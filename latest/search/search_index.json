{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"Home","text":""},{"location":"index.html#opensquirrel","title":"OpenSquirrel","text":"<p>This site contains the documentation for OpenSquirrel, i.e., a flexible quantum program compiler. OpenSquirrel chooses a modular, over a configurable, approach to prepare and optimize quantum circuits for heterogeneous target architectures.</p> <p>It has a user-friendly interface and is straightforwardly extensible with custom-made readers, compiler passes, and exporters. As a quantum circuit compiler, it is fully aware of the semantics of each gate and arbitrary quantum gates can be constructed manually. It understands the quantum programming language cQASM 3 and will support additional quantum programming languages in the future. It is developed in modern Python and follows best practices.</p> <p>[GitHub repository] [PyPI]</p>"},{"location":"index.html#table-of-contents","title":"Table of Contents","text":"<ul> <li>Tutorial</li> <li>Circuit builder</li> <li>Compilation passes</li> <li>API documentation</li> </ul>"},{"location":"index.html#authors","title":"Authors","text":"<p>Quantum Inspire (support@quantum-inspire.com)</p>"},{"location":"index.html#acknowledgements","title":"Acknowledgements","text":"<p>The Quantum Inspire project (by QuTech: a collaboration of TNO and TU Delft)</p>"},{"location":"installation.html","title":"Installation","text":""},{"location":"installation.html#installation","title":"Installation","text":"<p>OpenSquirrel is available through the Python Package Index (PyPI).</p> <p>Accordingly, installation is as easy as ABC: </p><pre><code>$ pip install opensquirrel\n</code></pre><p></p> <p>You can check if the package is installed by importing it: </p><pre><code>import opensquirrel\n</code></pre><p></p>"},{"location":"circuit-builder/index.html","title":"Circuit builder","text":"<p>Coming soon</p>"},{"location":"circuit-builder/instructions/control-instructions.html","title":"Control instructions","text":"<p>Coming soon</p>"},{"location":"circuit-builder/instructions/control-instructions.html#control-instructions","title":"Control Instructions","text":"Name Operator Description Example Barrier barrier Barrier gate <code>builder.barrier(0)</code> Wait wait Wait gate <code>builder.wait(0)</code>"},{"location":"circuit-builder/instructions/gates.html","title":"Gates","text":"<p>Coming soon</p>"},{"location":"circuit-builder/instructions/gates.html#unitary-instructions","title":"Unitary Instructions","text":"Name Operator Description Example I I Identity gate <code>builder.I(0)</code> H H Hadamard gate <code>builder.H(0)</code> X X Pauli-X <code>builder.X(0)</code> X90 X<sub>90</sub> Rotation around the x-axis of \\(\\frac{\\pi}{2}\\) <code>builder.X90(0)</code> mX90 X<sub>-90</sub> Rotation around the x-axis of \\(\\frac{-\\pi}{2}\\) <code>builder.mX90(0)</code> Y Y Pauli-Y <code>builder.Y(0)</code> Y90 Y<sub>90</sub> Rotation around the y-axis of \\(\\frac{\\pi}{2}\\) <code>builder.Y90(0)</code> mY90 Y<sub>-90</sub> Rotation around the y-axis of \\(\\frac{-\\pi}{2}\\) <code>builder.mY90(0)</code> Z Z Pauli-Z <code>builder.Z(0)</code> S S Phase gate <code>builder.S(0)</code> Sdag S<sup>\u2020</sup> S dagger gate <code>builder.Sdag(0)</code> T T T <code>builder.T(0)</code> Tdag T<sup>\u2020</sup> T dagger gate <code>builder.Tdag(0)</code> Rx R<sub>x</sub>(\\(\\theta\\)) Arbitrary rotation around x-axis <code>builder.Rx(0, 0.23)</code> Ry R<sub>y</sub>(\\(\\theta\\)) Arbitrary rotation around y-axis <code>builder.Ry(0, 0.23)</code> Rz R<sub>z</sub>(\\(\\theta\\)) Arbitrary rotation around z-axis <code>builder.Rz(0, 2)</code> Rn R<sub>n</sub>(n<sub>x</sub>, n<sub>y</sub>, n<sub>z</sub>, \\(\\theta\\), \\(\\phi\\)<sub>g</sub>) Arbitrary rotation around specified axis <code>builder.Rn(0)</code> CZ CZ Controlled-Z, Controlled-Phase <code>builder.CZ(1, 2)</code> CR CR(\\theta) Controlled phase shift (arbitrary angle) <code>builder.CR(0, 1, 3.1415)</code> CRk CR<sub>k</sub>(k) Controlled phase shift (\\(\\frac{\\pi}{2^{k-1}}\\)) <code>builder.CRk(1, 0, 2)</code> SWAP SWAP SWAP gate <code>builder.SWAP(1, 2)</code> CNOT CNOT Controlled-NOT gate <code>builder.CNOT(1, 2)</code>"},{"location":"circuit-builder/instructions/non-unitaries.html","title":"Non-unitaries","text":"<p>Coming soon</p>"},{"location":"circuit-builder/instructions/non-unitaries.html#non-unitary-instructions","title":"Non-Unitary Instructions","text":"Name Operator Description Example Init init Initialize certain qubits in \\(\\|0&gt;\\) <code>builder.init(0)</code> Measure measure Measure qubit argument <code>builder.measure(0)</code> Reset reset Reset a qubit's state to \\(\\|0&gt;\\) <code>builder.reset(0)</code>"},{"location":"compilation-passes/index.html","title":"Compilation passes","text":"<p>Compilation passes are essential steps in the process of converting a high-level quantum algorithm, i.e. quantum circuits, into a hardware-specific executable format. This process, known as quantum compilation, involves several stages to ensure that the quantum circuit can be executed efficiently on a given quantum hardware.</p> <p>Compilation passes include various optimization techniques and transformations applied to the quantum circuit. These passes can involve qubit routing, initial mapping, gate decomposition, or error correction. These optimization steps are essential to the execution of quantum algorithms. Often times, the design of quantum algorithms does not take into account the constraints or limitations imposed by the target hardware, such as qubit coupling map or native gate set.</p> <p>These passes are therefore needed to ensure that an initial circuit is converted to a version that adheres to the requirements of the hardware. They can easily be applied using the following methods on the <code>circuit</code> object:</p> <ul> <li>decompose</li> <li>export</li> <li>map</li> <li>merge</li> <li>route</li> <li>validate</li> </ul>"},{"location":"compilation-passes/index.html#types-of-passes","title":"Types of passes","text":"<p>Given the methods stated above, the following types of passes are available:</p> <ul> <li>Decomposer</li> <li>Exporter</li> <li>Mapper</li> <li>Merger</li> <li>Router</li> <li>Validator</li> </ul> <p>Integrated passes</p> <p>The reader and writer passes are integrated in particular functionalities of the circuit. They are not applied in the same way as the passes mentioned above, i.e., by passing them as an argument when calling one of the aforementiond methods on the circuit. Instead, the reader and writer are executed when one parses a cQASM string or writes out the circuit to a cQASM string, respectively. The reader is invoked when using the <code>Circuit.from_string</code> method, and the writer is invoked when converting the circuit to a string with <code>str</code> or printing it out with <code>print</code>.</p>"},{"location":"compilation-passes/decomposition/index.html","title":"Decomposition","text":"<p>Gate decomposition is a fundamental process in quantum compilation that involves breaking down complex quantum gates into a sequence of simpler, more elementary gates that can be directly implemented on quantum hardware. This step is crucial because most quantum processors can only perform a limited set of basic operations, such as single-qubit rotations and two-qubit entangling gates like the <code>CNOT</code> gate.</p> <p>The importance of gate decomposition lies in its ability to translate high-level quantum algorithms into executable instructions for quantum hardware. By decomposing complex gates into a series of elementary gates, the quantum compiler ensures that the algorithm can be run on the available hardware, regardless of its specific constraints and capabilities. This process ensures that the quantum algorithm is broken down into a series of gates that match the native gate set of the hardware.</p> <p>More in depth decomposition tutorials can be found in the decomposition example Jupyter notebook.</p>"},{"location":"compilation-passes/decomposition/aba-decomposer.html","title":"ABA decomposer","text":"<p>One of the most common single qubit decomposition techniques is the ZYZ decomposition. This technique decomposes a quantum gate into an <code>Rz</code>, <code>Ry</code> and <code>Rz</code> gate in that order. The decompositions are found in <code>opensquirrel.passes.decomposer</code>, an example can be seen below where a <code>H</code>, <code>Z</code>, <code>Y</code>, and <code>Rx</code> gate are all decomposed on a single qubit circuit.</p> <p></p><pre><code>from opensquirrel.circuit_builder import CircuitBuilder\nfrom opensquirrel.passes.decomposer import ZYZDecomposer\nimport math\n\nbuilder = CircuitBuilder(qubit_register_size=1)\nbuilder.H(0).Z(0).Y(0).Rx(0, math.pi / 3)\ncircuit = builder.to_circuit()\n\ncircuit.decompose(decomposer=ZYZDecomposer())\n\nprint(circuit)\n</code></pre> Output:<p></p> <pre><code>version 3.0\n\nqubit[1] q\n\nRz(3.1415927) q[0]\nRy(1.5707963) q[0]\nRz(3.1415927) q[0]\nRy(3.1415927) q[0]\nRz(1.5707963) q[0]\nRy(1.0471976) q[0]\nRz(-1.5707963) q[0]\n</code></pre> <p>Similarly, the decomposer can be used on individual gates.</p> <pre><code>from opensquirrel.passes.decomposer import ZYZDecomposer\nfrom opensquirrel import H\n\nprint(ZYZDecomposer().decompose(H(0)))\n</code></pre>"},{"location":"compilation-passes/decomposition/cnot-decomposer.html","title":"CNOT decomposer","text":"<p>Coming soon</p>"},{"location":"compilation-passes/decomposition/cz-decomposer.html","title":"CZ decomposer","text":"<p>Coming soon</p>"},{"location":"compilation-passes/decomposition/mckay-decomposer.html","title":"McKay decomposer","text":"<p>Coming soon</p>"},{"location":"compilation-passes/decomposition/predefined-decomposers.html","title":"Predefined decomposers","text":""},{"location":"compilation-passes/decomposition/predefined-decomposers.html#1-predefined-decomposition","title":"1. Predefined decomposition","text":"<p>The first kind of decomposition is when you want to replace a particular gate in the circuit, like the <code>CNOT</code> gate, with a fixed list of gates. It is commonly known that <code>CNOT</code> can be decomposed as <code>H</code>-<code>CZ</code>-<code>H</code>. This decomposition is demonstrated below using a Python lambda function, which requires the same parameters as the gate that is decomposed:</p> <p></p><pre><code>from opensquirrel.circuit import Circuit\nfrom opensquirrel import CNOT, H, CZ\n\ncircuit = Circuit.from_string(\n    \"\"\"\n    version 3.0\n    qubit[3] q\n\n    X q[0:2]  // Note that this notation is expanded in OpenSquirrel.\n    CNOT q[0], q[1]\n    Ry q[2], 6.78\n    \"\"\"\n)\ncircuit.replace(\n    CNOT,\n    lambda control, target:\n    [\n        H(target),\n        CZ(control, target),\n        H(target),\n    ]\n)\n\nprint(circuit)\n</code></pre> Output:<p></p> <pre><code>version 3.0\n\nqubit[3] q\n\nX q[0]\nX q[1]\nX q[2]\nH q[1]\nCZ q[0], q[1]\nH q[1]\nRy(6.78) q[2]\n</code></pre> <p>OpenSquirrel will check whether the provided decomposition is correct. For instance, an exception is thrown if we forget the final Hadamard, or H gate, in our custom-made decomposition:</p> <p></p><pre><code>from opensquirrel.circuit import Circuit\nfrom opensquirrel import CNOT, CZ, H\n\ncircuit = Circuit.from_string(\n    \"\"\"\n    version 3.0\n    qubit[3] q\n\n    X q[0:2]\n    CNOT q[0], q[1]\n    Ry q[2], 6.78\n    \"\"\"\n)\ntry:\n    circuit.replace(\n        CNOT,\n        lambda control, target:\n        [\n            H(target),\n            CZ(control, target),\n        ]\n    )\nexcept Exception as e:\n  print(e)\n</code></pre> Output:<p></p> <pre><code>replacement for gate CNOT does not preserve the quantum state\n</code></pre>"},{"location":"compilation-passes/decomposition/predefined-decomposers.html#cnot-to-cz-decomposer","title":"<code>CNOT</code> to <code>CZ</code> decomposer","text":"<p>The decomposition of the <code>CNOT</code> gate into a <code>CZ</code> gate (with additional single-qubit gates) is used frequently. To this end a <code>CNOT2CZDecomposer</code> has been implemented that decomposes any <code>CNOT</code>s in a circuit to a <code>Ry(-\u03c0/2)</code>-<code>CZ</code>-<code>Ry(\u03c0/2)</code>. The decomposition is illustrated in the image below.</p> <p></p> <p><code>Ry</code> gates are used instead of, e.g., <code>H</code> gates, as they are, generally, more likely to be supported already by target backends.</p>"},{"location":"compilation-passes/decomposition/predefined-decomposers.html#swap-to-cnot-decomposer","title":"<code>SWAP</code> to <code>CNOT</code> decomposer","text":"<p>The <code>SWAP2CNOTDecomposer</code> implements the predefined decomposition of the <code>SWAP</code> gate into 3 <code>CNOT</code> gates. The decomposition is illustrated in the image below.</p> <p></p>"},{"location":"compilation-passes/decomposition/predefined-decomposers.html#swap-to-cz-decomposer","title":"<code>SWAP</code> to <code>CZ</code> decomposer","text":"<p>The <code>SWAP2CZDecomposer</code> implements the predefined decomposition of the <code>SWAP</code> gate into <code>Ry</code> rotations and 3 <code>CZ</code> gates. The decomposition is illustrated in the image below.</p> <p></p>"},{"location":"compilation-passes/exporting/index.html","title":"Exporting","text":"<p>Instead of writing the circuit out to the default cQASM format, one can also use a custom exporter pass to export the circuit to a particular output format.</p> <p>Exporting can be done by calling the <code>export</code> method on the circuit object and providing the desired exporter <code>exporter</code> as an input argument to the call, e.g.,</p> <pre><code>from opensquirrel import CQasmV1Exporter\n\nexported_circuit = circuit.export(exporter=CQasmV1Exporter)\n</code></pre> <p>As shown in the example above, the exported circuit is given as the return value.</p> <p>The following exporting passes are available in OpenSquirrel:</p> <ul> <li>cQASMv1 exporter (<code>CQasmV1Exporter</code>)</li> <li>quantify-scheduler exporter (<code>QuantifySchedulerExporter</code>)</li> </ul> <p>Unsupported language features</p> <p>Note that certain features of the cQASM language may not be supported by the language to which the circuit is exported. These features are either processed by the exporter (e.g. control instructions), an error is raised, or some features will simply be lost/ignored and lose their intended effect. Especially, certain gates may not have a counterpart in the language that is exported to e.g. the general <code>Rn</code> gate. One could circumvent this latter issue by decomposing the circuit into gates that are supported. Make sure to consult the documentation on the particular exporters to understand the exporting process and result.</p>"},{"location":"compilation-passes/exporting/cqasm-v1-exporter.html","title":"cQASMv1 exporter","text":"<p>The cQASM v1 exporter (<code>CQasmV1Exporter</code>) exports the circuit to a string that adheres to the cQASM version 1.0 language specification.</p> <p>Here are some important differences to take note of:</p> <ol> <li>The version statement changes from <code>version 3.&lt;m&gt;</code> (where <code>&lt;m&gt;</code> refers to the minor version number) to <code>version 1.0</code>.</li> <li>All qubit register declarations are combined into a single (virtual) qubit register (<code>q</code>) statement.</li> <li>Bit registers declarations and assignments of measurement outcomes to bit register variables are discarded; cQASM version 1.0 does not support bit registers or variables. Note that the measurement statement is not discarded; the <code>measure</code> instruction is translated to <code>measure_z</code>. The outcome of a measurement on qubit at (virtual) index i will be stored at index i in the measurement register.</li> <li>The non-unitary <code>init</code> and <code>reset</code> instructions are both translated to <code>prep_z</code>.</li> <li>Instructions are translated to lowercase; even though, cQASM version 1.0 is not case-sensitive.</li> <li>Single gate multi qubit (SGMQ) notation is unpacked; the gate is applied to each qubit on a separate line.</li> <li>Consecutive <code>barrier</code> instructions are grouped in SGMQ notation to form a uniform barrier, across which no instructions on the specified qubits can be scheduled.</li> </ol> <p>Unsupported gates</p> <p>cQASM version 1.0 does not support the Rn gate and will raise an error (<code>UnSupportedGateError</code>) if this gate is part of the circuit that is to be exported. A single-qubit decomposition pass can be used to decompose the circuit to gates that the cQASM v1 exporter supports.</p> <p>The four examples below show how circuits written in cQASM are exported to cQASM v1.</p> Simple circuitRegisters<code>init</code> and <code>reset</code>SGMQ notation and uniform barriers <pre><code>from opensquirrel import Circuit\nfrom opensquirrel.passes.exporter import CQasmV1Exporter\n</code></pre> <pre><code>circuit = Circuit.from_string(\n    \"\"\"\n    version 3.0\n\n    qubit[2] q\n    bit[2] b\n\n    H q[0]\n    CNOT q[0], q[1]\n    b = measure q\n    \"\"\"\n)\n\nexported_circuit = circuit.export(exporter=CQasmV1Exporter)\nprint(exported_circuit)\n</code></pre> <pre><code>version 1.0\n\nqubits 2\n\nh q[0]\ncnot q[0], q[1]\nmeasure_z q[0]\nmeasure_z q[1]\n</code></pre> <p>Note that the version statement is changed (1.), the qubit register declaration is made into a statement (2.), the bit register declaration and assignment to bit variables have been discarded (3.), the instructions are in lowercase (5.), and the SGMQ notation has been unpacked (6.). The numbers refer to the differences listed above.</p> <pre><code>from opensquirrel import Circuit\nfrom opensquirrel.passes.exporter import CQasmv1Exporter\n</code></pre> <pre><code>circuit = Circuit.from_string(\n    \"\"\"\n    version 3.0\n\n    qubit[2] qA\n    bit[3] bA\n\n    H qA[0]\n    CNOT qA[0], qA[1]\n\n    bA[1,2] = measure qA\n\n    qubit[3] qB\n    bit[2] bB\n\n    H qB[1]\n    CNOT qB[1], qA[1]\n\n    bB[0] = measure qB[1]\n    bB[1] = measure qA[1]\n    \"\"\"\n)\n\nexported_circuit = circuit.export(exporter=CQasmv1Exporter)\nprint(exported_circuit)\n</code></pre> <pre><code>version 1.0\n\nqubits 5\n\nh q[0]\ncnot q[0], q[1]\nmeasure_z q[0]\nmeasure_z q[1]\nh q[3]\ncnot q[3], q[1]\nmeasure_z q[3]\nmeasure_z q[1]\n</code></pre> <p>Note that the version statement is changed (1.), the qubit register declaration is made into a statement (2.), the bit register declaration and assignment to bit variables have been discarded (3.), the instructions are in lowercase (5.), and the SGMQ notation has been unpacked (6.). The numbers refer to the differences listed above.</p> <p>In particular, this example illustrates that all qubit registers have been combined into a single (virtual) qubit register <code>q</code>, i.e., the registers <code>qA</code> and <code>qB</code> have been concatenated into <code>q</code>, such that <code>qA[0], qA[1] = q[0], q[1]</code> and <code>qB[0], qB[1], qB[2] = q[2], q[3], q[4]</code>. The qubit registers are concatenated in the order they are declared.</p> <p>Moreover, the bit registers have been discarded and the measurement instructions <code>measure_z</code> implicitly assign the measurement outcomes to the bit/measurement register index corresponding to the index of the (virtual) qubit that is measured. For instance, <code>bB[0] = measure qB[1]</code> is translated to <code>measure_z q[3]</code>, and the outcome will bestored at index 3 in the bit/measurement register. This also implies that different measurements on the same qubit, at (virtual) index i will always be stored in the same place, i.e. at index i, on the bit/measurement register. Which further implies that outcomes of subsequent measurements on the same qubit always overwrite the outcome of the previous measurement.</p> <pre><code>from opensquirrel import Circuit\nfrom opensquirrel.passes.exporter import CQasmV1Exporter\n</code></pre> <pre><code>circuit = Circuit.from_string(\n    \"\"\"\n    version 3.0\n\n    qubit[2] q\n    bit[2] b\n\n    init q\n\n    H q[0]\n    CNOT q[0], q[1]\n    b = measure q\n\n    reset q\n\n    H q[0]\n    Z q[0]\n    CNOT q[0], q[1]\n    b = measure q\n    \"\"\"\n)\n\nexported_circuit = circuit.export(exporter=CQasmV1Exporter)\nprint(exported_circuit)\n</code></pre> <pre><code>version 1.0\n\nqubits 2\n\nprep_z q[0]\nprep_z q[1]\nh q[0]\ncnot q[0], q[1]\nmeasure_z q[0]\nmeasure_z q[1]\nprep_z q[0]\nprep_z q[1]\nh q[0]\nz q[0]\ncnot q[0], q[1]\nmeasure_z q[0]\nmeasure_z q[1]\n</code></pre> <p>Note that the version statement is changed (1.), the qubit register declaration is made into a statement (2.), the bit register declaration and assignment to bit variables have been discarded (3.), the <code>init</code> and <code>reset</code> instructions are both translated to <code>prep_z</code> (4.), the instructions are in lowercase (5.), and the SGMQ notation has been unpacked (6.). The numbers refer to the differences listed above.</p> <p>In cQASM version 1.0, one cannot distinguish between an <code>init</code> and a <code>reset</code> instruction. The definition of the <code>prep_z</code> instruction is close to that of the <code>reset</code> instruction, i.e., the state of the qubit is set to \\(|0\\rangle\\) by first measuring it and then, conditioned on the outcome being 1, applying a Pauli-X gate.</p> <pre><code>from opensquirrel import Circuit\nfrom opensquirrel.passes.exporter import CQasmV1Exporter\n</code></pre> <pre><code>circuit = Circuit.from_string(\n    \"\"\"\n    version 3.0\n\n    qubit[4] q\n    bit[4] b\n\n    init q[0,1]\n\n    barrier q[0]\n\n    H q[0]\n    CNOT q[0], q[1]\n\n    init q[2]\n\n    barrier q[0]\n    barrier q[1]\n    barrier q[2]\n\n    H q[2]\n    b[0,1] = measure q[0,1]\n\n    init q[3]\n\n    barrier q[2, 3]\n    Z q[2]\n    CNOT q[2], q[3]\n\n    b[2,3] = measure q[2,3]\n    \"\"\"\n)\n\nexported_circuit = circuit.export(exporter=CQasmV1Exporter)\nprint(exported_circuit)\n</code></pre> <pre><code>version 1.0\n\nqubits 4\n\nprep_z q[0]\nprep_z q[1]\nbarrier q[0]\nh q[0]\ncnot q[0], q[1]\nprep_z q[2]\nbarrier q[0, 1, 2]\nh q[2]\nmeasure_z q[0]\nmeasure_z q[1]\nprep_z q[3]\nbarrier q[2, 3]\nz q[2]\ncnot q[2], q[3]\nmeasure_z q[2]\nmeasure_z q[3]\n</code></pre> <p>Note that the version statement is changed (1.), the qubit register declaration is made into a statement (2.), the bit register declaration and assignment to bit variables have been discarded (3.), the <code>init</code> instruction is translated to <code>prep_z</code> (4.), the instructions are in lowercase (5.), the SGMQ notation has been unpacked (6.) and consecutive <code>barrier</code> have been grouped in SGMQ notation to form a uniform barrier (7.). The numbers refer to the differences listed above.</p> <p>The three consecutive barrier instructions, following the <code>init q[2]</code> statement, have been grouped using SGMQ notation. They form a uniform barrier across all the specified qubits, instead of a single barrier on each of the respective qubits. Also, in contrast to other instructions where the SGMQ notation has been unpacked, the SGMQ notation for the statement <code>barrier q[2, 3]</code> has been preserved.</p>"},{"location":"compilation-passes/exporting/quantify-scheduler-exporter.html","title":"quantify-scheduler exporter","text":"<p>The quantify-scheduler exporter (<code>QuantifySchedulerExporter</code>) exports the circuit to a <code>Schedule</code> object.</p> <p>The bit string mapping has been deprecated</p> <p>The <code>QuantifySchedulerExporter</code> used to return a bit string mapping next to the <code>Schedule</code>. This bit string mapping has been deprecated. To obtain a mapping from the measurements to the bit register index their outcomes are assigned to, use the circuit property <code>Circuit.measurement_to_bit_map</code>, instead. This mapping has the following structure:</p> <pre><code>{\n    &lt;qubit-index: str&gt; : [\n        &lt;bit-index: int&gt;,\n        &lt;bit-index: int&gt;,\n        ...\n    ],\n    &lt;qubit-index: str&gt; : [ ... ],\n    ...\n}\n</code></pre> <p>Each qubit at index \\(i\\) contains a list of bit indices. The index \\(j\\) of this list is the measurement index and denotes the order in which the qubit was measured. The values at \\(j\\) denote the bit register index \\(k\\) to which the measurement outcome was assigned in the circuit. Qubits that are not measured do not have an entry in the measurement to bit mapping.</p> <p>Here are some important differences to take note of:</p> <ol> <li>All qubit register declarations are combined into a single (virtual) qubit register (<code>q</code>) statement.</li> <li>Bit registers declarations and assignments of measurement outcomes to bit register variables are discarded; quantify-scheduler does not support bit registers or variables. Note that the measurement statement is not discarded; the <code>measure</code> instruction is translated to <code>Measure</code>. Furthermore, measurement outcomes are related to the (virtual) bit registers they were assigned to in the cQASM circuit. Their mapping can be obtained through the <code>Circuit.measurement_to_bit_map</code> property, as described above.</li> <li>The non-unitary <code>init</code> instruction is ignored and <code>reset</code> instruction is translated to <code>Reset</code>. The <code>reset</code> instruction can be used to set the state of the qubit to the \\(|0\\rangle\\) state, similar to the effect of the <code>init</code> instruction.</li> <li>Single gate multi qubit (SGMQ) notation is unpacked; the gate is applied to each qubit on a separate line.</li> <li>Control instructions (<code>barrier</code> and <code>wait</code>) are currently not supported. Note: processing of the control instructions is currently under active development, but not yet part of the latest version of OpenSquirrel.</li> <li>Angles are translated from radians to degrees.</li> </ol> <p>Unsupported gates</p> <p>The quantify-scheduler exporter does not support the Rn gate in general. Unless both the \\(n_x\\) and \\(n_y\\) components are zero, or just the \\(n_z\\) component is zero, it will raise an error (<code>UnSupportedGateError</code>) if this gate is part of the circuit that is to be exported.</p> <p>The same error is raised if the circuit to be exported contains a Hadamard, SWAP, or any arbitrary two-qubit gate that is not either a CNOT or CZ gate. Decomposition passes can be used to decompose the circuit to gates that the quantify-scheduler exporter supports.</p> <p>The four examples below show how circuits written in cQASM are exported to a quantify-scheduler <code>Schedule</code>.</p> Simple circuitRegisters<code>init</code> and <code>reset</code> <pre><code>from opensquirrel import Circuit\nfrom opensquirrel.passes.exporter import QuantifySchedulerExporter\n</code></pre> <pre><code>circuit = Circuit.from_string(\n    \"\"\"\n    version 3.0\n\n    qubit[2] q\n    bit[2] b\n\n    H q[0]\n    CNOT q[0], q[1]\n    b = measure q\n    \"\"\"\n)\n\nexported_schedule = circuit.export(exporter=QuantifySchedulerExporter)\n\nfor schedulable in exported_schedule.schedulables.values():\n    print(exported_schedule.operations[schedulable[\"operation_id\"]].name)\nprint('\\n', \"measurement to bit map: \", circuit.measurement_to_bit_map)\n</code></pre> <pre><code>Rxy(90, 90, 'q[0]')\nRxy(180, 0, 'q[0]')\nCNOT (q[0], q[1])\nMeasure q[0]\nMeasure q[1]\n\nmeasurement to bit map: {\"0\": [0], \"1\": [1]}\n</code></pre> <p>Note that the bit register declaration and assignment to bit variables have been discarded (2.), the SGMQ notation has been unpacked (4.), and the angles have been translated from radians to degrees (6.). The numbers refer to the differences listed above.</p> <p>According to the description of the measurement to bit mapping above, note that the outcome of the first measurement (\\(j=0\\)) on qubit at index \\(i=0\\), is mapped to the (virtual) bit variable at index \\(k=0\\), and the outcome of the first measurement (\\(j=0\\)) on qubit at index \\(i=1\\), is mapped to the (virtual) bit variable at index \\(k=1\\).</p> <pre><code>from opensquirrel import Circuit\nfrom opensquirrel.passes.exporter import QuantifySchedulerExporter\n</code></pre> <pre><code>circuit = Circuit.from_string(\n    \"\"\"\n    version 3.0\n\n    qubit[2] qA\n    bit[3] bA\n\n    H qA[0]\n    CNOT qA[0], qA[1]\n\n    bA[1,2] = measure qA\n\n    qubit[3] qB\n    bit[2] bB\n\n    H qB[1]\n    CNOT qB[1], qA[1]\n\n    bB[0] = measure qB[1]\n    bB[1] = measure qA[1]\n    \"\"\"\n)\n\nexported_circuit = circuit.export(exporter=QuantifySchedulerExporter)\nfor schedulable in exported_schedule.schedulables.values():\n    print(exported_schedule.operations[schedulable[\"operation_id\"]].name)\nprint('\\n', \"measurement to bit map: \", circuit.measurement_to_bit_map)\n</code></pre> <pre><code>Rxy(90, 90, 'q[0]')\nRxy(180, 0, 'q[0]')\nCNOT (q[0], q[1])\nMeasure q[0]\nMeasure q[1]\nRxy(90, 90, 'q[3]')\nRxy(180, 0, 'q[3]')\nCNOT (q[3], q[1])\nMeasure q[3]\nMeasure q[1]\n\nmeasurement to bit map:  {\"0\": [1], \"1\": [2, 4], \"3\": [3]}\n</code></pre> <p>Note that all qubit register declarations are combined into a single (virtual) qubit register (1.), the bit register declaration and assignment to bit variables have been discarded (2.), the SGMQ notation has been unpacked (4.), and the angles have been translated from radians to degrees (6.). The numbers refer to the differences listed above.</p> <p>In particular, this example illustrates that all qubit registers have been combined into a single (virtual) qubit register <code>q</code>, i.e., the registers <code>qA</code> and <code>qB</code> have been concatenated into <code>q</code>, such that <code>qA[0], qA[1] = q[0], q[1]</code> and <code>qB[0], qB[1], qB[2] = q[2], q[3], q[4]</code>. The qubit registers are concatenated in the order they are declared.</p> <p>Moreover, even though the bit registers have been discarded in the circuit, the mapping from meausurement to (virtual) bit variable has been stored in the measurement to bit mapping. Note that, just like with the translation of the qubit register declarations to the single virtual register <code>q</code>, the bit register declarations are also concatenated in the order they are declared into a single bit register <code>b</code>. In this example, the virtual bit register translation is as follows: <code>bA[0], bA[1], bA[2] = b[0], b[1], b[2]</code> and <code>bB[0], bB[1] = b[3], b[4]</code>.</p> <p>For instance, the statement <code>bB[1] = measure qA[1]</code> in the original circuit becomes, in terms of virtual registers, <code>b[4] = measure q[1]</code>. Note that in the measurement to bit mapping the outcome of the second measurement (measurement index \\(j=1\\)) on <code>q[1]</code>, i.e. qubit at index \\(i=1\\), is assigned to the bit at index \\(k=4\\).</p> <pre><code>from opensquirrel import Circuit\nfrom opensquirrel.passes.exporter import QuantifySchedulerExporter\n</code></pre> <pre><code>circuit = Circuit.from_string(\n    \"\"\"\n    version 3.0\n\n    qubit[2] q\n    bit[2] b\n\n    init q\n\n    H q[0]\n    CNOT q[0], q[1]\n    b = measure q\n\n    reset q\n\n    H q[0]\n    Z q[0]\n    CNOT q[0], q[1]\n    b = measure q\n    \"\"\"\n)\n\nexported_circuit = circuit.export(exporter=QuantifySchedulerExporter())\nfor schedulable in exported_schedule.schedulables.values():\n    print(exported_schedule.operations[schedulable[\"operation_id\"]].name)\nprint('\\n', \"measurement to bit map: \", circuit.measurement_to_bit_map)\n</code></pre> <pre><code>Reset q[0]\nReset q[1]\nRxy(90, 90, 'q[0]')\nRxy(180, 0, 'q[0]')\nCNOT (q[0], q[1])\nMeasure q[0]\nMeasure q[1]\nReset q[0]\nReset q[1]\nRxy(90, 90, 'q[0]')\nRxy(180, 0, 'q[0]')\nRz(180, 'q[0]')\nCNOT (q[0], q[1])\nMeasure q[0]\nMeasure q[1]\n\nmeasurement to bit map:  {\"0\": [0, 0], \"1\": [1, 1]}\n</code></pre> <p>Note that the bit register declaration and assignment to bit variables have been discarded (2.), the <code>init</code> instructions have been ignored and the <code>reset</code> instructions have been translated to Reset, the SGMQ notation has been unpacked (4.), and the angles have been translated from radians to degrees (6.). The numbers refer to the differences listed above.</p> <p>The quantify-scheduler operation library does not distinguish between an <code>init</code> and a <code>reset</code> instruction. For now, the <code>init</code> instruction is ignored and the <code>reset</code> instruction is translated to Reset. Note that one can us the <code>reset</code> instruction to set the state of the qubit to the \\(|0\\rangle\\) state, which is similar to the effect of the <code>init</code> instruction.</p> <p>macOS ARM not supported</p> <p>The quantify-scheduler exporter cannot run on macOS ARM, due to the fact that the required dependency <code>pyqt5-qt5==5.15.2</code> does provide binaries for that architecture.</p>"},{"location":"compilation-passes/mapping/index.html","title":"Mapping","text":"<p>Qubit mapping, also known as initial mapping, is a critical step in the quantum compilation process. It involves assigning logical qubits, which are used in the quantum algorithm, to physical qubits available on the quantum hardware. This mapping is essential because the physical qubits on a quantum processor have specific connectivity constraints, meaning not all qubits can directly interact with each other. The initial mapping must respect these constraints to ensure that the required two-qubit gates can be executed without violating the hardware's connectivity limitations.</p> <p>A poor initial mapping can lead to a high number of SWAP operations, which are used to move qubits into positions where they can interact. SWAP operations increase the circuit depth and introduce additional errors. An optimal initial mapping minimizes the need for these operations, thereby reducing the overall error rate and improving the fidelity of the quantum computation. Efficient qubit mapping can significantly enhance the performance of the quantum circuit. By strategically placing qubits, the compiler can reduce the number of additional operations required, leading to faster and more reliable quantum computations.</p> <p>The following mapping passes are available in Opensquirrel:</p> <ul> <li>Hardcoded Mapper (<code>HardcodedMapper</code>)</li> <li>Identity Mapper (<code>IdentitiyMapper</code>)</li> <li>Random Mapper (<code>RandomMapper</code>)</li> <li>QGym Mapper (<code>QGymMapper</code>)</li> </ul>"},{"location":"compilation-passes/mapping/hardcoded-mapper.html","title":"Hardcoded mapper","text":"<p>With this mapper, the initial mapping is simply hardcoded.</p>"},{"location":"compilation-passes/mapping/identity-mapper.html","title":"Identity mapper","text":"<p>The Identity Mapper simply maps each virtual qubit on the circuit to its corresponding physical qubit on the device, index-wise.</p>"},{"location":"compilation-passes/mapping/qgym-mapper.html","title":"QGym mapper","text":"<p>The QGym package functions in a manner similar to the well-known gym package, in the sense that it provides a number of environments on which reinforcement learning (RL) agents can be applied. The main purpose of qgym is to develop reinforcement learning environments which represent various passes of the OpenQL framework.</p> <p>The package offers RL-based environments resembling quantum compilation steps, namely for initial mapping, qubit routing, and gate scheduling. The environments offer all the relevant components needed to train agents, including states and action spaces, and (customizable) reward functions (basically all the components required by a Markov Decision Process). Furthermore, the actual training of the agents is handled by the StableBaselines3 python package, which offers reliable, customizable, out of the box Pytorch implementations of DRL agents.</p> <p>The initial mapping problem is translated to a RL context within QGym in the following manner. The setup begins with a fixed connection graph (an undirected graph representation of the hardware connectivity), static across all episodes. Each episode introduces a novel, randomly generated interaction graph (undirected graph representation of the qubit interactions within the circuit) for the agent to observe, alongside an initially empty mapping. At every step, the agent can map a virtual qubit to a physical qubit until the mapping is fully established. In theory, this process enables the training of agents that are capable of managing various interaction graphs on a predetermined connectivity. Both the interaction and connection graphs are easily represented via Networkx graphs.</p> <p>At the moment, the following DRL agents can be used to map circuits in Opensquirrel:</p> <ul> <li>Proximal Policy Optimization (PPO)</li> <li>Advantage Actor-Critic (A2C)</li> <li>Trust Region Policy Optimization (TRPO)</li> <li>Recurrent PPO</li> <li>PPO with illegal action masking</li> </ul> <p>The last three agents in the list above can be imported from the extension/experimental package of StableBaselines3, namely sb3-contrib.</p> <p>The following code snippet demonstrates the usage of the <code>QGymMapper</code>.</p> <p>We assume that the <code>connectivity</code> of the target backend QPU is known, as well as that a <code>TRPO.zip</code> file, containing the weights of a trained agent, is available in the working directory.</p> <pre><code>from opensquirrel.passes.mapper import QGymMapper\nfrom opensquirrel import CircuitBuilder\nimport networkx as nx\nimport json\n\nconnectivity = {\n        \"0\": [2],\n        \"1\": [2],\n        \"2\": [0, 1, 3, 4],\n        \"3\": [2],\n        \"4\": [2],\n}\n\nqgym_mapper = QGymMapper(\n    agent_class=\"TRPO\",\n    agent_path=\"path-to-agent/TRPO.zip\",\n    connectivity=connectivity\n)\n\nbuilder = CircuitBuilder(5)\nbuilder.H(0)\nbuilder.CNOT(0, 1)\nbuilder.H(2)\nbuilder.CNOT(1, 2)\nbuilder.CNOT(2, 4)\nbuilder.CNOT(3, 4)\ncircuit = builder.to_circuit()\n\ncircuit.map(mapper = qgym_mapper)\n</code></pre>"},{"location":"compilation-passes/mapping/random-mapper.html","title":"Random mapper","text":"<p>This mapper pass generates a random initial mapping from virtual qubits from physical qubits.</p>"},{"location":"compilation-passes/merging/index.html","title":"Merging","text":"<p>Merger passes in OpenSquirrel are used to merge gates into single operations. Their main purpose is to reduce the circuit depth.</p> <p>Note that the gate that results from merging two gates will in general be an arbitrary operation, i.e., not be a known gate. In most cases, subsequent decomposition of the gates will be required in order to execute the circuit on a target backend. The kind of decomposition pass required will depend on the primitive gate set that the intended backend supports.</p> <p>OpenSquirrel currently facilitates the following merge pass:</p> <ul> <li>Single-qubit gates merger (<code>SingleQubitGatesMerger</code>)</li> </ul>"},{"location":"compilation-passes/merging/single-qubit-gates-merger.html","title":"Single-qubit gates merger","text":"<p>All single-qubit gates appearing in a circuit can be merged by using the single-qubit gates merging pass (<code>SingleQubitGatesMerger</code>). Note that multi-qubit gates remain untouched and single-qubit gates are not merged across any multi-qubit gates. Single-qubit gates are also not merged across non-unitary instructions, e.g. <code>init</code>, <code>reset</code>, and <code>measure</code>, and control instructions, e.g., <code>wait</code>, and <code>barrier</code>. Merging single-qubit gates may lead to a significant reduction in circuit depth, i.e., the number of operations required to execute the circuit.</p> <p>OpenSquirrel will try to recognize whether the resulting gate is a known gate, e.g., if two consecutive X90 gates are merged, OpenSquirrel will recognize it as a single X gate. Nevertheless, the gate that results from the merger of multiple single-qubit gates will, in general, be an arbitrary rotation. Accordingly, to be able to run the circuit on a particular backend that supports a given primitive gate set, it is often required to perform a decomposition pass after merging the single-qubit gates.</p> <p>Note</p> <p>Depending on the circuit and chosen decomposition, the circuit depth might actually increase, even though a merging pass has been applied. For instance, if the merging of two single-qubit gates leads to an arbitrary single-qubit rotation gate and the <code>McKayDecomposer</code> is used, then the two initial gates may ultimately result in five single-qubit rotation gates. This is demonstrated in the final example below.</p> <p>The example below shows how the single-qubit gates merging pass can be used to merge the single-qubit gates in the circuit. Note that the <code>SingleQubitGatesMerger</code> pass does not require any input arguments.</p> <p>Check the circuit builder on how to generate a circuit.</p> <pre><code>from opensquirrel import CircuitBuilder\nfrom opensquirrel.passes.merger import SingleQubitGatesMerger\nfrom math import pi  # not necessary for using the SingleQubitGatesMerger\n</code></pre> <pre><code>builder = CircuitBuilder(1)\nfor _ in range(4):\n    builder.Rx(0, pi / 4)\ncircuit = builder.to_circuit()\n\ncircuit.merge(merger=SingleQubitGatesMerger())\n</code></pre> <code>print(circuit)</code> <pre><code>version 3.0\n\nqubit[1] q\n\nRx(3.1415927) q[0]\n</code></pre> <p>The above example shows how four consecutive Rx rotations over \\(\\pi/4\\), are merged into a single Rx rotation over \\(\\pi\\).</p> <p>The following example shows that the merging of single-qubit gates does not occur across multi-qubit gates, non-unitary instructions, and control instructions.</p> <pre><code>builder = CircuitBuilder(2, 2)\nbuilder.Ry(0, pi / 2).X(0).CNOT(0, 1).H(0).X(1)\nbuilder.barrier(1)\nbuilder.H(0).X(1).measure(0, 0).H(0).X(1)\ncircuit = builder.to_circuit()\n\ncircuit.merge(merger=SingleQubitGatesMerger())\n</code></pre> <code>print(circuit)</code> <pre><code>version 3.0\n\nqubit[2] q\nbit[2] b\n\nH q[0]\nCNOT q[0], q[1]\nH q[0]\nX q[1]\nbarrier q[1]\nH q[0]\nb[0] = measure q[0]\nH q[0]\n</code></pre> <p>Note</p> <p>In the above example, note that even though the <code>barrier</code> is placed on qubit at index 1, that the Hadamards (<code>H</code>) on qubit at index 0 on either side of that barrier are not merged. Barriers are unique in this regard; no merging of single-qubit gates occurs across barriers regardless of the qubit on which the barrier acts.</p> <p>The final example below shows how the circuit depth ultimately increases, even though the single-qubit gates where merged using the single-qubit gates merging pass.</p> <pre><code>builder = CircuitBuilder(1)\nbuilder.Rx(0, pi / 3).Ry(0, pi / 5)\ncircuit = builder.to_circuit()\n\ncircuit.merge(merger=SingleQubitGatesMerger())\ncircuit.decompose(decomposer=McKayDecomposer())\n</code></pre> <code>print(circuit)</code> <pre><code>version 3.0\n\nqubit[1] q\n\nRz(-2.2688338) q[0]\nX90 q[0]\nRz(1.9872376) q[0]\nX90 q[0]\nRz(-1.2436334) q[0]\n</code></pre>"},{"location":"compilation-passes/routing/index.html","title":"Routing","text":"<p>The qubit routing pass is a crucial step in the process of quantum compilation. It ensures that two-qubit interactions can be executed given a certain target backend.</p> <p>On quantum processing units (QPUs) qubits are often arranged in specific topologies where only certain pairs of qubits can directly interact. Which qubits can interact is given by a mapping called the backend connectivity, e.g.:</p> LinearStar-shapedDiamond-shaped <pre><code>connectivity = {\n    \"0\": [1],\n    \"1\": [0, 2],\n    \"2\": [1, 3],\n    \"3\": [2, 4],\n    \"4\": [3]\n}\n</code></pre> <pre><code>connectivity = {\n    \"0\": [2],\n    \"1\": [2],\n    \"2\": [0, 1, 3, 4],\n    \"3\": [2],\n    \"4\": [2]\n}\n</code></pre> <pre><code>connectivity = {\n    \"0\": [1, 2],\n    \"1\": [0, 3, 4],\n    \"2\": [0, 4, 5],\n    \"3\": [1, 4, 6],\n    \"4\": [1, 2, 6, 7],\n    \"5\": [2, 4, 7],\n    \"6\": [3, 4, 8],\n    \"7\": [4, 5, 8],\n    \"8\": [6, 7],\n}\n</code></pre> <p>The routing pass modifies the quantum circuit by inserting operations\u2014typically SWAP gates\u2014 that distribute the qubits such that the defined interactions can take place between connected qubits. In other words, it ensures that all qubit interactions respect the connectivity constraints, making the circuit executable on the target backend.</p> <p>The following routing passes are available in Opensquirrel:</p> <ul> <li>A* router (<code>AStarRouter</code>)</li> <li>Shortest-path router (<code>ShortestPathRouter</code>)</li> </ul>"},{"location":"compilation-passes/routing/a-star-router.html","title":"A* router","text":"<p>The A* (pronounced A-star) qubit routing pass (<code>AStarRouter</code>) uses the A* search algorithm to find the optimal path between qubits that need to interact but are not directly connected, given the backend connectivity. By leveraging one of the following distance metrics as a heuristic:</p> <ul> <li>Manhattan,</li> <li>Euclidean, or</li> <li>Chebyshev.</li> </ul> <p>It balances the trade-off between circuit depth and computational efficiency. This approach ensures that SWAP gates are inserted along the most efficient paths, minimizing the overall cost of routing while adhering to the connectivity constraints.</p> <p>The examples below show how the A* qubit routing pass, along with specified distance metrics, can be used to route circuits in OpenSquirrel, given the connectivity of the backend.</p> <p>Check the circuit builder on how to generate a circuit.</p> <pre><code>from opensquirrel import CircuitBuilder\nfrom opensquirrel.passes.router import AStarRouter\nfrom opensquirrel.passes.router.heuristics import DistanceMetric\n</code></pre> <pre><code>connectivity = {\"0\": [1], \"1\": [0, 2], \"2\": [1, 3], \"3\": [2, 4], \"4\": [3]}\n\nbuilder = CircuitBuilder(5)\nbuilder.CNOT(0, 1)\nbuilder.CNOT(1, 2)\nbuilder.CNOT(2, 3)\nbuilder.CNOT(3, 4)\nbuilder.CNOT(0, 4)\ncircuit = builder.to_circuit()\n\na_star_router = AStarRouter(\n    connectivity=connectivity,\n    distance_metric=DistanceMetric.MANHATTAN\n)\ncircuit.route(router=a_star_router)\n</code></pre> <code>print(circuit)</code> <pre><code>version 3.0\n\nqubit[5] q\n\nCNOT q[0], q[1]\nCNOT q[1], q[2]\nCNOT q[2], q[3]\nCNOT q[3], q[4]\nSWAP q[0], q[1]\nSWAP q[1], q[2]\nSWAP q[2], q[3]\nCNOT q[3], q[4]\n</code></pre> <pre><code>connectivity = {\n        \"0\": [1, 2, 5],\n        \"1\": [0, 3, 6],\n        \"2\": [0, 4, 7],\n        \"3\": [1, 5, 8],\n        \"4\": [2, 6, 9],\n        \"5\": [0, 3, 7],\n        \"6\": [1, 4, 8],\n        \"7\": [2, 5, 9],\n        \"8\": [3, 6, 9],\n        \"9\": [4, 7, 8],\n}\n\nbuilder = CircuitBuilder(10)\nbuilder.CNOT(0, 9)\nbuilder.CNOT(1, 8)\nbuilder.CNOT(2, 7)\nbuilder.CNOT(3, 6)\nbuilder.CNOT(4, 5)\nbuilder.CNOT(0, 2)\nbuilder.CNOT(1, 3)\nbuilder.CNOT(4, 6)\nbuilder.CNOT(5, 7)\nbuilder.CNOT(8, 9)\nbuilder.CNOT(0, 5)\nbuilder.CNOT(1, 6)\nbuilder.CNOT(2, 8)\nbuilder.CNOT(3, 9)\ncircuit = builder.to_circuit()\n\na_star_router = AStarRouter(\n    connectivity=connectivity,\n    distance_metric=DistanceMetric.CHEBYSHEV\n)\ncircuit.route(router=a_star_router)\n</code></pre> <code>print(circuit)</code> <pre><code>version 3.0\n\nqubit[10] q\n\nSWAP q[0], q[2]\nSWAP q[2], q[4]\nCNOT q[4], q[9]\nSWAP q[1], q[6]\nCNOT q[6], q[8]\nSWAP q[0], q[2]\nCNOT q[2], q[7]\nCNOT q[3], q[6]\nCNOT q[0], q[5]\nCNOT q[4], q[2]\nSWAP q[6], q[1]\nCNOT q[1], q[3]\nSWAP q[0], q[1]\nCNOT q[1], q[6]\nCNOT q[5], q[7]\nCNOT q[8], q[9]\nSWAP q[4], q[2]\nSWAP q[2], q[0]\nCNOT q[0], q[5]\nSWAP q[2], q[4]\nCNOT q[4], q[6]\nSWAP q[2], q[4]\nSWAP q[4], q[9]\nCNOT q[9], q[8]\nSWAP q[3], q[8]\nSWAP q[8], q[9]\nCNOT q[9], q[9]\n</code></pre> <p>If, based on the connectivity, a certain interaction is not possible, the A* router will throw an error; as shown in the following example where qubits 0 and 1 are disconnected from qubits 2 and 3.</p> <pre><code>connectivity = {\"0\": [1], \"1\": [0], \"2\": [3], \"3\": [2]}\n\nbuilder = CircuitBuilder(4)\nbuilder.CNOT(0, 2)\nbuilder.CNOT(3, 1)\ncircuit = builder.to_circuit()\n\na_star_router = AStarRouter(\n    connectivity=connectivity,\n    distance_metric=DistanceMetric.EUCLIDEAN\n)\ncircuit.route(router=a_star_router)\n</code></pre> <p><code>NoRoutingPathError: No routing path available between qubit 0 and qubit 2</code></p>"},{"location":"compilation-passes/routing/shortest-path-router.html","title":"Shortest-path router","text":"<p>The shortest-path routing pass (<code>ShortestPathRouter</code>) ensures that qubit interactions in a circuit can be executed given the target backend connectivity. It inserts the necessary SWAP gates along the shortest path, moving the qubits closer together so the intended operation can be performed. This approach aims to minimize the number of SWAPs required for each interaction by using the <code>shortest_path</code> method from the <code>networkx</code> package. While it uses a straightforward algorithm, it may result in an overly increased circuit depth.</p> <p>The following examples showcase the usage of the shortest-path routing pass. Note that the backend connectivity is required as an input argument.</p> <p>Check the circuit builder on how to generate the circuit.</p> <pre><code>from opensquirrel import CircuitBuilder\nfrom opensquirrel.passes.router import ShortestPathRouter\n</code></pre> <pre><code>connectivity = {\"0\": [1], \"1\": [0, 2], \"2\": [1, 3], \"3\": [2, 4], \"4\": [3]}\n\nbuilder = CircuitBuilder(5)\nbuilder.CNOT(0, 1)\nbuilder.CNOT(1, 2)\nbuilder.CNOT(2, 3)\nbuilder.CNOT(3, 4)\nbuilder.CNOT(0, 4)\ncircuit = builder.to_circuit()\n\nshortest_path_router = ShortestPathRouter(connectivity=connectivity)\ncircuit.route(router=shortest_path_router)\n</code></pre> <code>print(circuit)</code> <pre><code>version 3.0\n\nqubit[5] q\n\nCNOT q[0], q[1]\nCNOT q[1], q[2]\nCNOT q[2], q[3]\nCNOT q[3], q[4]\nSWAP q[0], q[1]\nSWAP q[1], q[2]\nSWAP q[2], q[3]\nCNOT q[3], q[4]\n</code></pre> <pre><code>connectivity = {\n    \"0\": [1, 2],\n    \"1\": [0, 3],\n    \"2\": [0, 4],\n    \"3\": [1, 5],\n    \"4\": [2, 5],\n    \"5\": [3, 4, 6],\n    \"6\": [5]\n}\n\nbuilder = CircuitBuilder(7)\nbuilder.CNOT(0, 6)\nbuilder.CNOT(1, 5)\nbuilder.CNOT(2, 4)\nbuilder.CNOT(3, 6)\nbuilder.CNOT(0, 2)\nbuilder.CNOT(1, 3)\nbuilder.CNOT(4, 5)\nbuilder.CNOT(5, 6)\ncircuit = builder.to_circuit()\n\nshortest_path_router = ShortestPathRouter(connectivity=connectivity)\ncircuit.route(router=shortest_path_router)\n</code></pre> <code>print(circuit)</code> <pre><code>version 3.0\n\nqubit[7] q\n\nSWAP q[0], q[1]\nSWAP q[1], q[3]\nSWAP q[3], q[5]\nCNOT q[5], q[6]\nSWAP q[0], q[1]\nCNOT q[1], q[5]\nCNOT q[2], q[4]\nSWAP q[0], q[1]\nSWAP q[1], q[3]\nSWAP q[3], q[5]\nCNOT q[5], q[6]\nSWAP q[3], q[1]\nSWAP q[1], q[0]\nCNOT q[0], q[2]\nSWAP q[1], q[3]\nCNOT q[3], q[3]\nSWAP q[4], q[2]\nSWAP q[2], q[0]\nCNOT q[0], q[5]\nSWAP q[1], q[3]\nSWAP q[3], q[5]\nCNOT q[5], q[6]\n</code></pre> <p>If, based on the connectivity, a certain interaction is not possible, the shortest-path router will throw an error; as shown in the following example where qubits 0 and 1 are disconnected from qubits 2 and 3.</p> <pre><code>connectivity = {\"0\": [1], \"1\": [0], \"2\": [3], \"3\": [2]}\n\nbuilder = CircuitBuilder(4)\nbuilder.CNOT(0, 2)\nbuilder.CNOT(3, 1)\ncircuit = builder.to_circuit()\n\nshortest_path_router = ShortestPathRouter(connectivity=connectivity)\ncircuit.route(router=shortest_path_router)\n</code></pre> <p><code>NoRoutingPathError: No routing path available between qubit 0 and qubit 2</code></p>"},{"location":"compilation-passes/validation/index.html","title":"Validation","text":"<p>Validator passes in OpenSquirrel are meant to provide some tools to check whether a quantum circuit is executable given the constraints imposed by the target backend. OpenSquirrel facilitates the following validation passes:</p> <ul> <li>Interaction validator (<code>InteractionValidator</code>)</li> <li>Primitive gate validator (<code>PrimitiveGateValidator</code>)</li> </ul>"},{"location":"compilation-passes/validation/interaction-validator.html","title":"Interaction validator","text":"<p>This pass checks whether all interactions in the circuit, i.e. two-qubit gates, are executable given the backend connectivity. If certain interactions are not possible, the validator will throw a <code>ValueError</code>, specifying which interactions cannot be executed.</p> <p>The interaction validator (<code>InteractionValidator</code>) can be used in the following manner.</p> <p>Check the circuit builder on how to generate a circuit.</p> <pre><code>from opensquirrel import CircuitBuilder\nfrom opensquirrel.passes.validator import InteractionValidator\n</code></pre> <pre><code>connectivity = {\n    \"0\": [1, 2],\n    \"1\": [0, 2, 3],\n    \"2\": [0, 1, 4],\n    \"3\": [1, 4],\n    \"4\": [2, 3]\n}\n\nbuilder = CircuitBuilder(5)\nbuilder.H(0)\nbuilder.CNOT(0, 1)\nbuilder.H(2)\nbuilder.CNOT(1, 2)\nbuilder.CNOT(2, 4)\nbuilder.CNOT(3, 4)\ncircuit = builder.to_circuit()\n\ninteraction_validator = InteractionValidator(connectivity=connectivity)\ncircuit.validate(validator=interaction_validator)\n</code></pre> <p>In the scenario above, there will be no output since all qubit interactions are executable given the connectivity. On the other hand, the circuit below will raise an error (<code>ValueError</code>) as certain interactions are not possible.</p> <pre><code>builder = CircuitBuilder(5)\nbuilder.H(0)\nbuilder.CNOT(0, 1)\nbuilder.CNOT(0, 3)\nbuilder.H(2)\nbuilder.CNOT(1, 2)\nbuilder.CNOT(1, 3)\nbuilder.CNOT(2, 3)\nbuilder.CNOT(3, 4)\nbuilder.CNOT(0, 4)\ncircuit = builder.to_circuit()\n\ncircuit.validate(validator=interaction_validator)\n</code></pre> <p><code>ValueError: the following qubit interactions in the circuit prevent a 1-to-1 mapping:{(2, 3), (0, 3), (0, 4)}</code></p> <p>Resolving the error</p> <p>The circuit can be redefined to only contain interactions between connected qubits or a routing pass can be used to resolve the error.</p>"},{"location":"compilation-passes/validation/primitive-gate-validator.html","title":"Primitive gate validator","text":"<p>When developing quantum algorithms, their compilation on a specific device depends on whether the hardware supports the operations implemented on the circuit.</p> <p>To this end, the primitive gate validator pass checks whether the quantum gates in the quantum circuit are present in the primitive gate set of the target backend. If this is not the case, the validator will throw a <code>ValueError</code>, specifying which gates in the circuit are not in the provided primitive gate set.</p> <p>Below are some examples of using the primitive gate validator (<code>PrimitiveGateValidator</code>).</p> <p>Check the circuit builder on how to generate a circuit.</p> <pre><code>from opensquirrel import CircuitBuilder\nfrom opensquirrel.passes.validator import PrimitiveGateValidator\n</code></pre> <pre><code>from math import pi\npgs = [\"I\", \"Rx\", \"Ry\", \"Rz\", \"CZ\"]\n\nbuilder = CircuitBuilder(5)\nbuilder.Rx(pi / 2)\nbuilder.Ry(1, -pi / 2)\nbuilder.CZ(0, 1)\nbuilder.Ry(1, pi / 2)\ncircuit = builder.to_circuit()\n\ncircuit.validate(validator=PrimitiveGateValidator(primitive_gate_set=pgs))\n</code></pre> <p>In the scenario above, there will be no output, as all gates in the circuit are in the primitive gate set. On the other hand, the circuit below will raise an error (<code>ValueError</code>) as certain gates are not supported, given the backend primitive gate set (<code>pgs</code>).</p> <pre><code>pgs = [\"I\", \"X90\", \"mX90\", \"Y90\", \"mY90\", \"Rz\", \"CZ\"]\n\nbuilder = CircuitBuilder(5)\nbuilder.I(0)\nbuilder.X90(1)\nbuilder.mX90(2)\nbuilder.Y90(3)\nbuilder.mY90(4)\nbuilder.Rz(0, 2)\nbuilder.CZ(1, 2)\nbuilder.H(0)\nbuilder.CNOT(1, 2)\ncircuit = builder.to_circuit()\n\ncircuit.validate(validator=PrimitiveGateValidator(primitive_gate_set=pgs))\n</code></pre> <p><code>ValueError: the following gates are not in the primitive gate set: ['H', 'CNOT']</code></p> <p>Resolving the error</p> <p>The upsupported gates can be replaced manually, or a decomposition pass can be used to resolve the error.</p>"},{"location":"reference/circuit.html","title":"circuit","text":""},{"location":"reference/circuit.html#opensquirrel.circuit.Circuit","title":"<code>Circuit</code>","text":"<p>The Circuit class is the only interface to access OpenSquirrel's features.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; c = Circuit.from_string(\"version 3.0; qubit[3] q; h q[0]\")\n&gt;&gt;&gt; c\nversion 3.0\n\nqubit[3] q\n\nh q[0]\n\n&gt;&gt;&gt; c.decomposer(decomposer=mckay_decomposer.McKayDecomposer)\n&gt;&gt;&gt; c\nversion 3.0\n\nqubit[3] q\n\nx90 q[0]\nrz q[0], 1.5707963\nx90 q[0]\n</code></pre> Source code in <code>opensquirrel/circuit.py</code> <pre><code>class Circuit:\n    \"\"\"The Circuit class is the only interface to access OpenSquirrel's features.\n\n    Examples:\n        &gt;&gt;&gt; c = Circuit.from_string(\"version 3.0; qubit[3] q; h q[0]\")\n        &gt;&gt;&gt; c\n        version 3.0\n        &lt;BLANKLINE&gt;\n        qubit[3] q\n        &lt;BLANKLINE&gt;\n        h q[0]\n        &lt;BLANKLINE&gt;\n        &gt;&gt;&gt; c.decomposer(decomposer=mckay_decomposer.McKayDecomposer)\n        &gt;&gt;&gt; c\n        version 3.0\n        &lt;BLANKLINE&gt;\n        qubit[3] q\n        &lt;BLANKLINE&gt;\n        x90 q[0]\n        rz q[0], 1.5707963\n        x90 q[0]\n        &lt;BLANKLINE&gt;\n    \"\"\"\n\n    def __init__(self, register_manager: RegisterManager, ir: IR) -&gt; None:\n        \"\"\"Create a circuit object from a register manager and an IR.\"\"\"\n        self.register_manager = register_manager\n        self.ir = ir\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Write the circuit to a cQASM 3 string.\"\"\"\n        from opensquirrel.writer import writer\n\n        return writer.circuit_to_string(self)\n\n    def __eq__(self, other: Any) -&gt; bool:\n        if not isinstance(other, Circuit):\n            return False\n        return self.register_manager == other.register_manager and self.ir == other.ir\n\n    @classmethod\n    def from_string(cls, cqasm3_string: str) -&gt; Circuit:\n        \"\"\"Create a circuit object from a cQasm3 string. All the gates in the circuit need to be defined in\n        the `gates` argument.\n\n        * type-checking is performed, eliminating qubit indices errors and incoherences\n        * checks that used gates are supported and mentioned in `gates` with appropriate signatures\n        * does not support map or variables, and other things...\n        * for example of `gates` dictionary, please look at TestGates.py\n\n        Args:\n            cqasm3_string: a cQASM 3 string\n        \"\"\"\n        from opensquirrel.reader import LibQasmParser\n\n        return LibQasmParser().circuit_from_string(cqasm3_string)\n\n    @property\n    def qubit_register_size(self) -&gt; int:\n        return self.register_manager.qubit_register_size\n\n    @property\n    def bit_register_size(self) -&gt; int:\n        return self.register_manager.bit_register_size\n\n    @property\n    def qubit_register_name(self) -&gt; str:\n        return self.register_manager.qubit_register_name\n\n    @property\n    def bit_register_name(self) -&gt; str:\n        return self.register_manager.bit_register_name\n\n    @property\n    def instruction_count(self) -&gt; InstructionCount:\n        \"\"\"Count the instructions in the circuit by name.\"\"\"\n        counter: Counter[str] = Counter()\n        counter.update(\n            getattr(statement, \"name\", \"unknown\")\n            for statement in self.ir.statements\n            if not isinstance(statement, AsmDeclaration)\n        )\n        return dict(counter)\n\n    @property\n    def measurement_to_bit_map(self) -&gt; MeasurementToBitMap:\n        \"\"\"Determines and returns the measurement to bit register index mapping.\"\"\"\n        m2b_map: MeasurementToBitMap = defaultdict(list[int])\n        for statement in self.ir.statements:\n            if isinstance(statement, Measure):\n                qubit_index, bit_index = statement.qubit.index, statement.bit.index\n                m2b_map[str(qubit_index)].append(bit_index)\n        return m2b_map\n\n    def asm_filter(self, backend_name: str) -&gt; None:\n        self.ir.statements = [\n            statement\n            for statement in self.ir.statements\n            if not isinstance(statement, AsmDeclaration)\n            or (isinstance(statement, AsmDeclaration) and backend_name in str(statement.backend_name))\n        ]\n\n    def decompose(self, decomposer: Decomposer) -&gt; None:\n        \"\"\"Generic decomposition pass.\n        It applies the given decomposer function to every gate in the circuit.\n        \"\"\"\n        from opensquirrel.passes.decomposer import general_decomposer\n\n        general_decomposer.decompose(self.ir, decomposer)\n\n    def export(self, exporter: Exporter) -&gt; Any:\n        \"\"\"Generic export pass.\n        Exports the circuit using the specified exporter.\n\n        \"\"\"\n        return exporter.export(self)\n\n    def map(self, mapper: Mapper) -&gt; None:\n        \"\"\"Generic qubit mapper pass.\n        Map the (virtual) qubits of the circuit to the physical qubits of the target hardware.\n        \"\"\"\n        from opensquirrel.passes.mapper.qubit_remapper import remap_ir\n\n        mapping = mapper.map(self.ir, self.qubit_register_size)\n        remap_ir(self, mapping)\n\n    def merge(self, merger: Merger) -&gt; None:\n        \"\"\"Generic merge pass. It applies the given merger to the circuit.\"\"\"\n        merger.merge(self.ir, self.qubit_register_size)\n\n    def route(self, router: Router) -&gt; None:\n        \"\"\"Generic router pass. It applies the given router to the circuit.\"\"\"\n        router.route(self.ir, self.qubit_register_size)\n\n    def replace(self, gate: type[Gate], replacement_gates_function: Callable[..., list[Gate]]) -&gt; None:\n        \"\"\"Manually replace occurrences of a given gate with a list of gates.\n        `replacement_gates_function` is a callable that takes the arguments of the gate that is to be replaced and\n        returns the decomposition as a list of gates.\n        \"\"\"\n        from opensquirrel.passes.decomposer import general_decomposer\n\n        general_decomposer.replace(self.ir, gate, replacement_gates_function)\n\n    def validate(self, validator: Validator) -&gt; None:\n        \"\"\"Generic validator pass. It applies the given validator to the circuit.\"\"\"\n        validator.validate(self.ir)\n</code></pre>"},{"location":"reference/circuit.html#opensquirrel.circuit.Circuit.instruction_count","title":"<code>instruction_count</code>  <code>property</code>","text":"<p>Count the instructions in the circuit by name.</p>"},{"location":"reference/circuit.html#opensquirrel.circuit.Circuit.measurement_to_bit_map","title":"<code>measurement_to_bit_map</code>  <code>property</code>","text":"<p>Determines and returns the measurement to bit register index mapping.</p>"},{"location":"reference/circuit.html#opensquirrel.circuit.Circuit.__init__","title":"<code>__init__(register_manager, ir)</code>","text":"<p>Create a circuit object from a register manager and an IR.</p> Source code in <code>opensquirrel/circuit.py</code> <pre><code>def __init__(self, register_manager: RegisterManager, ir: IR) -&gt; None:\n    \"\"\"Create a circuit object from a register manager and an IR.\"\"\"\n    self.register_manager = register_manager\n    self.ir = ir\n</code></pre>"},{"location":"reference/circuit.html#opensquirrel.circuit.Circuit.__repr__","title":"<code>__repr__()</code>","text":"<p>Write the circuit to a cQASM 3 string.</p> Source code in <code>opensquirrel/circuit.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Write the circuit to a cQASM 3 string.\"\"\"\n    from opensquirrel.writer import writer\n\n    return writer.circuit_to_string(self)\n</code></pre>"},{"location":"reference/circuit.html#opensquirrel.circuit.Circuit.decompose","title":"<code>decompose(decomposer)</code>","text":"<p>Generic decomposition pass. It applies the given decomposer function to every gate in the circuit.</p> Source code in <code>opensquirrel/circuit.py</code> <pre><code>def decompose(self, decomposer: Decomposer) -&gt; None:\n    \"\"\"Generic decomposition pass.\n    It applies the given decomposer function to every gate in the circuit.\n    \"\"\"\n    from opensquirrel.passes.decomposer import general_decomposer\n\n    general_decomposer.decompose(self.ir, decomposer)\n</code></pre>"},{"location":"reference/circuit.html#opensquirrel.circuit.Circuit.export","title":"<code>export(exporter)</code>","text":"<p>Generic export pass. Exports the circuit using the specified exporter.</p> Source code in <code>opensquirrel/circuit.py</code> <pre><code>def export(self, exporter: Exporter) -&gt; Any:\n    \"\"\"Generic export pass.\n    Exports the circuit using the specified exporter.\n\n    \"\"\"\n    return exporter.export(self)\n</code></pre>"},{"location":"reference/circuit.html#opensquirrel.circuit.Circuit.from_string","title":"<code>from_string(cqasm3_string)</code>  <code>classmethod</code>","text":"<p>Create a circuit object from a cQasm3 string. All the gates in the circuit need to be defined in the <code>gates</code> argument.</p> <ul> <li>type-checking is performed, eliminating qubit indices errors and incoherences</li> <li>checks that used gates are supported and mentioned in <code>gates</code> with appropriate signatures</li> <li>does not support map or variables, and other things...</li> <li>for example of <code>gates</code> dictionary, please look at TestGates.py</li> </ul> <p>Parameters:</p> Name Type Description Default <code>cqasm3_string</code> <code>str</code> <p>a cQASM 3 string</p> required Source code in <code>opensquirrel/circuit.py</code> <pre><code>@classmethod\ndef from_string(cls, cqasm3_string: str) -&gt; Circuit:\n    \"\"\"Create a circuit object from a cQasm3 string. All the gates in the circuit need to be defined in\n    the `gates` argument.\n\n    * type-checking is performed, eliminating qubit indices errors and incoherences\n    * checks that used gates are supported and mentioned in `gates` with appropriate signatures\n    * does not support map or variables, and other things...\n    * for example of `gates` dictionary, please look at TestGates.py\n\n    Args:\n        cqasm3_string: a cQASM 3 string\n    \"\"\"\n    from opensquirrel.reader import LibQasmParser\n\n    return LibQasmParser().circuit_from_string(cqasm3_string)\n</code></pre>"},{"location":"reference/circuit.html#opensquirrel.circuit.Circuit.map","title":"<code>map(mapper)</code>","text":"<p>Generic qubit mapper pass. Map the (virtual) qubits of the circuit to the physical qubits of the target hardware.</p> Source code in <code>opensquirrel/circuit.py</code> <pre><code>def map(self, mapper: Mapper) -&gt; None:\n    \"\"\"Generic qubit mapper pass.\n    Map the (virtual) qubits of the circuit to the physical qubits of the target hardware.\n    \"\"\"\n    from opensquirrel.passes.mapper.qubit_remapper import remap_ir\n\n    mapping = mapper.map(self.ir, self.qubit_register_size)\n    remap_ir(self, mapping)\n</code></pre>"},{"location":"reference/circuit.html#opensquirrel.circuit.Circuit.merge","title":"<code>merge(merger)</code>","text":"<p>Generic merge pass. It applies the given merger to the circuit.</p> Source code in <code>opensquirrel/circuit.py</code> <pre><code>def merge(self, merger: Merger) -&gt; None:\n    \"\"\"Generic merge pass. It applies the given merger to the circuit.\"\"\"\n    merger.merge(self.ir, self.qubit_register_size)\n</code></pre>"},{"location":"reference/circuit.html#opensquirrel.circuit.Circuit.replace","title":"<code>replace(gate, replacement_gates_function)</code>","text":"<p>Manually replace occurrences of a given gate with a list of gates. <code>replacement_gates_function</code> is a callable that takes the arguments of the gate that is to be replaced and returns the decomposition as a list of gates.</p> Source code in <code>opensquirrel/circuit.py</code> <pre><code>def replace(self, gate: type[Gate], replacement_gates_function: Callable[..., list[Gate]]) -&gt; None:\n    \"\"\"Manually replace occurrences of a given gate with a list of gates.\n    `replacement_gates_function` is a callable that takes the arguments of the gate that is to be replaced and\n    returns the decomposition as a list of gates.\n    \"\"\"\n    from opensquirrel.passes.decomposer import general_decomposer\n\n    general_decomposer.replace(self.ir, gate, replacement_gates_function)\n</code></pre>"},{"location":"reference/circuit.html#opensquirrel.circuit.Circuit.route","title":"<code>route(router)</code>","text":"<p>Generic router pass. It applies the given router to the circuit.</p> Source code in <code>opensquirrel/circuit.py</code> <pre><code>def route(self, router: Router) -&gt; None:\n    \"\"\"Generic router pass. It applies the given router to the circuit.\"\"\"\n    router.route(self.ir, self.qubit_register_size)\n</code></pre>"},{"location":"reference/circuit.html#opensquirrel.circuit.Circuit.validate","title":"<code>validate(validator)</code>","text":"<p>Generic validator pass. It applies the given validator to the circuit.</p> Source code in <code>opensquirrel/circuit.py</code> <pre><code>def validate(self, validator: Validator) -&gt; None:\n    \"\"\"Generic validator pass. It applies the given validator to the circuit.\"\"\"\n    validator.validate(self.ir)\n</code></pre>"},{"location":"reference/circuit_builder.html","title":"circuit_builder","text":""},{"location":"reference/circuit_builder.html#opensquirrel.circuit_builder.CircuitBuilder","title":"<code>CircuitBuilder</code>","text":"<p>A class using the builder pattern to make construction of circuits easy from Python. Adds corresponding instruction when a method is called. Checks that instructions are known and called with the right arguments. Mainly here to allow for Qiskit-style circuit construction:</p> <p>Parameters:</p> Name Type Description Default <code>qubit_register_size</code> <code>int</code> <p>Size of the qubit register</p> required <code>bit_register_size</code> <code>int</code> <p>Size of the bit register</p> <code>0</code> Example <p>CircuitBuilder(qubit_register_size=3, bit_register_size=3).        H(0).CNOT(0, 1).CNOT(0, 2).        to_circuit() version 3.0  qubit[3] q  h q[0] cnot q[0], q[1] cnot q[0], q[2] </p> Source code in <code>opensquirrel/circuit_builder.py</code> <pre><code>class CircuitBuilder:\n    \"\"\"\n    A class using the builder pattern to make construction of circuits easy from Python.\n    Adds corresponding instruction when a method is called. Checks that instructions are known and called with the right\n    arguments.\n    Mainly here to allow for Qiskit-style circuit construction:\n\n    Args:\n        qubit_register_size (int): Size of the qubit register\n        bit_register_size (int): Size of the bit register\n\n    Example:\n        &gt;&gt;&gt; CircuitBuilder(qubit_register_size=3, bit_register_size=3).\\\n        H(0).CNOT(0, 1).CNOT(0, 2).\\\n        to_circuit()\n        version 3.0\n        &lt;BLANKLINE&gt;\n        qubit[3] q\n        &lt;BLANKLINE&gt;\n        h q[0]\n        cnot q[0], q[1]\n        cnot q[0], q[2]\n        &lt;BLANKLINE&gt;\n    \"\"\"\n\n    def __init__(self, qubit_register_size: int, bit_register_size: int = 0) -&gt; None:\n        self.register_manager = RegisterManager(\n            OrderedDict({DEFAULT_QUBIT_REGISTER_NAME: QubitRegister(qubit_register_size)}),\n            OrderedDict({DEFAULT_BIT_REGISTER_NAME: BitRegister(bit_register_size)}),\n        )\n        self.ir = IR()\n\n    def __dir__(self) -&gt; list[str]:\n        return super().__dir__() + list(_builder_dynamic_attributes)  # type: ignore\n\n    def __getattr__(self, attr: str) -&gt; Any:\n        if attr in _builder_dynamic_attributes:\n            return partial(self._add_statement, attr)\n        # Default behaviour\n        return self.__getattribute__(attr)\n\n    def _check_qubit_out_of_bounds_access(self, qubit: QubitLike) -&gt; None:\n        \"\"\"Throw error if qubit index is outside the qubit register range.\n\n        Args:\n            qubit: qubit to check.\n        \"\"\"\n        index = Qubit(qubit).index\n        if index &gt;= self.register_manager.qubit_register_size:\n            msg = f\"qubit index {index} is out of bounds\"\n            raise IndexError(msg)\n\n    def _check_bit_out_of_bounds_access(self, bit: BitLike) -&gt; None:\n        \"\"\"Throw error if bit index is outside the bit register range.\n\n        Args:\n            bit: bit to check.\n        \"\"\"\n        index = Bit(bit).index\n        if index &gt;= self.register_manager.bit_register_size:\n            msg = f\"bit index {index} is out of bounds\"\n            raise IndexError(msg)\n\n    def _check_out_of_bounds_access(self, instruction: Instruction) -&gt; None:\n        for qubit in instruction.qubit_operands:\n            self._check_qubit_out_of_bounds_access(qubit)\n\n        for bit in instruction.bit_operands:\n            self._check_bit_out_of_bounds_access(bit)\n\n    def _add_statement(self, attr: str, *args: Any) -&gt; Self:\n        if attr == \"asm\":\n            try:\n                asm_declaration = AsmDeclaration(*args)\n                self.ir.add_asm_declaration(asm_declaration)\n            except TypeError:\n                msg = f\"trying to build '{attr}' with the wrong number or type of arguments: '{args}'\"\n                raise TypeError(msg) from None\n            return self\n\n        if attr not in default_instruction_set:\n            msg = f\"unknown instruction '{attr}'\"\n            raise ValueError(msg)\n        try:\n            instruction = default_instruction_set[attr](*args)\n        except TypeError as e:\n            msg = f\"trying to build {attr!r} with the wrong number or type of arguments: {args!r}: {e}\"\n            raise TypeError(msg) from e\n\n        self._check_out_of_bounds_access(instruction)\n\n        self.ir.add_statement(instruction)\n        return self\n\n    def to_circuit(self) -&gt; Circuit:\n        return Circuit(deepcopy(self.register_manager), deepcopy(self.ir))\n</code></pre>"},{"location":"reference/circuit_matrix_calculator.html","title":"circuit_matrix_calculator","text":""},{"location":"reference/circuit_matrix_calculator.html#opensquirrel.circuit_matrix_calculator.get_circuit_matrix","title":"<code>get_circuit_matrix(circuit)</code>","text":"<p>Compute the (large) unitary matrix corresponding to the circuit.</p> <p>This matrix has 4**n elements, where n is the number of qubits. Result is stored as a numpy array of complex numbers.</p> <p>Returns:</p> Type Description <code>NDArray[complex128]</code> <p>Matrix representation of the circuit.</p> Source code in <code>opensquirrel/circuit_matrix_calculator.py</code> <pre><code>def get_circuit_matrix(circuit: Circuit) -&gt; NDArray[np.complex128]:\n    \"\"\"Compute the (large) unitary matrix corresponding to the circuit.\n\n    This matrix has 4**n elements, where n is the number of qubits. Result is stored as a numpy array of complex\n    numbers.\n\n    Returns:\n        Matrix representation of the circuit.\n    \"\"\"\n    impl = _CircuitMatrixCalculator(circuit.qubit_register_size)\n\n    circuit.ir.accept(impl)\n\n    return impl.matrix\n</code></pre>"},{"location":"reference/common.html","title":"common","text":""},{"location":"reference/common.html#opensquirrel.common.are_matrices_equivalent_up_to_global_phase","title":"<code>are_matrices_equivalent_up_to_global_phase(matrix_a, matrix_b)</code>","text":"<p>Checks whether two matrices are equivalent up to a global phase.</p> <p>Parameters:</p> Name Type Description Default <code>matrix_a</code> <code>NDArray[complex128]</code> <p>first matrix.</p> required <code>matrix_b</code> <code>NDArray[complex128]</code> <p>second matrix.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether two matrices are equivalent up to a global phase.</p> Source code in <code>opensquirrel/common.py</code> <pre><code>def are_matrices_equivalent_up_to_global_phase(\n    matrix_a: NDArray[np.complex128], matrix_b: NDArray[np.complex128]\n) -&gt; bool:\n    \"\"\"Checks whether two matrices are equivalent up to a global phase.\n\n    Args:\n        matrix_a: first matrix.\n        matrix_b: second matrix.\n\n    Returns:\n        Whether two matrices are equivalent up to a global phase.\n    \"\"\"\n    first_non_zero = next(\n        (i, j) for i in range(matrix_a.shape[0]) for j in range(matrix_a.shape[1]) if abs(matrix_a[i, j]) &gt; ATOL\n    )\n\n    if abs(matrix_b[first_non_zero]) &lt; ATOL:\n        return False\n\n    phase_difference = matrix_a[first_non_zero] / matrix_b[first_non_zero]\n\n    return np.allclose(matrix_a, phase_difference * matrix_b, atol=ATOL)\n</code></pre>"},{"location":"reference/common.html#opensquirrel.common.is_identity_matrix_up_to_a_global_phase","title":"<code>is_identity_matrix_up_to_a_global_phase(matrix)</code>","text":"<p>Checks whether matrix is an identity matrix up to a global phase.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>NDArray[complex128]</code> <p>matrix to check.</p> required <p>Returns:     Whether matrix is an identity matrix up to a global phase.</p> Source code in <code>opensquirrel/common.py</code> <pre><code>def is_identity_matrix_up_to_a_global_phase(matrix: NDArray[np.complex128]) -&gt; bool:\n    \"\"\"Checks whether matrix is an identity matrix up to a global phase.\n\n    Args:\n        matrix: matrix to check.\n    Returns:\n        Whether matrix is an identity matrix up to a global phase.\n    \"\"\"\n    return are_matrices_equivalent_up_to_global_phase(matrix, np.eye(matrix.shape[0], dtype=np.complex128))\n</code></pre>"},{"location":"reference/common.html#opensquirrel.common.normalize_angle","title":"<code>normalize_angle(x)</code>","text":"<p>Normalize the angle to be in between the range of \\((-\\pi, \\pi]\\).</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>SupportsFloat</code> <p>value to normalize.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The normalized angle.</p> Source code in <code>opensquirrel/common.py</code> <pre><code>def normalize_angle(x: SupportsFloat) -&gt; float:\n    r\"\"\"Normalize the angle to be in between the range of $(-\\pi, \\pi]$.\n\n    Args:\n        x: value to normalize.\n\n    Returns:\n        The normalized angle.\n    \"\"\"\n    x = float(x)\n    t = x - tau * (x // tau + 1)\n    if t &lt; -tau / 2 + ATOL:\n        t += tau\n    elif t &gt; tau / 2:\n        t -= tau\n    return t\n</code></pre>"},{"location":"reference/common.html#opensquirrel.common.repr_round","title":"<code>repr_round(value, decimals=REPR_DECIMALS)</code>","text":"<p>Given a numerical value (of type <code>float</code>, <code>Axis</code>, or <code>NDArray[np.complex128]</code>): - rounds it to <code>REPR_DECIMALS</code>, - converts it to string, and - removes the newlines.</p> <p>Returns:</p> Type Description <code>str</code> <p>A single-line string representation of a numerical value.</p> Source code in <code>opensquirrel/common.py</code> <pre><code>def repr_round(value: float | BaseAxis | NDArray[np.complex128], decimals: int = REPR_DECIMALS) -&gt; str:\n    \"\"\"\n    Given a numerical value (of type `float`, `Axis`, or `NDArray[np.complex128]`):\n    - rounds it to `REPR_DECIMALS`,\n    - converts it to string, and\n    - removes the newlines.\n\n    Returns:\n        A single-line string representation of a numerical value.\n    \"\"\"\n    return f\"{np.round(value, decimals)}\".replace(\"\\n\", \"\")\n</code></pre>"},{"location":"reference/default_gate_modifiers.html","title":"default_gate_modifiers","text":""},{"location":"reference/default_instructions.html","title":"default_instructions","text":""},{"location":"reference/exceptions.html","title":"exceptions","text":"<p>This module contains all custom exception used by <code>OpenSquirrel</code>.</p>"},{"location":"reference/exceptions.html#opensquirrel.exceptions.ExporterError","title":"<code>ExporterError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Should be raised when a circuit cannot be exported to the desired output format.</p> Source code in <code>opensquirrel/exceptions.py</code> <pre><code>class ExporterError(Exception):\n    \"\"\"Should be raised when a circuit cannot be exported to the desired output format.\"\"\"\n</code></pre>"},{"location":"reference/exceptions.html#opensquirrel.exceptions.NoRoutingPathError","title":"<code>NoRoutingPathError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Should be raised when no routing path is available between qubits.</p> Source code in <code>opensquirrel/exceptions.py</code> <pre><code>class NoRoutingPathError(Exception):\n    \"\"\"Should be raised when no routing path is available between qubits.\"\"\"\n\n    def __init__(self, message: str, *args: Any) -&gt; None:\n        \"\"\"Init of the ``NoRoutingPathError``.\n\n        Args:\n            message: Error message.\n        \"\"\"\n        super().__init__(message, *args)\n</code></pre>"},{"location":"reference/exceptions.html#opensquirrel.exceptions.NoRoutingPathError.__init__","title":"<code>__init__(message, *args)</code>","text":"<p>Init of the <code>NoRoutingPathError</code>.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Error message.</p> required Source code in <code>opensquirrel/exceptions.py</code> <pre><code>def __init__(self, message: str, *args: Any) -&gt; None:\n    \"\"\"Init of the ``NoRoutingPathError``.\n\n    Args:\n        message: Error message.\n    \"\"\"\n    super().__init__(message, *args)\n</code></pre>"},{"location":"reference/exceptions.html#opensquirrel.exceptions.UnsupportedGateError","title":"<code>UnsupportedGateError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Should be raised when a gate is not supported.</p> Source code in <code>opensquirrel/exceptions.py</code> <pre><code>class UnsupportedGateError(Exception):\n    \"\"\"Should be raised when a gate is not supported.\"\"\"\n\n    def __init__(self, gate: Any, *args: Any) -&gt; None:\n        \"\"\"Init of the ``UnsupportedGateError``.\n\n        Args:\n            gate: Gate that is not supported.\n        \"\"\"\n        super().__init__(f\"{gate} is not supported\", *args)\n</code></pre>"},{"location":"reference/exceptions.html#opensquirrel.exceptions.UnsupportedGateError.__init__","title":"<code>__init__(gate, *args)</code>","text":"<p>Init of the <code>UnsupportedGateError</code>.</p> <p>Parameters:</p> Name Type Description Default <code>gate</code> <code>Any</code> <p>Gate that is not supported.</p> required Source code in <code>opensquirrel/exceptions.py</code> <pre><code>def __init__(self, gate: Any, *args: Any) -&gt; None:\n    \"\"\"Init of the ``UnsupportedGateError``.\n\n    Args:\n        gate: Gate that is not supported.\n    \"\"\"\n    super().__init__(f\"{gate} is not supported\", *args)\n</code></pre>"},{"location":"reference/reference.html","title":"Reference","text":"<ul> <li>opensquirrel<ul> <li>circuit</li> <li>circuit_builder</li> <li>circuit_matrix_calculator</li> <li>common</li> <li>default_gate_modifiers</li> <li>default_instructions</li> <li>exceptions</li> <li>ir<ul> <li>control_instruction</li> <li>default_gates<ul> <li>single_qubit_gates</li> <li>two_qubit_gates</li> </ul> </li> <li>expression</li> <li>ir</li> <li>non_unitary</li> <li>semantics<ul> <li>bsr</li> <li>canonical_gate</li> <li>controlled_gate</li> <li>gate_semantic</li> <li>matrix_gate</li> </ul> </li> <li>single_qubit_gate</li> <li>statement</li> <li>two_qubit_gate</li> <li>unitary</li> </ul> </li> <li>passes<ul> <li>decomposer<ul> <li>aba_decomposer</li> <li>cnot2cz_decomposer</li> <li>cnot_decomposer</li> <li>cz_decomposer</li> <li>general_decomposer</li> <li>mckay_decomposer</li> <li>swap2cnot_decomposer</li> <li>swap2cz_decomposer</li> </ul> </li> <li>exporter<ul> <li>cqasmv1_exporter</li> <li>general_exporter</li> <li>quantify_scheduler_exporter</li> </ul> </li> <li>mapper<ul> <li>check_mapper</li> <li>general_mapper</li> <li>mapping</li> <li>mip_mapper</li> <li>qgym_mapper</li> <li>qubit_remapper</li> <li>simple_mappers</li> <li>utils</li> </ul> </li> <li>merger<ul> <li>general_merger</li> <li>single_qubit_gates_merger</li> </ul> </li> <li>router<ul> <li>astar_router</li> <li>common</li> <li>general_router</li> <li>heuristics</li> <li>shortest_path_router</li> </ul> </li> <li>validator<ul> <li>general_validator</li> <li>interaction_validator</li> <li>primitive_gate_validator</li> </ul> </li> </ul> </li> <li>reader<ul> <li>libqasm_parser</li> </ul> </li> <li>register_manager</li> <li>reindexer<ul> <li>qubit_reindexer</li> </ul> </li> <li>utils<ul> <li>context</li> <li>general_math</li> <li>identity_filter</li> <li>list</li> <li>matrix_expander</li> </ul> </li> <li>writer<ul> <li>writer</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/register_manager.html","title":"register_manager","text":""},{"location":"reference/register_manager.html#opensquirrel.register_manager.BitRegister","title":"<code>BitRegister</code>","text":"<p>               Bases: <code>Register</code></p> <p>BitRegister manages a (virtual) bit register.</p> Source code in <code>opensquirrel/register_manager.py</code> <pre><code>class BitRegister(Register):\n    \"\"\"BitRegister manages a (virtual) bit register.\"\"\"\n\n    _default_name: str = DEFAULT_BIT_REGISTER_NAME\n\n    def __init__(self, size: int, name: str = _default_name) -&gt; None:\n        super().__init__(size, name=name)\n</code></pre>"},{"location":"reference/register_manager.html#opensquirrel.register_manager.QubitRegister","title":"<code>QubitRegister</code>","text":"<p>               Bases: <code>Register</code></p> <p>QubitRegister manages a (virtual) qubit register.</p> Source code in <code>opensquirrel/register_manager.py</code> <pre><code>class QubitRegister(Register):\n    \"\"\"QubitRegister manages a (virtual) qubit register.\"\"\"\n\n    _default_name: str = DEFAULT_QUBIT_REGISTER_NAME\n\n    def __init__(self, size: int, name: str = _default_name) -&gt; None:\n        super().__init__(size, name=name)\n</code></pre>"},{"location":"reference/register_manager.html#opensquirrel.register_manager.Register","title":"<code>Register</code>","text":"<p>Register manages a (virtual) register.</p> Source code in <code>opensquirrel/register_manager.py</code> <pre><code>class Register:\n    \"\"\"Register manages a (virtual) register.\"\"\"\n\n    def __init__(\n        self,\n        size: int,\n        name: str,\n        virtual_zero_index: int = 0,\n    ) -&gt; None:\n        self._size = size\n        self._name = name\n        self._virtual_zero_index = virtual_zero_index\n\n    @property\n    def name(self) -&gt; str:\n        return self._name\n\n    @property\n    def size(self) -&gt; int:\n        return self._size\n\n    @property\n    def virtual_zero_index(self) -&gt; int:\n        return self._virtual_zero_index\n\n    @virtual_zero_index.setter\n    def virtual_zero_index(self, value: int) -&gt; None:\n        self._virtual_zero_index = value\n\n    def __getitem__(self, index: int) -&gt; Any:\n        if abs(index) &gt; self._size:\n            msg = f\"Index {index} is out of range\"\n            raise IndexError(msg)\n        size = self._size if index &lt; 0 else 0\n        return self._virtual_zero_index + index + size\n\n    def __eq__(self, other: Any) -&gt; bool:\n        if not isinstance(other, Register):\n            return False\n        return (\n            self.size == other.size and self.name == other.name and self.virtual_zero_index == other.virtual_zero_index\n        )\n\n    def __repr__(self) -&gt; str:\n        return f\"{type(self)}: {self.name}, {self.size}\"\n</code></pre>"},{"location":"reference/ir/control_instruction.html","title":"control_instruction","text":""},{"location":"reference/ir/expression.html","title":"expression","text":""},{"location":"reference/ir/expression.html#opensquirrel.ir.expression.Axis","title":"<code>Axis</code>","text":"<p>               Bases: <code>BaseAxis</code></p> <p>The <code>Axis</code> object parses and stores a vector containing 3 elements.</p> <p>The input vector is always normalized before it is stored.</p> Source code in <code>opensquirrel/ir/expression.py</code> <pre><code>class Axis(BaseAxis):\n    \"\"\"The ``Axis`` object parses and stores a vector containing 3 elements.\n\n    The input vector is always normalized before it is stored.\n    \"\"\"\n\n    @staticmethod\n    def parse(axis: AxisLike) -&gt; NDArray[np.float64]:\n        \"\"\"Parse and validate an ``AxisLike``.\n\n        Check if the `axis` can be cast to a 1DArray of length 3, raise an error otherwise.\n        After casting to an array, the axis is normalized.\n\n        Args:\n            axis: ``AxisLike`` to validate and parse.\n\n        Returns:\n            Parsed axis represented as a 1DArray of length 3.\n        \"\"\"\n        if isinstance(axis, Axis):\n            return axis.value\n\n        try:\n            axis = np.asarray(axis, dtype=np.float64)\n        except (ValueError, TypeError) as e:\n            msg = \"axis requires an ArrayLike\"\n            raise TypeError(msg) from e\n        axis = axis.flatten()\n        if len(axis) != 3:\n            msg = f\"axis requires an ArrayLike of length 3, but received an ArrayLike of length {len(axis)}\"\n            raise ValueError(msg)\n        if np.all(axis == 0):\n            msg = \"axis requires at least one element to be non-zero\"\n            raise ValueError(msg)\n        axis = cast(\"NDArray[np.float64]\", axis)\n        return axis / np.linalg.norm(axis)\n\n    def accept(self, visitor: IRVisitor) -&gt; Any:\n        \"\"\"Accept the ``Axis``.\"\"\"\n        return visitor.visit_axis(self)\n</code></pre>"},{"location":"reference/ir/expression.html#opensquirrel.ir.expression.Axis.accept","title":"<code>accept(visitor)</code>","text":"<p>Accept the <code>Axis</code>.</p> Source code in <code>opensquirrel/ir/expression.py</code> <pre><code>def accept(self, visitor: IRVisitor) -&gt; Any:\n    \"\"\"Accept the ``Axis``.\"\"\"\n    return visitor.visit_axis(self)\n</code></pre>"},{"location":"reference/ir/expression.html#opensquirrel.ir.expression.Axis.parse","title":"<code>parse(axis)</code>  <code>staticmethod</code>","text":"<p>Parse and validate an <code>AxisLike</code>.</p> <p>Check if the <code>axis</code> can be cast to a 1DArray of length 3, raise an error otherwise. After casting to an array, the axis is normalized.</p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>AxisLike</code> <p><code>AxisLike</code> to validate and parse.</p> required <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>Parsed axis represented as a 1DArray of length 3.</p> Source code in <code>opensquirrel/ir/expression.py</code> <pre><code>@staticmethod\ndef parse(axis: AxisLike) -&gt; NDArray[np.float64]:\n    \"\"\"Parse and validate an ``AxisLike``.\n\n    Check if the `axis` can be cast to a 1DArray of length 3, raise an error otherwise.\n    After casting to an array, the axis is normalized.\n\n    Args:\n        axis: ``AxisLike`` to validate and parse.\n\n    Returns:\n        Parsed axis represented as a 1DArray of length 3.\n    \"\"\"\n    if isinstance(axis, Axis):\n        return axis.value\n\n    try:\n        axis = np.asarray(axis, dtype=np.float64)\n    except (ValueError, TypeError) as e:\n        msg = \"axis requires an ArrayLike\"\n        raise TypeError(msg) from e\n    axis = axis.flatten()\n    if len(axis) != 3:\n        msg = f\"axis requires an ArrayLike of length 3, but received an ArrayLike of length {len(axis)}\"\n        raise ValueError(msg)\n    if np.all(axis == 0):\n        msg = \"axis requires at least one element to be non-zero\"\n        raise ValueError(msg)\n    axis = cast(\"NDArray[np.float64]\", axis)\n    return axis / np.linalg.norm(axis)\n</code></pre>"},{"location":"reference/ir/expression.html#opensquirrel.ir.expression.BaseAxis","title":"<code>BaseAxis</code>","text":"<p>               Bases: <code>Sequence[float64]</code>, <code>Expression</code>, <code>ABC</code></p> Source code in <code>opensquirrel/ir/expression.py</code> <pre><code>class BaseAxis(Sequence[np.float64], Expression, ABC):\n    _len = 3\n\n    def __init__(self, *axis: AxisLike) -&gt; None:\n        \"\"\"Init of the ``BaseAxis`` object.\n\n        axis: An ``AxisLike`` to create the axis from.\n        \"\"\"\n        self.value = axis[0] if len(axis) == 1 else cast(\"AxisLike\", axis)\n\n    @staticmethod\n    @abstractmethod\n    def parse(axis: AxisLike) -&gt; NDArray[np.float64]: ...\n\n    @property\n    def value(self) -&gt; NDArray[np.float64]:\n        \"\"\"The ``BaseAxis`` data saved as a 1D-Array with 3 elements.\"\"\"\n        return self._value\n\n    @value.setter\n    def value(self, axis: AxisLike) -&gt; None:\n        \"\"\"Parse and set a new axis.\n\n        Args:\n            axis: An ``AxisLike`` to create the axis from.\n        \"\"\"\n        self._value = self.parse(axis)\n\n    @overload\n    def __getitem__(self, i: int, /) -&gt; np.float64: ...\n\n    @overload\n    def __getitem__(self, s: slice, /) -&gt; list[np.float64]: ...\n\n    def __getitem__(self, index: int | slice, /) -&gt; np.float64 | list[np.float64]:\n        \"\"\"Get the item at `index`.\"\"\"\n        return cast(\"np.float64\", self.value[index])\n\n    def __len__(self) -&gt; int:\n        \"\"\"Length of the axis, which is always 3.\"\"\"\n        return self._len\n\n    def __repr__(self) -&gt; str:\n        \"\"\"String representation of the ``BaseAxis``.\"\"\"\n        return f\"{self.__class__.__name__}{self.value}\"\n\n    def __array__(self, dtype: DTypeLike = None, *, copy: bool | None = None) -&gt; NDArray[Any]:\n        \"\"\"Convert the ``BaseAxis`` data to an array.\"\"\"\n        return np.array(self.value, dtype=dtype, copy=copy)\n\n    def __eq__(self, other: Any) -&gt; bool:\n        \"\"\"Check if `self` is equal to `other`.\n\n        Two ``BaseAxis`` objects are considered equal if their axes are equal.\n        \"\"\"\n        if not isinstance(other, self.__class__):\n            return False\n        return np.array_equal(self, other)\n</code></pre>"},{"location":"reference/ir/expression.html#opensquirrel.ir.expression.BaseAxis.value","title":"<code>value</code>  <code>property</code> <code>writable</code>","text":"<p>The <code>BaseAxis</code> data saved as a 1D-Array with 3 elements.</p>"},{"location":"reference/ir/expression.html#opensquirrel.ir.expression.BaseAxis.__array__","title":"<code>__array__(dtype=None, *, copy=None)</code>","text":"<p>Convert the <code>BaseAxis</code> data to an array.</p> Source code in <code>opensquirrel/ir/expression.py</code> <pre><code>def __array__(self, dtype: DTypeLike = None, *, copy: bool | None = None) -&gt; NDArray[Any]:\n    \"\"\"Convert the ``BaseAxis`` data to an array.\"\"\"\n    return np.array(self.value, dtype=dtype, copy=copy)\n</code></pre>"},{"location":"reference/ir/expression.html#opensquirrel.ir.expression.BaseAxis.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Check if <code>self</code> is equal to <code>other</code>.</p> <p>Two <code>BaseAxis</code> objects are considered equal if their axes are equal.</p> Source code in <code>opensquirrel/ir/expression.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n    \"\"\"Check if `self` is equal to `other`.\n\n    Two ``BaseAxis`` objects are considered equal if their axes are equal.\n    \"\"\"\n    if not isinstance(other, self.__class__):\n        return False\n    return np.array_equal(self, other)\n</code></pre>"},{"location":"reference/ir/expression.html#opensquirrel.ir.expression.BaseAxis.__getitem__","title":"<code>__getitem__(index)</code>","text":"<pre><code>__getitem__(i: int) -&gt; np.float64\n</code></pre><pre><code>__getitem__(s: slice) -&gt; list[np.float64]\n</code></pre> <p>Get the item at <code>index</code>.</p> Source code in <code>opensquirrel/ir/expression.py</code> <pre><code>def __getitem__(self, index: int | slice, /) -&gt; np.float64 | list[np.float64]:\n    \"\"\"Get the item at `index`.\"\"\"\n    return cast(\"np.float64\", self.value[index])\n</code></pre>"},{"location":"reference/ir/expression.html#opensquirrel.ir.expression.BaseAxis.__init__","title":"<code>__init__(*axis)</code>","text":"<p>Init of the <code>BaseAxis</code> object.</p> <p>axis: An <code>AxisLike</code> to create the axis from.</p> Source code in <code>opensquirrel/ir/expression.py</code> <pre><code>def __init__(self, *axis: AxisLike) -&gt; None:\n    \"\"\"Init of the ``BaseAxis`` object.\n\n    axis: An ``AxisLike`` to create the axis from.\n    \"\"\"\n    self.value = axis[0] if len(axis) == 1 else cast(\"AxisLike\", axis)\n</code></pre>"},{"location":"reference/ir/expression.html#opensquirrel.ir.expression.BaseAxis.__len__","title":"<code>__len__()</code>","text":"<p>Length of the axis, which is always 3.</p> Source code in <code>opensquirrel/ir/expression.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Length of the axis, which is always 3.\"\"\"\n    return self._len\n</code></pre>"},{"location":"reference/ir/expression.html#opensquirrel.ir.expression.BaseAxis.__repr__","title":"<code>__repr__()</code>","text":"<p>String representation of the <code>BaseAxis</code>.</p> Source code in <code>opensquirrel/ir/expression.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"String representation of the ``BaseAxis``.\"\"\"\n    return f\"{self.__class__.__name__}{self.value}\"\n</code></pre>"},{"location":"reference/ir/expression.html#opensquirrel.ir.expression.Float","title":"<code>Float</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Expression</code></p> <p>Floats used for intermediate representation of <code>Statement</code> arguments.</p> <p>Attributes:</p> Name Type Description <code>value</code> <code>float</code> <p>value of the <code>Float</code> object.</p> Source code in <code>opensquirrel/ir/expression.py</code> <pre><code>@dataclass(init=False)\nclass Float(Expression):\n    \"\"\"Floats used for intermediate representation of ``Statement`` arguments.\n\n    Attributes:\n        value: value of the ``Float`` object.\n    \"\"\"\n\n    value: float\n\n    def __init__(self, value: SupportsFloat) -&gt; None:\n        \"\"\"Init of the ``Float`` object.\n\n        Args:\n            value: value of the ``Float`` object.\n        \"\"\"\n        if isinstance(value, SupportsFloat):\n            self.value = float(value)\n            return\n\n        msg = \"value must be a float\"\n        raise TypeError(msg)\n\n    def __float__(self) -&gt; float:\n        \"\"\"Cast the ``Float`` object to a built-in Python ``float``.\n\n        Returns:\n            Built-in Python ``float`` representation of the ``Float``.\n        \"\"\"\n        return self.value\n\n    def accept(self, visitor: IRVisitor) -&gt; Any:\n        return visitor.visit_float(self)\n</code></pre>"},{"location":"reference/ir/expression.html#opensquirrel.ir.expression.Float.__float__","title":"<code>__float__()</code>","text":"<p>Cast the <code>Float</code> object to a built-in Python <code>float</code>.</p> <p>Returns:</p> Type Description <code>float</code> <p>Built-in Python <code>float</code> representation of the <code>Float</code>.</p> Source code in <code>opensquirrel/ir/expression.py</code> <pre><code>def __float__(self) -&gt; float:\n    \"\"\"Cast the ``Float`` object to a built-in Python ``float``.\n\n    Returns:\n        Built-in Python ``float`` representation of the ``Float``.\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"reference/ir/expression.html#opensquirrel.ir.expression.Float.__init__","title":"<code>__init__(value)</code>","text":"<p>Init of the <code>Float</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>SupportsFloat</code> <p>value of the <code>Float</code> object.</p> required Source code in <code>opensquirrel/ir/expression.py</code> <pre><code>def __init__(self, value: SupportsFloat) -&gt; None:\n    \"\"\"Init of the ``Float`` object.\n\n    Args:\n        value: value of the ``Float`` object.\n    \"\"\"\n    if isinstance(value, SupportsFloat):\n        self.value = float(value)\n        return\n\n    msg = \"value must be a float\"\n    raise TypeError(msg)\n</code></pre>"},{"location":"reference/ir/expression.html#opensquirrel.ir.expression.Int","title":"<code>Int</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Expression</code></p> <p>Integers used for intermediate representation of <code>Statement</code> arguments.</p> <p>Attributes:</p> Name Type Description <code>value</code> <code>int</code> <p>value of the <code>Int</code> object.</p> Source code in <code>opensquirrel/ir/expression.py</code> <pre><code>@dataclass(init=False)\nclass Int(Expression):\n    \"\"\"Integers used for intermediate representation of ``Statement`` arguments.\n\n    Attributes:\n        value: value of the ``Int`` object.\n    \"\"\"\n\n    value: int\n\n    def __init__(self, value: SupportsInt) -&gt; None:\n        \"\"\"Init of the ``Int`` object.\n\n        Args:\n            value: value of the ``Int`` object.\n        \"\"\"\n        if isinstance(value, SupportsInt):\n            self.value = int(value)\n            return\n\n        msg = \"value must be an int\"\n        raise TypeError(msg)\n\n    def __int__(self) -&gt; int:\n        \"\"\"Cast the ``Int`` object to a built-in Python ``int``.\n\n        Returns:\n            Built-in Python ``int`` representation of the ``Int``.\n        \"\"\"\n        return self.value\n\n    def accept(self, visitor: IRVisitor) -&gt; Any:\n        return visitor.visit_int(self)\n</code></pre>"},{"location":"reference/ir/expression.html#opensquirrel.ir.expression.Int.__init__","title":"<code>__init__(value)</code>","text":"<p>Init of the <code>Int</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>SupportsInt</code> <p>value of the <code>Int</code> object.</p> required Source code in <code>opensquirrel/ir/expression.py</code> <pre><code>def __init__(self, value: SupportsInt) -&gt; None:\n    \"\"\"Init of the ``Int`` object.\n\n    Args:\n        value: value of the ``Int`` object.\n    \"\"\"\n    if isinstance(value, SupportsInt):\n        self.value = int(value)\n        return\n\n    msg = \"value must be an int\"\n    raise TypeError(msg)\n</code></pre>"},{"location":"reference/ir/expression.html#opensquirrel.ir.expression.Int.__int__","title":"<code>__int__()</code>","text":"<p>Cast the <code>Int</code> object to a built-in Python <code>int</code>.</p> <p>Returns:</p> Type Description <code>int</code> <p>Built-in Python <code>int</code> representation of the <code>Int</code>.</p> Source code in <code>opensquirrel/ir/expression.py</code> <pre><code>def __int__(self) -&gt; int:\n    \"\"\"Cast the ``Int`` object to a built-in Python ``int``.\n\n    Returns:\n        Built-in Python ``int`` representation of the ``Int``.\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"reference/ir/expression.html#opensquirrel.ir.expression.Qubit","title":"<code>Qubit</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Expression</code></p> <p><code>Qubit</code> is used for intermediate representation of <code>Statement</code> arguments.</p> <p>Attributes:</p> Name Type Description <code>index</code> <code>int</code> <p>index of the <code>Qubit</code> object.</p> Source code in <code>opensquirrel/ir/expression.py</code> <pre><code>@dataclass(init=False)\nclass Qubit(Expression):\n    \"\"\"``Qubit`` is used for intermediate representation of ``Statement`` arguments.\n\n    Attributes:\n        index: index of the ``Qubit`` object.\n    \"\"\"\n\n    index: int\n\n    def __init__(self, index: QubitLike) -&gt; None:\n        if isinstance(index, SupportsInt):\n            self.index = int(index)\n        elif isinstance(index, Qubit):\n            self.index = index.index\n        else:\n            msg = \"index must be a QubitLike\"\n            raise TypeError(msg)\n\n    def __hash__(self) -&gt; int:\n        return hash(str(self.__class__) + str(self.index))\n\n    def __repr__(self) -&gt; str:\n        return f\"Qubit[{self.index}]\"\n\n    def accept(self, visitor: IRVisitor) -&gt; Any:\n        return visitor.visit_qubit(self)\n</code></pre>"},{"location":"reference/ir/expression.html#opensquirrel.ir.expression.String","title":"<code>String</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Expression</code></p> <p>Strings used for intermediate representation of <code>Statement</code> arguments.</p> <p>Attributes:</p> Name Type Description <code>value</code> <code>str</code> <p>value of the <code>String</code> object.</p> Source code in <code>opensquirrel/ir/expression.py</code> <pre><code>@dataclass(init=False)\nclass String(Expression):\n    \"\"\"Strings used for intermediate representation of ``Statement`` arguments.\n\n    Attributes:\n        value: value of the ``String`` object.\n    \"\"\"\n\n    value: str\n\n    def __init__(self, value: SupportsStr) -&gt; None:\n        \"\"\"Init of the ``String`` object.\n\n        Args:\n            value: value of the ``String`` object.\n        \"\"\"\n        if isinstance(value, SupportsStr):\n            self.value = str(value)\n            return\n\n        msg = \"value must be a str\"\n        raise TypeError(msg)\n\n    def __str__(self) -&gt; str:\n        \"\"\"Cast the ``String`` object to a built-in Python ``str``.\n\n        Returns:\n            Built-in Python ``str`` representation of the ``String``.\n        \"\"\"\n        return self.value\n\n    def accept(self, visitor: IRVisitor) -&gt; Any:\n        return visitor.visit_str(self)\n</code></pre>"},{"location":"reference/ir/expression.html#opensquirrel.ir.expression.String.__init__","title":"<code>__init__(value)</code>","text":"<p>Init of the <code>String</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>SupportsStr</code> <p>value of the <code>String</code> object.</p> required Source code in <code>opensquirrel/ir/expression.py</code> <pre><code>def __init__(self, value: SupportsStr) -&gt; None:\n    \"\"\"Init of the ``String`` object.\n\n    Args:\n        value: value of the ``String`` object.\n    \"\"\"\n    if isinstance(value, SupportsStr):\n        self.value = str(value)\n        return\n\n    msg = \"value must be a str\"\n    raise TypeError(msg)\n</code></pre>"},{"location":"reference/ir/expression.html#opensquirrel.ir.expression.String.__str__","title":"<code>__str__()</code>","text":"<p>Cast the <code>String</code> object to a built-in Python <code>str</code>.</p> <p>Returns:</p> Type Description <code>str</code> <p>Built-in Python <code>str</code> representation of the <code>String</code>.</p> Source code in <code>opensquirrel/ir/expression.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Cast the ``String`` object to a built-in Python ``str``.\n\n    Returns:\n        Built-in Python ``str`` representation of the ``String``.\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"reference/ir/ir.html","title":"ir","text":""},{"location":"reference/ir/non_unitary.html","title":"non_unitary","text":""},{"location":"reference/ir/single_qubit_gate.html","title":"single_qubit_gate","text":""},{"location":"reference/ir/single_qubit_gate.html#opensquirrel.ir.single_qubit_gate.try_match_replace_with_default_gate","title":"<code>try_match_replace_with_default_gate(gate)</code>","text":"<p>Try replacing a given SingleQubitGate with a default SingleQubitGate.     It does that by matching the input SingleQubitGate to a default SingleQubitGate.</p> <p>Returns:</p> Type Description <code>SingleQubitGate</code> <p>A default SingleQubitGate if this SingleQubitGate is close to it,</p> <code>SingleQubitGate</code> <p>or the input SingleQubitGate otherwise.</p> Source code in <code>opensquirrel/ir/single_qubit_gate.py</code> <pre><code>def try_match_replace_with_default_gate(gate: SingleQubitGate) -&gt; SingleQubitGate:\n    \"\"\"Try replacing a given SingleQubitGate with a default SingleQubitGate.\n        It does that by matching the input SingleQubitGate to a default SingleQubitGate.\n\n    Returns:\n            A default SingleQubitGate if this SingleQubitGate is close to it,\n            or the input SingleQubitGate otherwise.\n    \"\"\"\n    from opensquirrel.default_instructions import (\n        default_bsr_with_param_set,\n        default_single_qubit_gate_set,\n    )\n    from opensquirrel.ir.default_gates.single_qubit_gates import Rn\n\n    for gate_name in default_single_qubit_gate_set:\n        if gate_name in (\"Rn\", \"U\"):\n            continue\n\n        arguments: tuple[Any, ...] = (gate.qubit,)\n        if gate_name in default_bsr_with_param_set:\n            arguments += (Float(gate.bsr.angle),)\n\n        possible_gate = default_single_qubit_gate_set[gate_name](*arguments)\n        if possible_gate == gate:\n            return possible_gate\n\n    nx, ny, nz = gate.bsr.axis.value\n    return Rn(gate.qubit, nx=nx, ny=ny, nz=nz, theta=gate.bsr.angle, phi=gate.bsr.phase)\n</code></pre>"},{"location":"reference/ir/statement.html","title":"statement","text":""},{"location":"reference/ir/statement.html#opensquirrel.ir.statement.AsmDeclaration","title":"<code>AsmDeclaration</code>","text":"<p>               Bases: <code>Statement</code></p> <p><code>AsmDeclaration</code> is used to define an assembly declaration statement in the IR.</p> <p>Parameters:</p> Name Type Description Default <code>backend_name</code> <code>SupportsStr</code> <p>Name of the backend that is to process the provided backend code.</p> required <code>backend_code</code> <code>SupportsStr</code> <p>(Assembly) code to be processed by the specified backend.</p> required Source code in <code>opensquirrel/ir/statement.py</code> <pre><code>class AsmDeclaration(Statement):\n    \"\"\"``AsmDeclaration`` is used to define an assembly declaration statement in the IR.\n\n    Args:\n        backend_name: Name of the backend that is to process the provided backend code.\n        backend_code: (Assembly) code to be processed by the specified backend.\n    \"\"\"\n\n    def __init__(\n        self,\n        backend_name: SupportsStr,\n        backend_code: SupportsStr,\n    ) -&gt; None:\n        self.backend_name = String(backend_name)\n        self.backend_code = String(backend_code)\n        Statement.__init__(self)\n\n    def accept(self, visitor: IRVisitor) -&gt; Any:\n        visitor.visit_statement(self)\n        return visitor.visit_asm_declaration(self)\n</code></pre>"},{"location":"reference/ir/two_qubit_gate.html","title":"two_qubit_gate","text":""},{"location":"reference/ir/unitary.html","title":"unitary","text":""},{"location":"reference/ir/default_gates/single_qubit_gates.html","title":"single_qubit_gates","text":""},{"location":"reference/ir/default_gates/two_qubit_gates.html","title":"two_qubit_gates","text":""},{"location":"reference/ir/semantics/bsr.html","title":"bsr","text":""},{"location":"reference/ir/semantics/bsr.html#opensquirrel.ir.semantics.bsr.BlochSphereRotation","title":"<code>BlochSphereRotation</code>","text":"<p>               Bases: <code>GateSemantic</code>, <code>IRNode</code></p> Source code in <code>opensquirrel/ir/semantics/bsr.py</code> <pre><code>class BlochSphereRotation(GateSemantic, IRNode):\n    normalize_angle_params: bool = True\n\n    def __init__(\n        self,\n        axis: AxisLike,\n        angle: SupportsFloat,\n        phase: SupportsFloat,\n    ) -&gt; None:\n        self.axis = Axis(axis)\n        self.angle = normalize_angle(angle) if self.normalize_angle_params else float(angle)\n        self.phase = normalize_angle(phase) if self.normalize_angle_params else float(phase)\n\n    def accept(self, visitor: IRVisitor) -&gt; Any:\n        return visitor.visit_bloch_sphere_rotation(self)\n\n    def is_identity(self) -&gt; bool:\n        # Angle and phase are already normalized.\n        return abs(self.angle) &lt; ATOL and abs(self.phase) &lt; ATOL\n\n    def __repr__(self) -&gt; str:\n        return (\n            f\"BlochSphereRotation(axis={repr_round(self.axis)}, angle={repr_round(self.angle)}, \"\n            f\"phase={repr_round(self.phase)})\"\n        )\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, BlochSphereRotation):\n            return False\n\n        if np.allclose(self.axis.value, other.axis.value, atol=ATOL):\n            return abs(self.angle - other.angle) &lt; ATOL and abs(self.phase - other.phase) &lt; ATOL\n\n        if np.allclose(self.axis.value, -other.axis.value, atol=ATOL):\n            return abs(self.angle + other.angle) &lt; ATOL and abs(self.phase + other.phase) &lt; ATOL\n\n        return False\n\n    def __mul__(self, other: BlochSphereRotation) -&gt; BlochSphereRotation:\n        \"\"\"Computes the single qubit gate resulting from the composition of two single\n        qubit gates, by composing the Bloch sphere rotations of the two gates.\n        The first rotation (A) is applied and then the second (B):\n\n        As separate gates:\n            A q\n            B q\n\n        As linear operations:\n            (B * A) q\n\n        If the final single qubit gate is anonymous, we try to match it to a default gate.\n\n        Uses Rodrigues' rotation formula (see https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula).\n        \"\"\"\n        acos_argument = cos(self.angle / 2) * cos(other.angle / 2) - sin(self.angle / 2) * sin(\n            other.angle / 2\n        ) * np.dot(self.axis, other.axis)\n        combined_angle = 2 * acos(acos_argument)\n\n        if abs(sin(combined_angle / 2)) &lt; ATOL:\n            return bsr_from_matrix([[1, 0], [0, 1]])\n\n        order_of_magnitude = abs(floor(log10(ATOL)))\n        combined_axis = np.round(\n            (\n                1\n                / sin(combined_angle / 2)\n                * (\n                    sin(self.angle / 2) * cos(other.angle / 2) * self.axis.value\n                    + cos(self.angle / 2) * sin(other.angle / 2) * other.axis.value\n                    + sin(self.angle / 2) * sin(other.angle / 2) * np.cross(other.axis, self.axis)\n                )\n            ),\n            order_of_magnitude,\n        )\n\n        combined_phase = np.round(self.phase + other.phase, order_of_magnitude)\n        return BlochSphereRotation(\n            axis=combined_axis,\n            angle=combined_angle,\n            phase=combined_phase,\n        )\n</code></pre>"},{"location":"reference/ir/semantics/bsr.html#opensquirrel.ir.semantics.bsr.BlochSphereRotation.__mul__","title":"<code>__mul__(other)</code>","text":"<p>Computes the single qubit gate resulting from the composition of two single qubit gates, by composing the Bloch sphere rotations of the two gates. The first rotation (A) is applied and then the second (B):</p> As separate gates <p>A q B q</p> As linear operations <p>(B * A) q</p> <p>If the final single qubit gate is anonymous, we try to match it to a default gate.</p> <p>Uses Rodrigues' rotation formula (see https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula).</p> Source code in <code>opensquirrel/ir/semantics/bsr.py</code> <pre><code>def __mul__(self, other: BlochSphereRotation) -&gt; BlochSphereRotation:\n    \"\"\"Computes the single qubit gate resulting from the composition of two single\n    qubit gates, by composing the Bloch sphere rotations of the two gates.\n    The first rotation (A) is applied and then the second (B):\n\n    As separate gates:\n        A q\n        B q\n\n    As linear operations:\n        (B * A) q\n\n    If the final single qubit gate is anonymous, we try to match it to a default gate.\n\n    Uses Rodrigues' rotation formula (see https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula).\n    \"\"\"\n    acos_argument = cos(self.angle / 2) * cos(other.angle / 2) - sin(self.angle / 2) * sin(\n        other.angle / 2\n    ) * np.dot(self.axis, other.axis)\n    combined_angle = 2 * acos(acos_argument)\n\n    if abs(sin(combined_angle / 2)) &lt; ATOL:\n        return bsr_from_matrix([[1, 0], [0, 1]])\n\n    order_of_magnitude = abs(floor(log10(ATOL)))\n    combined_axis = np.round(\n        (\n            1\n            / sin(combined_angle / 2)\n            * (\n                sin(self.angle / 2) * cos(other.angle / 2) * self.axis.value\n                + cos(self.angle / 2) * sin(other.angle / 2) * other.axis.value\n                + sin(self.angle / 2) * sin(other.angle / 2) * np.cross(other.axis, self.axis)\n            )\n        ),\n        order_of_magnitude,\n    )\n\n    combined_phase = np.round(self.phase + other.phase, order_of_magnitude)\n    return BlochSphereRotation(\n        axis=combined_axis,\n        angle=combined_angle,\n        phase=combined_phase,\n    )\n</code></pre>"},{"location":"reference/ir/semantics/canonical_gate.html","title":"canonical_gate","text":""},{"location":"reference/ir/semantics/canonical_gate.html#opensquirrel.ir.semantics.canonical_gate.CanonicalAxis","title":"<code>CanonicalAxis</code>","text":"<p>               Bases: <code>BaseAxis</code></p> Source code in <code>opensquirrel/ir/semantics/canonical_gate.py</code> <pre><code>class CanonicalAxis(BaseAxis):\n    @staticmethod\n    def parse(axis: AxisLike) -&gt; NDArray[np.float64]:\n        \"\"\"Parse and validate an ``AxisLike``.\n\n        Check if the `axis` can be cast to a 1DArray of length 3, raise an error otherwise.\n        After casting to an array, the elements of the canonical axis are restricted to the Weyl chamber.\n\n        Args:\n            axis: ``AxisLike`` to validate and parse.\n\n        Returns:\n            Parsed axis represented as a 1DArray of length 3.\n        \"\"\"\n        if isinstance(axis, CanonicalAxis):\n            return axis.value\n\n        try:\n            axis = np.asarray(axis, dtype=float)\n        except (ValueError, TypeError) as e:\n            msg = \"axis requires an ArrayLike\"\n            raise TypeError(msg) from e\n        axis = axis.flatten()\n        if len(axis) != 3:\n            msg = f\"axis requires an ArrayLike of length 3, but received an ArrayLike of length {len(axis)}\"\n            raise ValueError(msg)\n\n        return CanonicalAxis.restrict_to_weyl_chamber(axis)\n\n    @staticmethod\n    def restrict_to_weyl_chamber(axis: NDArray[np.float64]) -&gt; NDArray[np.float64]:\n        \"\"\"Restrict the given axis to the Weyl chamber. The six rules that are\n        (implicitly) used are:\n            1. The canonical parameters are periodic with a period of 2 (neglecting\n               a global phase).\n            2. Can(tx, ty, tz) ~ Can(tx - 1, ty, tz) (for any parameter)\n            3. Can(tx, ty, tz) ~ Can(tx, -ty, -tz) (for any pair of parameters)\n            4. Can(tx, ty, tz) ~ Can(ty, tx, tz) (for any pair of parameters)\n            5. Can(tx, ty, 0) ~ Can(1 - tx, ty, 0)\n            6. Can(tx, ty, tz) x Can(tx', ty', tz') = Can(tx + tx', ty + ty', tz + tz')\n               (here x represents matrix multiplication)\n\n        Based on the rules described in Chapter 5 of https://threeplusone.com/pubs/on_gates.pdf\n        \"\"\"\n        axis = (axis + 1) % 2 - 1\n\n        while (axis &lt; 0).any():\n            axis = np.where(axis &lt; 0, axis - 1, axis)\n            axis = (axis + 1) % 2 - 1\n\n        axis = np.sort(axis)[::-1]\n        match sum(t &gt; 1 / 2 for t in axis):\n            case 1:\n                axis[0] = 1 - axis[0]\n            case 2:\n                axis[0], axis[2] = axis[2], axis[0]\n                axis[1:] = 1 - axis[1:]\n            case 3:\n                axis = 1 - axis\n\n        return np.sort(axis)[::-1]\n\n    def accept(self, visitor: IRVisitor) -&gt; Any:\n        return visitor.visit_canonical_axis(self)\n</code></pre>"},{"location":"reference/ir/semantics/canonical_gate.html#opensquirrel.ir.semantics.canonical_gate.CanonicalAxis.parse","title":"<code>parse(axis)</code>  <code>staticmethod</code>","text":"<p>Parse and validate an <code>AxisLike</code>.</p> <p>Check if the <code>axis</code> can be cast to a 1DArray of length 3, raise an error otherwise. After casting to an array, the elements of the canonical axis are restricted to the Weyl chamber.</p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>AxisLike</code> <p><code>AxisLike</code> to validate and parse.</p> required <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>Parsed axis represented as a 1DArray of length 3.</p> Source code in <code>opensquirrel/ir/semantics/canonical_gate.py</code> <pre><code>@staticmethod\ndef parse(axis: AxisLike) -&gt; NDArray[np.float64]:\n    \"\"\"Parse and validate an ``AxisLike``.\n\n    Check if the `axis` can be cast to a 1DArray of length 3, raise an error otherwise.\n    After casting to an array, the elements of the canonical axis are restricted to the Weyl chamber.\n\n    Args:\n        axis: ``AxisLike`` to validate and parse.\n\n    Returns:\n        Parsed axis represented as a 1DArray of length 3.\n    \"\"\"\n    if isinstance(axis, CanonicalAxis):\n        return axis.value\n\n    try:\n        axis = np.asarray(axis, dtype=float)\n    except (ValueError, TypeError) as e:\n        msg = \"axis requires an ArrayLike\"\n        raise TypeError(msg) from e\n    axis = axis.flatten()\n    if len(axis) != 3:\n        msg = f\"axis requires an ArrayLike of length 3, but received an ArrayLike of length {len(axis)}\"\n        raise ValueError(msg)\n\n    return CanonicalAxis.restrict_to_weyl_chamber(axis)\n</code></pre>"},{"location":"reference/ir/semantics/canonical_gate.html#opensquirrel.ir.semantics.canonical_gate.CanonicalAxis.restrict_to_weyl_chamber","title":"<code>restrict_to_weyl_chamber(axis)</code>  <code>staticmethod</code>","text":"<p>Restrict the given axis to the Weyl chamber. The six rules that are (implicitly) used are:     1. The canonical parameters are periodic with a period of 2 (neglecting        a global phase).     2. Can(tx, ty, tz) ~ Can(tx - 1, ty, tz) (for any parameter)     3. Can(tx, ty, tz) ~ Can(tx, -ty, -tz) (for any pair of parameters)     4. Can(tx, ty, tz) ~ Can(ty, tx, tz) (for any pair of parameters)     5. Can(tx, ty, 0) ~ Can(1 - tx, ty, 0)     6. Can(tx, ty, tz) x Can(tx', ty', tz') = Can(tx + tx', ty + ty', tz + tz')        (here x represents matrix multiplication)</p> <p>Based on the rules described in Chapter 5 of https://threeplusone.com/pubs/on_gates.pdf</p> Source code in <code>opensquirrel/ir/semantics/canonical_gate.py</code> <pre><code>@staticmethod\ndef restrict_to_weyl_chamber(axis: NDArray[np.float64]) -&gt; NDArray[np.float64]:\n    \"\"\"Restrict the given axis to the Weyl chamber. The six rules that are\n    (implicitly) used are:\n        1. The canonical parameters are periodic with a period of 2 (neglecting\n           a global phase).\n        2. Can(tx, ty, tz) ~ Can(tx - 1, ty, tz) (for any parameter)\n        3. Can(tx, ty, tz) ~ Can(tx, -ty, -tz) (for any pair of parameters)\n        4. Can(tx, ty, tz) ~ Can(ty, tx, tz) (for any pair of parameters)\n        5. Can(tx, ty, 0) ~ Can(1 - tx, ty, 0)\n        6. Can(tx, ty, tz) x Can(tx', ty', tz') = Can(tx + tx', ty + ty', tz + tz')\n           (here x represents matrix multiplication)\n\n    Based on the rules described in Chapter 5 of https://threeplusone.com/pubs/on_gates.pdf\n    \"\"\"\n    axis = (axis + 1) % 2 - 1\n\n    while (axis &lt; 0).any():\n        axis = np.where(axis &lt; 0, axis - 1, axis)\n        axis = (axis + 1) % 2 - 1\n\n    axis = np.sort(axis)[::-1]\n    match sum(t &gt; 1 / 2 for t in axis):\n        case 1:\n            axis[0] = 1 - axis[0]\n        case 2:\n            axis[0], axis[2] = axis[2], axis[0]\n            axis[1:] = 1 - axis[1:]\n        case 3:\n            axis = 1 - axis\n\n    return np.sort(axis)[::-1]\n</code></pre>"},{"location":"reference/ir/semantics/controlled_gate.html","title":"controlled_gate","text":""},{"location":"reference/ir/semantics/gate_semantic.html","title":"gate_semantic","text":""},{"location":"reference/ir/semantics/matrix_gate.html","title":"matrix_gate","text":""},{"location":"reference/passes/decomposer/aba_decomposer.html","title":"aba_decomposer","text":"<p>Module containing classes that inherit from the ABADecomposer class to decompose a circuit into one of the Pauli ABA decompositions.</p>"},{"location":"reference/passes/decomposer/aba_decomposer.html#opensquirrel.passes.decomposer.aba_decomposer.ABADecomposer","title":"<code>ABADecomposer</code>","text":"<p>               Bases: <code>Decomposer</code>, <code>ABC</code></p> Source code in <code>opensquirrel/passes/decomposer/aba_decomposer.py</code> <pre><code>class ABADecomposer(Decomposer, ABC):\n    @property\n    @abstractmethod\n    def ra(self) -&gt; Callable[..., SingleQubitGate]: ...\n\n    @property\n    @abstractmethod\n    def rb(self) -&gt; Callable[..., SingleQubitGate]: ...\n\n    _gate_list: ClassVar[list[Callable[..., SingleQubitGate]]] = [Rx, Ry, Rz]\n\n    def __init__(self, **kwargs: Any) -&gt; None:\n        super().__init__(**kwargs)\n        self.index_a = self._gate_list.index(self.ra)\n        self.index_b = self._gate_list.index(self.rb)\n\n    def _find_unused_index(self) -&gt; int:\n        \"\"\"Finds the index of the axis object that is not used in the decomposition.\n        For example, if one selects the ZYZ decomposition, the integer returned will be 0 (since it is X).\n\n        Returns:\n            Index of the axis object that is not used in the decomposition.\n        \"\"\"\n        return ({0, 1, 2} - {self.index_a, self.index_b}).pop()\n\n    def _set_a_b_c_axes_values(self, axis: AxisLike) -&gt; tuple[Any, Any, Any]:\n        \"\"\"Given:\n        - an A-B-A decomposition strategy (where A and B can be either X, Y, or Z), and\n        - a rotation axis { X: x, Y: y, Z: z } corresponding to a Bloch sphere rotation.\n        Sets a new rotation axis (a, b, c) such that a = axis[A], b = axis[B], and c = axis[C].\n        For example, given a Z-X-Z decomposition strategy, and an axis (x, y, z), sets (a, b, c) = (z, x, y).\n\n        Parameters:\n            axis: _normalized_ axis of a Bloch sphere rotation\n\n         Returns:\n             A triplet (a, b, c) where a, b, and c are the values of x, y, and z reordered.\n        \"\"\"\n        axis_ = Axis(axis)\n        return axis_[self.index_a], axis_[self.index_b], axis_[self._find_unused_index()]\n\n    @staticmethod\n    def _are_b_and_c_axes_in_negative_octant(b_axis_value: float, c_axis_value: float) -&gt; bool:\n        \"\"\"Given an ABC axis system, and the values for axes B and C.\n        Checks if the values for the B and C axes fall in one of the two negative octants (A positive or negative,\n        and B and C negative, or one of them zero).\n\n        Returns:\n            True if the values for axis B and C are both negative or zero, but not zero at the same time.\n            False otherwise.\n        \"\"\"\n        return (\n            (b_axis_value &lt; 0 or abs(b_axis_value) &lt; ATOL)\n            and (c_axis_value &lt; 0 or abs(c_axis_value) &lt; ATOL)\n            and not (abs(b_axis_value) &lt; ATOL and abs(c_axis_value) &lt; ATOL)\n        )\n\n    def get_decomposition_angles(self, axis: AxisLike, alpha: float) -&gt; tuple[float, float, float]:\n        \"\"\"Given:\n        - an A-B-A decomposition strategy (where A and B can be either X, Y, or Z), and\n        - the rotation axis and angle corresponding to a Bloch sphere rotation.\n        Calculates the rotation angles around axes A, B, and C,\n        such that the original Bloch sphere rotation can be expressed as U = Ra(theta3) Rb(theta2) Rc(theta1),\n        Rn meaning rotation around axis N\n\n        Parameters:\n            axis: _normalized_ axis of a Bloch sphere rotation\n            alpha: angle of a Bloch sphere rotation\n\n        Returns:\n            A triplet (theta_1, theta_2, theta_3), where theta_1, theta_2, and theta_3 are the rotation angles around\n            axes A, B, and C, respectively.\n        \"\"\"\n        if not (-math.pi + ATOL &lt; alpha &lt;= math.pi + ATOL):\n            msg = \"angle needs to be normalized\"\n            raise ValueError(msg)\n\n        a_axis_value, b_axis_value, c_axis_value = self._set_a_b_c_axes_values(axis)\n\n        # Calculate primary angle\n        p = 2 * math.atan2(a_axis_value * math.sin(alpha / 2), math.cos(alpha / 2))\n\n        # Calculate theta 2\n        theta_2 = 2 * acos(math.cos(alpha / 2) * math.sqrt(1 + (a_axis_value * math.tan(alpha / 2)) ** 2))\n        theta_2 = math.copysign(theta_2, alpha)\n\n        # Calculate secondary angle\n        if abs(math.sin(theta_2 / 2)) &lt; ATOL:\n            # This can be anything, but setting m = p means theta_3 == 0, which is better for gate count.\n            m = p\n        else:\n            m = 2 * acos(float(b_axis_value) * math.sin(alpha / 2) / math.sin(theta_2 / 2))\n            if math.pi - abs(m) &gt; ATOL:\n                ret_sign = 2 * math.atan2(c_axis_value, a_axis_value)\n                m = math.copysign(m, ret_sign)\n\n        # Check if the sign of the secondary angle has to be flipped\n        if are_axes_consecutive(self.index_a, self.index_b):\n            m = -m\n\n        # Calculate theta 1 and theta 2\n        theta_1 = (p + m) / 2\n        theta_3 = p - theta_1\n\n        # Check if theta 1 and theta 3 have to be swapped\n        if ABADecomposer._are_b_and_c_axes_in_negative_octant(b_axis_value, c_axis_value):\n            theta_1, theta_3 = theta_3, theta_1\n\n        return theta_1, theta_2, theta_3\n\n    def decompose(self, g: Gate) -&gt; list[Gate]:\n        \"\"\"General A-B-A decomposition function for a single gate.\n\n        Args:\n            g: gate to decompose.\n\n        Returns:\n            Three gates, following the A-B-A convention, corresponding to the decomposition of the input gate.\n        \"\"\"\n        if not isinstance(g, SingleQubitGate):\n            return [g]\n\n        theta1, theta2, theta3 = self.get_decomposition_angles(g.bsr.axis, g.bsr.angle)\n        a1 = self.ra(g.qubit, theta1)\n        b = self.rb(g.qubit, theta2)\n        a2 = self.ra(g.qubit, theta3)\n\n        return filter_out_identities([a1, b, a2])\n</code></pre>"},{"location":"reference/passes/decomposer/aba_decomposer.html#opensquirrel.passes.decomposer.aba_decomposer.ABADecomposer.decompose","title":"<code>decompose(g)</code>","text":"<p>General A-B-A decomposition function for a single gate.</p> <p>Parameters:</p> Name Type Description Default <code>g</code> <code>Gate</code> <p>gate to decompose.</p> required <p>Returns:</p> Type Description <code>list[Gate]</code> <p>Three gates, following the A-B-A convention, corresponding to the decomposition of the input gate.</p> Source code in <code>opensquirrel/passes/decomposer/aba_decomposer.py</code> <pre><code>def decompose(self, g: Gate) -&gt; list[Gate]:\n    \"\"\"General A-B-A decomposition function for a single gate.\n\n    Args:\n        g: gate to decompose.\n\n    Returns:\n        Three gates, following the A-B-A convention, corresponding to the decomposition of the input gate.\n    \"\"\"\n    if not isinstance(g, SingleQubitGate):\n        return [g]\n\n    theta1, theta2, theta3 = self.get_decomposition_angles(g.bsr.axis, g.bsr.angle)\n    a1 = self.ra(g.qubit, theta1)\n    b = self.rb(g.qubit, theta2)\n    a2 = self.ra(g.qubit, theta3)\n\n    return filter_out_identities([a1, b, a2])\n</code></pre>"},{"location":"reference/passes/decomposer/aba_decomposer.html#opensquirrel.passes.decomposer.aba_decomposer.ABADecomposer.get_decomposition_angles","title":"<code>get_decomposition_angles(axis, alpha)</code>","text":"<p>Given: - an A-B-A decomposition strategy (where A and B can be either X, Y, or Z), and - the rotation axis and angle corresponding to a Bloch sphere rotation. Calculates the rotation angles around axes A, B, and C, such that the original Bloch sphere rotation can be expressed as U = Ra(theta3) Rb(theta2) Rc(theta1), Rn meaning rotation around axis N</p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>AxisLike</code> <p>normalized axis of a Bloch sphere rotation</p> required <code>alpha</code> <code>float</code> <p>angle of a Bloch sphere rotation</p> required <p>Returns:</p> Type Description <code>float</code> <p>A triplet (theta_1, theta_2, theta_3), where theta_1, theta_2, and theta_3 are the rotation angles around</p> <code>float</code> <p>axes A, B, and C, respectively.</p> Source code in <code>opensquirrel/passes/decomposer/aba_decomposer.py</code> <pre><code>def get_decomposition_angles(self, axis: AxisLike, alpha: float) -&gt; tuple[float, float, float]:\n    \"\"\"Given:\n    - an A-B-A decomposition strategy (where A and B can be either X, Y, or Z), and\n    - the rotation axis and angle corresponding to a Bloch sphere rotation.\n    Calculates the rotation angles around axes A, B, and C,\n    such that the original Bloch sphere rotation can be expressed as U = Ra(theta3) Rb(theta2) Rc(theta1),\n    Rn meaning rotation around axis N\n\n    Parameters:\n        axis: _normalized_ axis of a Bloch sphere rotation\n        alpha: angle of a Bloch sphere rotation\n\n    Returns:\n        A triplet (theta_1, theta_2, theta_3), where theta_1, theta_2, and theta_3 are the rotation angles around\n        axes A, B, and C, respectively.\n    \"\"\"\n    if not (-math.pi + ATOL &lt; alpha &lt;= math.pi + ATOL):\n        msg = \"angle needs to be normalized\"\n        raise ValueError(msg)\n\n    a_axis_value, b_axis_value, c_axis_value = self._set_a_b_c_axes_values(axis)\n\n    # Calculate primary angle\n    p = 2 * math.atan2(a_axis_value * math.sin(alpha / 2), math.cos(alpha / 2))\n\n    # Calculate theta 2\n    theta_2 = 2 * acos(math.cos(alpha / 2) * math.sqrt(1 + (a_axis_value * math.tan(alpha / 2)) ** 2))\n    theta_2 = math.copysign(theta_2, alpha)\n\n    # Calculate secondary angle\n    if abs(math.sin(theta_2 / 2)) &lt; ATOL:\n        # This can be anything, but setting m = p means theta_3 == 0, which is better for gate count.\n        m = p\n    else:\n        m = 2 * acos(float(b_axis_value) * math.sin(alpha / 2) / math.sin(theta_2 / 2))\n        if math.pi - abs(m) &gt; ATOL:\n            ret_sign = 2 * math.atan2(c_axis_value, a_axis_value)\n            m = math.copysign(m, ret_sign)\n\n    # Check if the sign of the secondary angle has to be flipped\n    if are_axes_consecutive(self.index_a, self.index_b):\n        m = -m\n\n    # Calculate theta 1 and theta 2\n    theta_1 = (p + m) / 2\n    theta_3 = p - theta_1\n\n    # Check if theta 1 and theta 3 have to be swapped\n    if ABADecomposer._are_b_and_c_axes_in_negative_octant(b_axis_value, c_axis_value):\n        theta_1, theta_3 = theta_3, theta_1\n\n    return theta_1, theta_2, theta_3\n</code></pre>"},{"location":"reference/passes/decomposer/aba_decomposer.html#opensquirrel.passes.decomposer.aba_decomposer.XYXDecomposer","title":"<code>XYXDecomposer</code>","text":"<p>               Bases: <code>ABADecomposer</code></p> <p>Class responsible for the X-Y-X decomposition.</p> Source code in <code>opensquirrel/passes/decomposer/aba_decomposer.py</code> <pre><code>class XYXDecomposer(ABADecomposer):\n    \"\"\"Class responsible for the X-Y-X decomposition.\"\"\"\n\n    @property\n    def ra(self) -&gt; Callable[..., SingleQubitGate]:\n        return Rx\n\n    @property\n    def rb(self) -&gt; Callable[..., SingleQubitGate]:\n        return Ry\n</code></pre>"},{"location":"reference/passes/decomposer/aba_decomposer.html#opensquirrel.passes.decomposer.aba_decomposer.XZXDecomposer","title":"<code>XZXDecomposer</code>","text":"<p>               Bases: <code>ABADecomposer</code></p> <p>Class responsible for the X-Z-X decomposition.</p> Source code in <code>opensquirrel/passes/decomposer/aba_decomposer.py</code> <pre><code>class XZXDecomposer(ABADecomposer):\n    \"\"\"Class responsible for the X-Z-X decomposition.\"\"\"\n\n    @property\n    def ra(self) -&gt; Callable[..., SingleQubitGate]:\n        return Rx\n\n    @property\n    def rb(self) -&gt; Callable[..., SingleQubitGate]:\n        return Rz\n</code></pre>"},{"location":"reference/passes/decomposer/aba_decomposer.html#opensquirrel.passes.decomposer.aba_decomposer.YXYDecomposer","title":"<code>YXYDecomposer</code>","text":"<p>               Bases: <code>ABADecomposer</code></p> <p>Class responsible for the Y-X-Y decomposition.</p> Source code in <code>opensquirrel/passes/decomposer/aba_decomposer.py</code> <pre><code>class YXYDecomposer(ABADecomposer):\n    \"\"\"Class responsible for the Y-X-Y decomposition.\"\"\"\n\n    @property\n    def ra(self) -&gt; Callable[..., SingleQubitGate]:\n        return Ry\n\n    @property\n    def rb(self) -&gt; Callable[..., SingleQubitGate]:\n        return Rx\n</code></pre>"},{"location":"reference/passes/decomposer/aba_decomposer.html#opensquirrel.passes.decomposer.aba_decomposer.YZYDecomposer","title":"<code>YZYDecomposer</code>","text":"<p>               Bases: <code>ABADecomposer</code></p> <p>Class responsible for the Y-Z-Y decomposition.</p> Source code in <code>opensquirrel/passes/decomposer/aba_decomposer.py</code> <pre><code>class YZYDecomposer(ABADecomposer):\n    \"\"\"Class responsible for the Y-Z-Y decomposition.\"\"\"\n\n    @property\n    def ra(self) -&gt; Callable[..., SingleQubitGate]:\n        return Ry\n\n    @property\n    def rb(self) -&gt; Callable[..., SingleQubitGate]:\n        return Rz\n</code></pre>"},{"location":"reference/passes/decomposer/aba_decomposer.html#opensquirrel.passes.decomposer.aba_decomposer.ZXZDecomposer","title":"<code>ZXZDecomposer</code>","text":"<p>               Bases: <code>ABADecomposer</code></p> <p>Class responsible for the Z-X-Z decomposition.</p> Source code in <code>opensquirrel/passes/decomposer/aba_decomposer.py</code> <pre><code>class ZXZDecomposer(ABADecomposer):\n    \"\"\"Class responsible for the Z-X-Z decomposition.\"\"\"\n\n    @property\n    def ra(self) -&gt; Callable[..., SingleQubitGate]:\n        return Rz\n\n    @property\n    def rb(self) -&gt; Callable[..., SingleQubitGate]:\n        return Rx\n</code></pre>"},{"location":"reference/passes/decomposer/aba_decomposer.html#opensquirrel.passes.decomposer.aba_decomposer.ZYZDecomposer","title":"<code>ZYZDecomposer</code>","text":"<p>               Bases: <code>ABADecomposer</code></p> <p>Class responsible for the Z-Y-Z decomposition.</p> Source code in <code>opensquirrel/passes/decomposer/aba_decomposer.py</code> <pre><code>class ZYZDecomposer(ABADecomposer):\n    \"\"\"Class responsible for the Z-Y-Z decomposition.\"\"\"\n\n    @property\n    def ra(self) -&gt; Callable[..., SingleQubitGate]:\n        return Rz\n\n    @property\n    def rb(self) -&gt; Callable[..., SingleQubitGate]:\n        return Ry\n</code></pre>"},{"location":"reference/passes/decomposer/cnot2cz_decomposer.html","title":"cnot2cz_decomposer","text":""},{"location":"reference/passes/decomposer/cnot2cz_decomposer.html#opensquirrel.passes.decomposer.cnot2cz_decomposer.CNOT2CZDecomposer","title":"<code>CNOT2CZDecomposer</code>","text":"<p>               Bases: <code>Decomposer</code></p> <p>Predefined decomposition of CNOT gate to CZ gate with Y rotations.</p> <p>---\u2022---     -----------------\u2022----------------    |     \u2192                   | ---\u2295---     --[Ry(-pi/2)]---[Z]---[Ry(pi/2)]--</p> Note <p>This decomposition preserves the global phase of the CNOT gate.</p> Source code in <code>opensquirrel/passes/decomposer/cnot2cz_decomposer.py</code> <pre><code>class CNOT2CZDecomposer(Decomposer):\n    \"\"\"Predefined decomposition of CNOT gate to CZ gate with Y rotations.\n\n    ---\u2022---     -----------------\u2022----------------\n       |     \u2192                   |\n    ---\u2295---     --[Ry(-pi/2)]---[Z]---[Ry(pi/2)]--\n\n    Note:\n        This decomposition preserves the global phase of the CNOT gate.\n    \"\"\"\n\n    def decompose(self, gate: Gate) -&gt; list[Gate]:\n        if gate.name != \"CNOT\":\n            return [gate]\n\n        control_qubit, target_qubit = gate.qubit_operands\n        return [\n            Ry(target_qubit, -pi / 2),\n            CZ(control_qubit, target_qubit),\n            Ry(target_qubit, pi / 2),\n        ]\n</code></pre>"},{"location":"reference/passes/decomposer/cnot_decomposer.html","title":"cnot_decomposer","text":""},{"location":"reference/passes/decomposer/cnot_decomposer.html#opensquirrel.passes.decomposer.cnot_decomposer.CNOTDecomposer","title":"<code>CNOTDecomposer</code>","text":"<p>               Bases: <code>Decomposer</code></p> <p>Decomposes 2-qubit controlled unitary gates to CNOT + Rz/Ry. Applying single-qubit gate fusion after this pass might be beneficial.</p> <p>Source of the math: https://threeplusone.com/pubs/on_gates.pdf, chapter 7.5 \"ABC decomposition\"</p> Source code in <code>opensquirrel/passes/decomposer/cnot_decomposer.py</code> <pre><code>class CNOTDecomposer(Decomposer):\n    \"\"\"\n    Decomposes 2-qubit controlled unitary gates to CNOT + Rz/Ry.\n    Applying single-qubit gate fusion after this pass might be beneficial.\n\n    Source of the math: https://threeplusone.com/pubs/on_gates.pdf, chapter 7.5 \"ABC decomposition\"\n    \"\"\"\n\n    def decompose(self, g: Gate) -&gt; list[Gate]:\n        if not isinstance(g, TwoQubitGate):\n            return [g]\n\n        if not g.controlled:\n            # Do nothing, this is not a controlled unitary gate.\n            return [g]\n\n        control_qubit = g.qubit0\n        target_qubit = g.qubit1\n        target_gate = g.controlled.target_gate\n\n        # Perform ZYZ decomposition on the target gate.\n        # This gives us an ABC decomposition (U = AXBXC, ABC = I) of the target gate.\n        # See https://threeplusone.com/pubs/on_gates.pdf\n\n        # Try special case first, see https://arxiv.org/pdf/quant-ph/9503016.pdf lemma 5.5\n        controlled_rotation_times_x = target_gate * X(target_qubit)\n        theta0_with_x, theta1_with_x, theta2_with_x = ZYZDecomposer().get_decomposition_angles(\n            controlled_rotation_times_x.bsr.axis,\n            controlled_rotation_times_x.bsr.angle,\n        )\n        if abs((theta0_with_x - theta2_with_x) % (2 * pi)) &lt; ATOL:\n            # The decomposition can use a single CNOT according to the lemma.\n            A = [Ry(target_qubit, -theta1_with_x / 2), Rz(target_qubit, -theta2_with_x)]  # noqa: N806\n            B = [Rz(target_qubit, theta2_with_x), Ry(target_qubit, theta1_with_x / 2)]  # noqa: N806\n            return filter_out_identities(\n                [\n                    *B,\n                    CNOT(control_qubit, target_qubit),\n                    *A,\n                    Rz(control_qubit, target_gate.bsr.phase - pi / 2),\n                ],\n            )\n\n        theta0, theta1, theta2 = ZYZDecomposer().get_decomposition_angles(target_gate.bsr.axis, target_gate.bsr.angle)\n\n        A = [Ry(target_qubit, theta1 / 2), Rz(target_qubit, theta2)]  # noqa: N806\n        B = [Rz(target_qubit, -(theta0 + theta2) / 2), Ry(target_qubit, -theta1 / 2)]  # noqa: N806\n        C = [Rz(target_qubit, (theta0 - theta2) / 2)]  # noqa: N806\n\n        return filter_out_identities(\n            [\n                *C,\n                CNOT(control_qubit, target_qubit),\n                *B,\n                CNOT(control_qubit, target_qubit),\n                *A,\n                Rz(control_qubit, target_gate.bsr.phase),\n            ],\n        )\n</code></pre>"},{"location":"reference/passes/decomposer/cz_decomposer.html","title":"cz_decomposer","text":""},{"location":"reference/passes/decomposer/cz_decomposer.html#opensquirrel.passes.decomposer.cz_decomposer.CZDecomposer","title":"<code>CZDecomposer</code>","text":"<p>               Bases: <code>Decomposer</code></p> <p>Decomposes 2-qubit controlled unitary gates to CZ + Rx/Ry. Applying single-qubit gate fusion after this pass might be beneficial.</p> <p>Source of the math: https://threeplusone.com/pubs/on_gates.pdf, chapter 7.5 \"ABC decomposition\"</p> Source code in <code>opensquirrel/passes/decomposer/cz_decomposer.py</code> <pre><code>class CZDecomposer(Decomposer):\n    \"\"\"\n    Decomposes 2-qubit controlled unitary gates to CZ + Rx/Ry.\n    Applying single-qubit gate fusion after this pass might be beneficial.\n\n    Source of the math: https://threeplusone.com/pubs/on_gates.pdf, chapter 7.5 \"ABC decomposition\"\n    \"\"\"\n\n    def decompose(self, g: Gate) -&gt; list[Gate]:\n        if not isinstance(g, TwoQubitGate):\n            return [g]\n\n        if not g.controlled:\n            # Do nothing:\n            # - BlochSphereRotation's are only single-qubit,\n            # - decomposing MatrixGate is currently not supported.\n            return [g]\n\n        control_qubit, target_qubit = g.qubit_operands\n        target_gate = g.controlled.target_gate\n\n        # Perform XYX decomposition on the target gate.\n        # This gives us an ABC decomposition (U = exp(i phase) * AZBZC, ABC = I) of the target gate.\n        # See https://threeplusone.com/pubs/on_gates.pdf\n\n        # Try special case first, see https://arxiv.org/pdf/quant-ph/9503016.pdf lemma 5.5\n        # Note that here V = Rx(a) * Ry(th) * Rx(a) * Z to create V = AZBZ, with AB = I\n        controlled_rotation_times_z = target_gate * Z(target_qubit)\n        theta0_with_z, theta1_with_z, theta2_with_z = XYXDecomposer().get_decomposition_angles(\n            controlled_rotation_times_z.bsr.axis,\n            controlled_rotation_times_z.bsr.angle,\n        )\n        if abs((theta0_with_z - theta2_with_z) % (2 * pi)) &lt; ATOL:\n            # The decomposition can use a single CZ according to the lemma.\n            A = [Ry(target_qubit, theta1_with_z / 2), Rx(target_qubit, theta2_with_z)]  # noqa: N806\n            B = [Rx(target_qubit, -theta2_with_z), Ry(target_qubit, -theta1_with_z / 2)]  # noqa: N806\n            return filter_out_identities(\n                [\n                    *B,\n                    CZ(control_qubit, target_qubit),\n                    *A,\n                    Rz(control_qubit, target_gate.bsr.phase - pi / 2),\n                ],\n            )\n\n        theta0, theta1, theta2 = XYXDecomposer().get_decomposition_angles(target_gate.bsr.axis, target_gate.bsr.angle)\n\n        A = [Ry(target_qubit, theta1 / 2), Rx(target_qubit, theta2)]  # noqa: N806\n        B = [Rx(target_qubit, -(theta0 + theta2) / 2), Ry(target_qubit, -theta1 / 2)]  # noqa: N806\n        C = [Rx(target_qubit, (theta0 - theta2) / 2)]  # noqa: N806\n\n        return filter_out_identities(\n            [\n                *C,\n                CZ(control_qubit, target_qubit),\n                *B,\n                CZ(control_qubit, target_qubit),\n                *A,\n                Rz(control_qubit, target_gate.bsr.phase),\n            ],\n        )\n</code></pre>"},{"location":"reference/passes/decomposer/general_decomposer.html","title":"general_decomposer","text":""},{"location":"reference/passes/decomposer/general_decomposer.html#opensquirrel.passes.decomposer.general_decomposer.decompose","title":"<code>decompose(ir, decomposer)</code>","text":"<p>Applies <code>decomposer</code> to every gate in the circuit, replacing each gate by the output of <code>decomposer</code>. When <code>decomposer</code> decides to not decomposer a gate, it needs to return a list with the intact gate as single element.</p> Source code in <code>opensquirrel/passes/decomposer/general_decomposer.py</code> <pre><code>def decompose(ir: IR, decomposer: Decomposer) -&gt; None:\n    \"\"\"Applies `decomposer` to every gate in the circuit, replacing each gate by the output of `decomposer`.\n    When `decomposer` decides to not decomposer a gate, it needs to return a list with the intact gate as single\n    element.\n    \"\"\"\n    statement_index = 0\n    while statement_index &lt; len(ir.statements):\n        statement = ir.statements[statement_index]\n\n        if not isinstance(statement, Gate):\n            statement_index += 1\n            continue\n\n        gate = statement\n        replacement_gates: list[Gate] = decomposer.decompose(statement)\n        check_gate_replacement(gate, replacement_gates)\n\n        ir.statements[statement_index : statement_index + 1] = replacement_gates\n        statement_index += len(replacement_gates)\n</code></pre>"},{"location":"reference/passes/decomposer/general_decomposer.html#opensquirrel.passes.decomposer.general_decomposer.replace","title":"<code>replace(ir, gate, replacement_gates_function)</code>","text":"<p>Does the same as decomposer, but only applies to a given gate.</p> Source code in <code>opensquirrel/passes/decomposer/general_decomposer.py</code> <pre><code>def replace(ir: IR, gate: type[Gate], replacement_gates_function: Callable[..., list[Gate]]) -&gt; None:\n    \"\"\"Does the same as decomposer, but only applies to a given gate.\"\"\"\n    generic_replacer = _GenericReplacer(gate, replacement_gates_function)\n\n    decompose(ir, generic_replacer)\n</code></pre>"},{"location":"reference/passes/decomposer/mckay_decomposer.html","title":"mckay_decomposer","text":""},{"location":"reference/passes/decomposer/mckay_decomposer.html#opensquirrel.passes.decomposer.mckay_decomposer.McKayDecomposer","title":"<code>McKayDecomposer</code>","text":"<p>               Bases: <code>Decomposer</code></p> Source code in <code>opensquirrel/passes/decomposer/mckay_decomposer.py</code> <pre><code>class McKayDecomposer(Decomposer):\n    def decompose(self, g: Gate) -&gt; list[Gate]:\n        \"\"\"Return the McKay decomposition of a 1-qubit gate as a list of gates.\n                gate   ----&gt;    Rz.Rx(pi/2).Rz.Rx(pi/2).Rz\n\n        The global phase is deemed _irrelevant_, therefore a simulator backend might produce different output.\n        The results should be equivalent modulo global phase.\n        Notice that, if the gate is Rz or X90, it will not be decomposed further, since they are natively used\n        in the McKay decomposition.\n\n        Relevant literature: https://arxiv.org/abs/1612.00858\n        \"\"\"\n        if not isinstance(g, SingleQubitGate) or g == X90(g.qubit):\n            return [g]\n\n        if abs(g.bsr.angle) &lt; ATOL:\n            return [I(g.qubit)]\n\n        if g.bsr.axis[0] == 0 and g.bsr.axis[1] == 0:\n            rz_angle = float(g.bsr.angle * g.bsr.axis[2])\n            return [Rz(g.qubit, rz_angle)]\n\n        zxz_decomposition = ZXZDecomposer().decompose(g)\n        zxz_angle = 0.0\n        if len(zxz_decomposition) &gt;= 2:\n            zxz_angle = next(\n                gate.bsr.angle\n                for gate in zxz_decomposition\n                if isinstance(gate, SingleQubitGate) and gate.bsr.axis == Axis(1, 0, 0)\n            )\n\n        if abs(zxz_angle - pi / 2) &lt; ATOL:\n            return [\n                X90(g.qubit) if isinstance(gate, SingleQubitGate) and gate.bsr.axis == Axis(1, 0, 0) else gate\n                for gate in zxz_decomposition\n            ]\n\n        # McKay decomposition\n        za_mod = sqrt(cos(g.bsr.angle / 2) ** 2 + (g.bsr.axis[2] * sin(g.bsr.angle / 2)) ** 2)\n        zb_mod = abs(sin(g.bsr.angle / 2)) * sqrt(g.bsr.axis[0] ** 2 + g.bsr.axis[1] ** 2)\n\n        theta = pi - 2 * atan2(zb_mod, za_mod)\n\n        alpha = atan2(-sin(g.bsr.angle / 2) * g.bsr.axis[2], cos(g.bsr.angle / 2))\n        beta = atan2(-sin(g.bsr.angle / 2) * g.bsr.axis[0], -sin(g.bsr.angle / 2) * g.bsr.axis[1])\n\n        lam = beta - alpha\n        phi = -beta - alpha - pi\n\n        lam = normalize_angle(lam)\n        phi = normalize_angle(phi)\n        theta = normalize_angle(theta)\n\n        decomposed_g: list[Gate] = []\n\n        if abs(theta) &lt; ATOL and lam == phi:\n            decomposed_g.extend((X90(g.qubit), X90(g.qubit)))\n            return decomposed_g\n\n        if abs(lam) &gt; ATOL:\n            decomposed_g.append(Rz(g.qubit, lam))\n\n        decomposed_g.append(X90(g.qubit))\n\n        if abs(theta) &gt; ATOL:\n            decomposed_g.append(Rz(g.qubit, theta))\n\n        decomposed_g.append(X90(g.qubit))\n\n        if abs(phi) &gt; ATOL:\n            decomposed_g.append(Rz(g.qubit, phi))\n\n        return decomposed_g\n</code></pre>"},{"location":"reference/passes/decomposer/mckay_decomposer.html#opensquirrel.passes.decomposer.mckay_decomposer.McKayDecomposer.decompose","title":"<code>decompose(g)</code>","text":"<p>Return the McKay decomposition of a 1-qubit gate as a list of gates.         gate   ----&gt;    Rz.Rx(pi/2).Rz.Rx(pi/2).Rz</p> <p>The global phase is deemed irrelevant, therefore a simulator backend might produce different output. The results should be equivalent modulo global phase. Notice that, if the gate is Rz or X90, it will not be decomposed further, since they are natively used in the McKay decomposition.</p> <p>Relevant literature: https://arxiv.org/abs/1612.00858</p> Source code in <code>opensquirrel/passes/decomposer/mckay_decomposer.py</code> <pre><code>def decompose(self, g: Gate) -&gt; list[Gate]:\n    \"\"\"Return the McKay decomposition of a 1-qubit gate as a list of gates.\n            gate   ----&gt;    Rz.Rx(pi/2).Rz.Rx(pi/2).Rz\n\n    The global phase is deemed _irrelevant_, therefore a simulator backend might produce different output.\n    The results should be equivalent modulo global phase.\n    Notice that, if the gate is Rz or X90, it will not be decomposed further, since they are natively used\n    in the McKay decomposition.\n\n    Relevant literature: https://arxiv.org/abs/1612.00858\n    \"\"\"\n    if not isinstance(g, SingleQubitGate) or g == X90(g.qubit):\n        return [g]\n\n    if abs(g.bsr.angle) &lt; ATOL:\n        return [I(g.qubit)]\n\n    if g.bsr.axis[0] == 0 and g.bsr.axis[1] == 0:\n        rz_angle = float(g.bsr.angle * g.bsr.axis[2])\n        return [Rz(g.qubit, rz_angle)]\n\n    zxz_decomposition = ZXZDecomposer().decompose(g)\n    zxz_angle = 0.0\n    if len(zxz_decomposition) &gt;= 2:\n        zxz_angle = next(\n            gate.bsr.angle\n            for gate in zxz_decomposition\n            if isinstance(gate, SingleQubitGate) and gate.bsr.axis == Axis(1, 0, 0)\n        )\n\n    if abs(zxz_angle - pi / 2) &lt; ATOL:\n        return [\n            X90(g.qubit) if isinstance(gate, SingleQubitGate) and gate.bsr.axis == Axis(1, 0, 0) else gate\n            for gate in zxz_decomposition\n        ]\n\n    # McKay decomposition\n    za_mod = sqrt(cos(g.bsr.angle / 2) ** 2 + (g.bsr.axis[2] * sin(g.bsr.angle / 2)) ** 2)\n    zb_mod = abs(sin(g.bsr.angle / 2)) * sqrt(g.bsr.axis[0] ** 2 + g.bsr.axis[1] ** 2)\n\n    theta = pi - 2 * atan2(zb_mod, za_mod)\n\n    alpha = atan2(-sin(g.bsr.angle / 2) * g.bsr.axis[2], cos(g.bsr.angle / 2))\n    beta = atan2(-sin(g.bsr.angle / 2) * g.bsr.axis[0], -sin(g.bsr.angle / 2) * g.bsr.axis[1])\n\n    lam = beta - alpha\n    phi = -beta - alpha - pi\n\n    lam = normalize_angle(lam)\n    phi = normalize_angle(phi)\n    theta = normalize_angle(theta)\n\n    decomposed_g: list[Gate] = []\n\n    if abs(theta) &lt; ATOL and lam == phi:\n        decomposed_g.extend((X90(g.qubit), X90(g.qubit)))\n        return decomposed_g\n\n    if abs(lam) &gt; ATOL:\n        decomposed_g.append(Rz(g.qubit, lam))\n\n    decomposed_g.append(X90(g.qubit))\n\n    if abs(theta) &gt; ATOL:\n        decomposed_g.append(Rz(g.qubit, theta))\n\n    decomposed_g.append(X90(g.qubit))\n\n    if abs(phi) &gt; ATOL:\n        decomposed_g.append(Rz(g.qubit, phi))\n\n    return decomposed_g\n</code></pre>"},{"location":"reference/passes/decomposer/swap2cnot_decomposer.html","title":"swap2cnot_decomposer","text":""},{"location":"reference/passes/decomposer/swap2cnot_decomposer.html#opensquirrel.passes.decomposer.swap2cnot_decomposer.SWAP2CNOTDecomposer","title":"<code>SWAP2CNOTDecomposer</code>","text":"<p>               Bases: <code>Decomposer</code></p> <p>Predefined decomposition of SWAP gate to 3 CNOT gates. ---x---     ----\u2022---[X]---\u2022----    |     \u2192      |    |    | ---x---     ---[X]---\u2022---[X]--- Note:     This decomposition preserves the global phase of the SWAP gate.</p> Source code in <code>opensquirrel/passes/decomposer/swap2cnot_decomposer.py</code> <pre><code>class SWAP2CNOTDecomposer(Decomposer):\n    \"\"\"Predefined decomposition of SWAP gate to 3 CNOT gates.\n    ---x---     ----\u2022---[X]---\u2022----\n       |     \u2192      |    |    |\n    ---x---     ---[X]---\u2022---[X]---\n    Note:\n        This decomposition preserves the global phase of the SWAP gate.\n    \"\"\"\n\n    def decompose(self, gate: Gate) -&gt; list[Gate]:\n        if gate.name != \"SWAP\":\n            return [gate]\n        qubit0, qubit1 = gate.qubit_operands\n        return [\n            CNOT(qubit0, qubit1),\n            CNOT(qubit1, qubit0),\n            CNOT(qubit0, qubit1),\n        ]\n</code></pre>"},{"location":"reference/passes/decomposer/swap2cz_decomposer.html","title":"swap2cz_decomposer","text":""},{"location":"reference/passes/decomposer/swap2cz_decomposer.html#opensquirrel.passes.decomposer.swap2cz_decomposer.SWAP2CZDecomposer","title":"<code>SWAP2CZDecomposer</code>","text":"<p>               Bases: <code>Decomposer</code></p> <p>Predefined decomposition of SWAP gate to Ry rotations and 3 CZ gates. ---x---     -------------\u2022-[Ry(-pi/2)]-\u2022-[Ry(+pi/2)]-\u2022-------------    |     \u2192               |             |             | ---x---     -[Ry(-pi/2)]-\u2022-[Ry(+pi/2)]-\u2022-[Ry(-pi/2)]-\u2022-[Ry(+pi/2)]- Note:     This decomposition preserves the global phase of the SWAP gate.</p> Source code in <code>opensquirrel/passes/decomposer/swap2cz_decomposer.py</code> <pre><code>class SWAP2CZDecomposer(Decomposer):\n    \"\"\"Predefined decomposition of SWAP gate to Ry rotations and 3 CZ gates.\n    ---x---     -------------\u2022-[Ry(-pi/2)]-\u2022-[Ry(+pi/2)]-\u2022-------------\n       |     \u2192               |             |             |\n    ---x---     -[Ry(-pi/2)]-\u2022-[Ry(+pi/2)]-\u2022-[Ry(-pi/2)]-\u2022-[Ry(+pi/2)]-\n    Note:\n        This decomposition preserves the global phase of the SWAP gate.\n    \"\"\"\n\n    def decompose(self, gate: Gate) -&gt; list[Gate]:\n        if gate.name != \"SWAP\":\n            return [gate]\n        qubit0, qubit1 = gate.qubit_operands\n        return [\n            Ry(qubit1, -pi / 2),\n            CZ(qubit0, qubit1),\n            Ry(qubit1, pi / 2),\n            Ry(qubit0, -pi / 2),\n            CZ(qubit1, qubit0),\n            Ry(qubit0, pi / 2),\n            Ry(qubit1, -pi / 2),\n            CZ(qubit0, qubit1),\n            Ry(qubit1, pi / 2),\n        ]\n</code></pre>"},{"location":"reference/passes/exporter/cqasmv1_exporter.html","title":"cqasmv1_exporter","text":""},{"location":"reference/passes/exporter/general_exporter.html","title":"general_exporter","text":""},{"location":"reference/passes/exporter/general_exporter.html#opensquirrel.passes.exporter.general_exporter.Exporter","title":"<code>Exporter</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>opensquirrel/passes/exporter/general_exporter.py</code> <pre><code>class Exporter(ABC):\n    def __init__(self, **kwargs: Any) -&gt; None:\n        \"\"\"Generic router class\"\"\"\n\n    @abstractmethod\n    def export(self, circuit: Circuit) -&gt; Any:\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/passes/exporter/general_exporter.html#opensquirrel.passes.exporter.general_exporter.Exporter.__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>Generic router class</p> Source code in <code>opensquirrel/passes/exporter/general_exporter.py</code> <pre><code>def __init__(self, **kwargs: Any) -&gt; None:\n    \"\"\"Generic router class\"\"\"\n</code></pre>"},{"location":"reference/passes/exporter/quantify_scheduler_exporter.html","title":"quantify_scheduler_exporter","text":""},{"location":"reference/passes/mapper/check_mapper.html","title":"check_mapper","text":"<p>This module contains checks for the <code>Mapper</code> pass.</p>"},{"location":"reference/passes/mapper/check_mapper.html#opensquirrel.passes.mapper.check_mapper.check_mapper","title":"<code>check_mapper(mapper)</code>","text":"<p>Check if the <code>mapper</code> complies with the OpenSquirrel requirements.</p> <p>If a <code>Mapper</code> implementation passes these checks, it should be compatible with the <code>Circuit.map</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>mapper</code> <code>Mapper</code> <p>Mapper to check.</p> required Source code in <code>opensquirrel/passes/mapper/check_mapper.py</code> <pre><code>def check_mapper(mapper: Mapper) -&gt; None:\n    \"\"\"Check if the `mapper` complies with the OpenSquirrel requirements.\n\n    If a ``Mapper`` implementation passes these checks, it should be compatible with the ``Circuit.map`` method.\n\n    Args:\n        mapper: Mapper to check.\n    \"\"\"\n    assert isinstance(mapper, Mapper)\n\n    register_manager = RegisterManager(\n        OrderedDict({DEFAULT_QUBIT_REGISTER_NAME: QubitRegister(10)}),\n        OrderedDict({DEFAULT_BIT_REGISTER_NAME: BitRegister(10)}),\n    )\n    ir = IR()\n    circuit = Circuit(register_manager, ir)\n    _check_scenario(circuit, mapper)\n\n    ir = IR()\n    ir.add_gate(SingleQubitGate(qubit=42, gate_semantic=BlochSphereRotation((1, 0, 0), 1, 2)))\n    ir.add_gate(TwoQubitGate(42, 100, gate_semantic=ControlledGateSemantic(I(100))))\n    ir.add_non_unitary(Measure(42, 42, (0, 0, 1)))\n    Circuit(register_manager, ir)\n    _check_scenario(circuit, mapper)\n</code></pre>"},{"location":"reference/passes/mapper/general_mapper.html","title":"general_mapper","text":"<p>This module contains generic mapping components.</p>"},{"location":"reference/passes/mapper/general_mapper.html#opensquirrel.passes.mapper.general_mapper.Mapper","title":"<code>Mapper</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for the Mapper pass.</p> Source code in <code>opensquirrel/passes/mapper/general_mapper.py</code> <pre><code>class Mapper(ABC):\n    \"\"\"Base class for the Mapper pass.\"\"\"\n\n    def __init__(self, **kwargs: Any) -&gt; None: ...\n\n    @abstractmethod\n    def map(self, ir: IR, qubit_register_size: int) -&gt; Mapping:\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/passes/mapper/mapping.html","title":"mapping","text":""},{"location":"reference/passes/mapper/mapping.html#opensquirrel.passes.mapper.mapping.Mapping","title":"<code>Mapping</code>","text":"A Mapping is a dictionary where <ul> <li>the keys are virtual qubit indices (from 0 to virtual_qubit_register_size-1), and</li> <li>the values are physical qubit indices.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>physical_qubit_register</code> <code>list[int]</code> <p>a list of physical qubit indices.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the mapping is incorrect.</p> Source code in <code>opensquirrel/passes/mapper/mapping.py</code> <pre><code>class Mapping:\n    \"\"\"A Mapping is a dictionary where:\n       - the keys are virtual qubit indices (from 0 to virtual_qubit_register_size-1), and\n       - the values are physical qubit indices.\n\n    Args:\n        physical_qubit_register: a list of physical qubit indices.\n\n    Raises:\n        ValueError: If the mapping is incorrect.\n    \"\"\"\n\n    def __init__(self, physical_qubit_register: list[int]) -&gt; None:\n        self.data: dict[int, int] = dict(enumerate(physical_qubit_register))\n        if (self.data.keys()) != set(self.data.values()):\n            msg = \"the mapping is incorrect\"\n            raise ValueError(msg)\n\n    def __eq__(self, other: Any) -&gt; bool:\n        if not isinstance(other, Mapping):\n            return False\n        return self.data == other.data\n\n    def __getitem__(self, key: int) -&gt; int:\n        return self.data[key]\n\n    def __len__(self) -&gt; int:\n        return len(self.data)\n\n    def size(self) -&gt; int:\n        return len(self.data)\n\n    def items(self) -&gt; list[tuple[int, int]]:\n        return list(self.data.items())\n\n    def keys(self) -&gt; list[int]:\n        return list(self.data.keys())\n\n    def values(self) -&gt; list[int]:\n        return list(self.data.values())\n</code></pre>"},{"location":"reference/passes/mapper/mip_mapper.html","title":"mip_mapper","text":""},{"location":"reference/passes/mapper/mip_mapper.html#opensquirrel.passes.mapper.mip_mapper.MIPMapper","title":"<code>MIPMapper</code>","text":"<p>               Bases: <code>Mapper</code></p> Source code in <code>opensquirrel/passes/mapper/mip_mapper.py</code> <pre><code>class MIPMapper(Mapper):\n    def __init__(\n        self,\n        connectivity: Connectivity,\n        timeout: float | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        super().__init__(**kwargs)\n        self.connectivity = connectivity\n        self.timeout = timeout\n\n    def map(self, ir: IR, qubit_register_size: int) -&gt; Mapping:\n        \"\"\"\n        Find an initial mapping of virtual qubits to physical qubits that minimizes\n        the sum of distances between mapped operands of all two-qubit gates, using\n        Mixed Integer Programming (MIP).\n\n        This method formulates the mapping as a linear assignment problem, where the\n        objective is to minimize the total \"distance cost\" of executing all two-qubit\n        gates, given the connectivity.\n\n        Args:\n            ir (IR): The intermediate representation of the quantum circuit to be mapped.\n            qubit_register_size (int): The number of virtual qubits in the circuit.\n\n        Returns:\n            Mapping: Mapping from virtual to physical qubits.\n\n        Raises:\n            RuntimeError: If the MIP solver fails to find a feasible mapping or times out.\n            RuntimeError: If the number of virtual qubits exceeds the number of physical qubits.\n        \"\"\"\n        num_physical_qubits = len(self.connectivity)\n\n        if qubit_register_size &gt; num_physical_qubits:\n            error_message = (\n                f\"Number of virtual qubits ({qubit_register_size}) exceeds \"\n                f\"number of physical qubits ({num_physical_qubits})\"\n            )\n            raise RuntimeError(error_message)\n\n        distance = self._get_distance(self.connectivity)\n        cost = self._get_cost(ir, distance, qubit_register_size, num_physical_qubits)\n        constraints, integrality, bounds = self._get_constraints(qubit_register_size, num_physical_qubits)\n        milp_options = self._get_milp_options()\n        mapping = self._solve_and_extract_mapping(\n            cost, constraints, integrality, bounds, milp_options, qubit_register_size, num_physical_qubits\n        )\n        return Mapping(mapping)\n\n    @staticmethod\n    def _get_distance(connectivity: dict[str, list[int]]) -&gt; list[list[int]]:\n        num_physical_qubits = len(connectivity)\n        distance = np.full((num_physical_qubits, num_physical_qubits), DISTANCE_UL, dtype=int)\n        np.fill_diagonal(distance, 0)\n\n        for start_qubit_index, end_qubit_indices in connectivity.items():\n            for end_qubit_index in end_qubit_indices:\n                distance[int(start_qubit_index), end_qubit_index] = 1\n\n        for k in range(num_physical_qubits):\n            for i in range(num_physical_qubits):\n                for j in range(num_physical_qubits):\n                    if distance[i][j] &gt; distance[i][k] + distance[k][j]:\n                        distance[i][j] = distance[i][k] + distance[k][j]\n\n        return list(distance)\n\n    def _get_cost(\n        self, ir: IR, distance: list[list[int]], num_virtual_qubits: int, num_physical_qubits: int\n    ) -&gt; list[list[int]]:\n        reference_counter = [[0 for _ in range(num_virtual_qubits)] for _ in range(num_virtual_qubits)]\n        for statement in getattr(ir, \"statements\", []):\n            if isinstance(statement, TwoQubitGate):\n                for q_0, q_1 in itertools.pairwise(statement.qubit_operands):\n                    reference_counter[q_0.index][q_1.index] += 1\n                    reference_counter[q_1.index][q_0.index] += 1\n\n        cost = [[0 for _ in range(num_physical_qubits)] for _ in range(num_virtual_qubits)]\n        for i in range(num_virtual_qubits):\n            for k in range(num_physical_qubits):\n                cost[i][k] = sum(\n                    reference_counter[i][j] * distance[k][l]\n                    for j in range(num_virtual_qubits)\n                    for l in range(num_physical_qubits)  # noqa: E741\n                )\n        return cost\n\n    def _get_constraints(\n        self, num_virtual_qubits: int, num_physical_qubits: int\n    ) -&gt; tuple[list[LinearConstraint], list[bool], Bounds]:\n        num_vars = num_virtual_qubits * num_physical_qubits\n        eq_a = np.zeros((num_virtual_qubits, num_vars))\n        for q_i in range(num_virtual_qubits):\n            for q_k in range(num_physical_qubits):\n                eq_a[q_i, q_i * num_physical_qubits + q_k] = 1\n        eq_b = np.ones(num_virtual_qubits)\n        ub_a = np.zeros((num_physical_qubits, num_vars))\n        for q_k in range(num_physical_qubits):\n            for q_i in range(num_virtual_qubits):\n                ub_a[q_k, q_i * num_physical_qubits + q_k] = 1\n        ub_b = np.ones(num_physical_qubits)\n        integrality = np.ones(num_vars, dtype=bool)\n        bounds = Bounds(0, 1)\n        constraints = [LinearConstraint(eq_a, eq_b, eq_b), LinearConstraint(ub_a, -np.inf, ub_b)]\n        return constraints, list(integrality), bounds\n\n    def _get_milp_options(self) -&gt; dict[str, float]:\n        milp_options = {}\n        if self.timeout is not None:\n            milp_options[\"time_limit\"] = self.timeout\n        return milp_options\n\n    def _solve_and_extract_mapping(\n        self,\n        cost_matrix: list[list[int]],\n        constraints: list[LinearConstraint],\n        integrality: list[bool],\n        bounds: Bounds,\n        milp_options: dict[str, float],\n        num_virtual_qubits: int,\n        num_physical_qubits: int,\n    ) -&gt; list[int]:\n        cost = np.array(cost_matrix).flatten()\n\n        res = milp(c=cost, constraints=constraints, integrality=integrality, bounds=bounds, options=milp_options)\n\n        if not res.success:\n            error_message = (\n                f\"MIP solver failed to find a feasible mapping. Status: {res.status}, Message: {res.message}\"\n            )\n            raise RuntimeError(error_message)\n\n        x_sol = res.x.reshape((num_virtual_qubits, num_physical_qubits))\n        mapping = []\n        for q_i in range(num_virtual_qubits):\n            q_k = int(np.argmax(x_sol[q_i]))\n            mapping.append(q_k)\n\n        return mapping\n</code></pre>"},{"location":"reference/passes/mapper/mip_mapper.html#opensquirrel.passes.mapper.mip_mapper.MIPMapper.map","title":"<code>map(ir, qubit_register_size)</code>","text":"<p>Find an initial mapping of virtual qubits to physical qubits that minimizes the sum of distances between mapped operands of all two-qubit gates, using Mixed Integer Programming (MIP).</p> <p>This method formulates the mapping as a linear assignment problem, where the objective is to minimize the total \"distance cost\" of executing all two-qubit gates, given the connectivity.</p> <p>Parameters:</p> Name Type Description Default <code>ir</code> <code>IR</code> <p>The intermediate representation of the quantum circuit to be mapped.</p> required <code>qubit_register_size</code> <code>int</code> <p>The number of virtual qubits in the circuit.</p> required <p>Returns:</p> Name Type Description <code>Mapping</code> <code>Mapping</code> <p>Mapping from virtual to physical qubits.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the MIP solver fails to find a feasible mapping or times out.</p> <code>RuntimeError</code> <p>If the number of virtual qubits exceeds the number of physical qubits.</p> Source code in <code>opensquirrel/passes/mapper/mip_mapper.py</code> <pre><code>def map(self, ir: IR, qubit_register_size: int) -&gt; Mapping:\n    \"\"\"\n    Find an initial mapping of virtual qubits to physical qubits that minimizes\n    the sum of distances between mapped operands of all two-qubit gates, using\n    Mixed Integer Programming (MIP).\n\n    This method formulates the mapping as a linear assignment problem, where the\n    objective is to minimize the total \"distance cost\" of executing all two-qubit\n    gates, given the connectivity.\n\n    Args:\n        ir (IR): The intermediate representation of the quantum circuit to be mapped.\n        qubit_register_size (int): The number of virtual qubits in the circuit.\n\n    Returns:\n        Mapping: Mapping from virtual to physical qubits.\n\n    Raises:\n        RuntimeError: If the MIP solver fails to find a feasible mapping or times out.\n        RuntimeError: If the number of virtual qubits exceeds the number of physical qubits.\n    \"\"\"\n    num_physical_qubits = len(self.connectivity)\n\n    if qubit_register_size &gt; num_physical_qubits:\n        error_message = (\n            f\"Number of virtual qubits ({qubit_register_size}) exceeds \"\n            f\"number of physical qubits ({num_physical_qubits})\"\n        )\n        raise RuntimeError(error_message)\n\n    distance = self._get_distance(self.connectivity)\n    cost = self._get_cost(ir, distance, qubit_register_size, num_physical_qubits)\n    constraints, integrality, bounds = self._get_constraints(qubit_register_size, num_physical_qubits)\n    milp_options = self._get_milp_options()\n    mapping = self._solve_and_extract_mapping(\n        cost, constraints, integrality, bounds, milp_options, qubit_register_size, num_physical_qubits\n    )\n    return Mapping(mapping)\n</code></pre>"},{"location":"reference/passes/mapper/qgym_mapper.html","title":"qgym_mapper","text":""},{"location":"reference/passes/mapper/qgym_mapper.html#opensquirrel.passes.mapper.qgym_mapper.QGymMapper","title":"<code>QGymMapper</code>","text":"<p>               Bases: <code>Mapper</code></p> <p>QGym-based mapper pass using a Stable-Baselines3 agent.</p> Source code in <code>opensquirrel/passes/mapper/qgym_mapper.py</code> <pre><code>class QGymMapper(Mapper):\n    \"\"\"QGym-based mapper pass using a Stable-Baselines3 agent.\"\"\"\n\n    def __init__(\n        self,\n        agent_class: str,\n        agent_path: str,\n        connectivity: Connectivity,\n        env_kwargs: dict[str, Any] | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        super().__init__(**kwargs)\n        self.hardware_connectivity = self._build_connectivity_graph(connectivity)\n        self.env = InitialMapping(connection_graph=self.hardware_connectivity, **(env_kwargs or {}))\n        self.agent = self._load_agent(agent_class, agent_path)\n\n    def map(self, ir: IR, qubit_register_size: int) -&gt; Mapping:\n        \"\"\"\n        Compute an initial logical-to-physical qubit mapping using a trained\n        Stable-Baselines3 agent acting in the QGym InitialMapping environment.\n\n        Args:\n            ir (IR): Intermediate representation of the quantum circuit to be mapped.\n            qubit_register_size (int): Number of logical (virtual) qubits in the circuit.\n\n        Returns:\n            Mapping: Mapping from virtual to physical qubits.\n\n        Raises:\n            ValueError: If the number of logical qubits differs from the number of physical qubits.\n            ValueError: If the agent produces an incomplete or invalid mapping.\n            RuntimeError: If no 'mapping' key is found in the final observation.\n        \"\"\"\n        num_physical = self.hardware_connectivity.number_of_nodes()\n        if qubit_register_size != num_physical:\n            msg = (\n                f\"The QGym mapper requires an equal number of logical and physical qubits.\"\n                f\"Respectively, got {qubit_register_size} logical and {num_physical} physical qubits instead.\"\n            )\n            raise ValueError(msg)\n\n        circuit_graph = self._ir_to_interaction_graph(ir)\n\n        obs, _ = self.env.reset(options={\"interaction_graph\": circuit_graph})\n\n        done = False\n        last_obs: Any = obs\n        while not done:\n            action, _ = self.agent.predict(obs, deterministic=True)\n            obs, _, terminated, truncated, _ = self.env.step(action)\n            done = terminated or truncated\n            last_obs = obs\n\n        return self._get_mapping(last_obs, qubit_register_size)\n\n    @staticmethod\n    def _build_connectivity_graph(connectivity: Connectivity) -&gt; nx.Graph:\n        \"\"\"Convert connectivity dictionary to NetworkX graph.\n\n        Args:\n            connectivity (Connectivity): Connectivity of the target backend.\n\n        Returns:\n            NetworkX graph representing the hardware connectivity.\n        \"\"\"\n        edges = []\n        for qubit_start, qubit_ends in connectivity.items():\n            for qubit_end in qubit_ends:\n                if [qubit_end, int(qubit_start)] in edges:\n                    continue\n                edges.append([int(qubit_start), qubit_end])\n        graph = nx.Graph()\n        graph.add_edges_from(edges)\n        return graph\n\n    @staticmethod\n    def _load_agent(agent_class: str, agent_path: str) -&gt; BaseAlgorithm:\n        \"\"\"Load a trained Stable-Baselines3 agent from a file.\"\"\"\n        if agent_class in [\"PPO\", \"A2C\"]:\n            sb3 = importlib.import_module(\"stable_baselines3\")\n        else:\n            sb3 = importlib.import_module(\"sb3_contrib\")\n        agent_cls = getattr(sb3, agent_class)\n        return cast(\"BaseAlgorithm\", agent_cls.load(agent_path))\n\n    @staticmethod\n    def _ir_to_interaction_graph(ir: IR) -&gt; nx.Graph:\n        \"\"\"Build an undirected interaction graph representation of the IR.\n\n        Args:\n            ir: Intermediate representation of the quantum circuit.\n\n        Returns:\n            NetworkX graph representation of the quantum circuit, compatible with QGym.\n        \"\"\"\n        interaction_graph = nx.Graph()\n        for statement in ir.statements:\n            if not isinstance(statement, Instruction):\n                continue\n            instruction = cast(\"Instruction\", statement)  # type: ignore[redundant-cast]\n            qubit_indices = instruction.qubit_indices\n            for q_index in qubit_indices:\n                interaction_graph.add_node(q_index)\n            if len(qubit_indices) &gt;= 2:\n                for q_i, q_j in combinations(qubit_indices, 2):\n                    if interaction_graph.has_edge(q_i, q_j):\n                        interaction_graph[q_i][q_j][\"weight\"] = interaction_graph[q_i][q_j].get(\"weight\", 1) + 1\n                    else:\n                        interaction_graph.add_edge(q_i, q_j, weight=1)\n        return interaction_graph\n\n    @staticmethod\n    def _get_mapping(last_obs: Any, qubit_register_size: int) -&gt; Mapping:\n        \"\"\"Extract and convert QGym's physical-to-logical mapping to OpenSquirrel's logical-to-physical mapping.\n\n        Args:\n            last_obs: Final observation from the QGym environment containing the mapping.\n            qubit_register_size: Number of qubits.\n\n        Returns:\n            Mapping object where index=logical qubit, value=physical qubit.\n\n        Raises:\n            RuntimeError: If 'mapping' key is not found in the observation.\n            ValueError: If mapping length doesn't match qubit_register_size.\n            ValueError: If the mapping is incomplete (not all logical qubits are mapped).\n        \"\"\"\n        if not isinstance(last_obs, dict) or last_obs.get(\"mapping\") is None:\n            msg = \"QGym environment did not provide 'mapping' in observation.\"\n            raise RuntimeError(msg)\n\n        mapping_data = last_obs[\"mapping\"]\n        physical_to_logical = mapping_data.tolist()\n\n        if len(physical_to_logical) != qubit_register_size:\n            msg = (\n                f\"Mapping length {len(physical_to_logical)} is not equal to \"\n                f\"the size of the qubit register {qubit_register_size}.\"\n            )\n            raise ValueError(msg)\n\n        logical_to_physical = [-1] * qubit_register_size\n        for physical_qubit, logical_qubit in enumerate(physical_to_logical):\n            if logical_qubit &lt; qubit_register_size:\n                logical_to_physical[logical_qubit] = physical_qubit\n\n        if -1 in logical_to_physical:\n            msg = f\"Incomplete mapping. Physical-to-logical: {physical_to_logical}\"\n            raise ValueError(msg)\n\n        return Mapping(logical_to_physical)\n</code></pre>"},{"location":"reference/passes/mapper/qgym_mapper.html#opensquirrel.passes.mapper.qgym_mapper.QGymMapper.map","title":"<code>map(ir, qubit_register_size)</code>","text":"<p>Compute an initial logical-to-physical qubit mapping using a trained Stable-Baselines3 agent acting in the QGym InitialMapping environment.</p> <p>Parameters:</p> Name Type Description Default <code>ir</code> <code>IR</code> <p>Intermediate representation of the quantum circuit to be mapped.</p> required <code>qubit_register_size</code> <code>int</code> <p>Number of logical (virtual) qubits in the circuit.</p> required <p>Returns:</p> Name Type Description <code>Mapping</code> <code>Mapping</code> <p>Mapping from virtual to physical qubits.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the number of logical qubits differs from the number of physical qubits.</p> <code>ValueError</code> <p>If the agent produces an incomplete or invalid mapping.</p> <code>RuntimeError</code> <p>If no 'mapping' key is found in the final observation.</p> Source code in <code>opensquirrel/passes/mapper/qgym_mapper.py</code> <pre><code>def map(self, ir: IR, qubit_register_size: int) -&gt; Mapping:\n    \"\"\"\n    Compute an initial logical-to-physical qubit mapping using a trained\n    Stable-Baselines3 agent acting in the QGym InitialMapping environment.\n\n    Args:\n        ir (IR): Intermediate representation of the quantum circuit to be mapped.\n        qubit_register_size (int): Number of logical (virtual) qubits in the circuit.\n\n    Returns:\n        Mapping: Mapping from virtual to physical qubits.\n\n    Raises:\n        ValueError: If the number of logical qubits differs from the number of physical qubits.\n        ValueError: If the agent produces an incomplete or invalid mapping.\n        RuntimeError: If no 'mapping' key is found in the final observation.\n    \"\"\"\n    num_physical = self.hardware_connectivity.number_of_nodes()\n    if qubit_register_size != num_physical:\n        msg = (\n            f\"The QGym mapper requires an equal number of logical and physical qubits.\"\n            f\"Respectively, got {qubit_register_size} logical and {num_physical} physical qubits instead.\"\n        )\n        raise ValueError(msg)\n\n    circuit_graph = self._ir_to_interaction_graph(ir)\n\n    obs, _ = self.env.reset(options={\"interaction_graph\": circuit_graph})\n\n    done = False\n    last_obs: Any = obs\n    while not done:\n        action, _ = self.agent.predict(obs, deterministic=True)\n        obs, _, terminated, truncated, _ = self.env.step(action)\n        done = terminated or truncated\n        last_obs = obs\n\n    return self._get_mapping(last_obs, qubit_register_size)\n</code></pre>"},{"location":"reference/passes/mapper/qubit_remapper.html","title":"qubit_remapper","text":""},{"location":"reference/passes/mapper/simple_mappers.html","title":"simple_mappers","text":"<p>This module contains the following simple mappers:</p> <ul> <li>IdentityMapper</li> <li>HardcodedMapper</li> <li>RandomMapper</li> </ul>"},{"location":"reference/passes/mapper/simple_mappers.html#opensquirrel.passes.mapper.simple_mappers.HardcodedMapper","title":"<code>HardcodedMapper</code>","text":"<p>               Bases: <code>Mapper</code></p> Source code in <code>opensquirrel/passes/mapper/simple_mappers.py</code> <pre><code>class HardcodedMapper(Mapper):\n    def __init__(self, mapping: Mapping, **kwargs: Any) -&gt; None:\n        \"\"\"\n        A ``HardcodedMapper`` maps each virtual qubit to a hardcoded physical qubit\n\n        Args:\n            mapping: The mapping from virtual to physical qubits\n        \"\"\"\n        super().__init__(**kwargs)\n        self._mapping = mapping\n\n    def map(self, ir: IR, qubit_register_size: int) -&gt; Mapping:\n        \"\"\"Return the hardcoded mapping.\"\"\"\n        if qubit_register_size != self._mapping.size():\n            msg = f\"qubit register size ({qubit_register_size}) and mapping size ({self._mapping.size()}) differ\"\n            raise ValueError(msg)\n        return self._mapping\n</code></pre>"},{"location":"reference/passes/mapper/simple_mappers.html#opensquirrel.passes.mapper.simple_mappers.HardcodedMapper.__init__","title":"<code>__init__(mapping, **kwargs)</code>","text":"<p>A <code>HardcodedMapper</code> maps each virtual qubit to a hardcoded physical qubit</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>Mapping</code> <p>The mapping from virtual to physical qubits</p> required Source code in <code>opensquirrel/passes/mapper/simple_mappers.py</code> <pre><code>def __init__(self, mapping: Mapping, **kwargs: Any) -&gt; None:\n    \"\"\"\n    A ``HardcodedMapper`` maps each virtual qubit to a hardcoded physical qubit\n\n    Args:\n        mapping: The mapping from virtual to physical qubits\n    \"\"\"\n    super().__init__(**kwargs)\n    self._mapping = mapping\n</code></pre>"},{"location":"reference/passes/mapper/simple_mappers.html#opensquirrel.passes.mapper.simple_mappers.HardcodedMapper.map","title":"<code>map(ir, qubit_register_size)</code>","text":"<p>Return the hardcoded mapping.</p> Source code in <code>opensquirrel/passes/mapper/simple_mappers.py</code> <pre><code>def map(self, ir: IR, qubit_register_size: int) -&gt; Mapping:\n    \"\"\"Return the hardcoded mapping.\"\"\"\n    if qubit_register_size != self._mapping.size():\n        msg = f\"qubit register size ({qubit_register_size}) and mapping size ({self._mapping.size()}) differ\"\n        raise ValueError(msg)\n    return self._mapping\n</code></pre>"},{"location":"reference/passes/mapper/simple_mappers.html#opensquirrel.passes.mapper.simple_mappers.IdentityMapper","title":"<code>IdentityMapper</code>","text":"<p>               Bases: <code>Mapper</code></p> Source code in <code>opensquirrel/passes/mapper/simple_mappers.py</code> <pre><code>class IdentityMapper(Mapper):\n    def __init__(self, **kwargs: Any) -&gt; None:\n        \"\"\"An ``IdentityMapper`` maps each virtual qubit to exactly the same physical qubit.\"\"\"\n        super().__init__(**kwargs)\n\n    def map(self, ir: IR, qubit_register_size: int) -&gt; Mapping:\n        \"\"\"Create identity mapping.\"\"\"\n        return Mapping(list(range(qubit_register_size)))\n</code></pre>"},{"location":"reference/passes/mapper/simple_mappers.html#opensquirrel.passes.mapper.simple_mappers.IdentityMapper.__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>An <code>IdentityMapper</code> maps each virtual qubit to exactly the same physical qubit.</p> Source code in <code>opensquirrel/passes/mapper/simple_mappers.py</code> <pre><code>def __init__(self, **kwargs: Any) -&gt; None:\n    \"\"\"An ``IdentityMapper`` maps each virtual qubit to exactly the same physical qubit.\"\"\"\n    super().__init__(**kwargs)\n</code></pre>"},{"location":"reference/passes/mapper/simple_mappers.html#opensquirrel.passes.mapper.simple_mappers.IdentityMapper.map","title":"<code>map(ir, qubit_register_size)</code>","text":"<p>Create identity mapping.</p> Source code in <code>opensquirrel/passes/mapper/simple_mappers.py</code> <pre><code>def map(self, ir: IR, qubit_register_size: int) -&gt; Mapping:\n    \"\"\"Create identity mapping.\"\"\"\n    return Mapping(list(range(qubit_register_size)))\n</code></pre>"},{"location":"reference/passes/mapper/simple_mappers.html#opensquirrel.passes.mapper.simple_mappers.RandomMapper","title":"<code>RandomMapper</code>","text":"<p>               Bases: <code>Mapper</code></p> Source code in <code>opensquirrel/passes/mapper/simple_mappers.py</code> <pre><code>class RandomMapper(Mapper):\n    def __init__(self, seed: int | None = None, **kwargs: Any) -&gt; None:\n        \"\"\"\n        A ``RandomMapper`` maps each virtual qubit to a random physical qubit.\n\n        Args:\n            seed: Random seed for reproducible results\n        \"\"\"\n        super().__init__(**kwargs)\n        self.seed = seed\n\n    def map(self, ir: IR, qubit_register_size: int) -&gt; Mapping:\n        \"\"\"Create a random mapping.\"\"\"\n        if self.seed:\n            random.seed(self.seed)\n\n        physical_qubit_register = list(range(qubit_register_size))\n        random.shuffle(physical_qubit_register)\n        return Mapping(physical_qubit_register)\n</code></pre>"},{"location":"reference/passes/mapper/simple_mappers.html#opensquirrel.passes.mapper.simple_mappers.RandomMapper.__init__","title":"<code>__init__(seed=None, **kwargs)</code>","text":"<p>A <code>RandomMapper</code> maps each virtual qubit to a random physical qubit.</p> <p>Parameters:</p> Name Type Description Default <code>seed</code> <code>int | None</code> <p>Random seed for reproducible results</p> <code>None</code> Source code in <code>opensquirrel/passes/mapper/simple_mappers.py</code> <pre><code>def __init__(self, seed: int | None = None, **kwargs: Any) -&gt; None:\n    \"\"\"\n    A ``RandomMapper`` maps each virtual qubit to a random physical qubit.\n\n    Args:\n        seed: Random seed for reproducible results\n    \"\"\"\n    super().__init__(**kwargs)\n    self.seed = seed\n</code></pre>"},{"location":"reference/passes/mapper/simple_mappers.html#opensquirrel.passes.mapper.simple_mappers.RandomMapper.map","title":"<code>map(ir, qubit_register_size)</code>","text":"<p>Create a random mapping.</p> Source code in <code>opensquirrel/passes/mapper/simple_mappers.py</code> <pre><code>def map(self, ir: IR, qubit_register_size: int) -&gt; Mapping:\n    \"\"\"Create a random mapping.\"\"\"\n    if self.seed:\n        random.seed(self.seed)\n\n    physical_qubit_register = list(range(qubit_register_size))\n    random.shuffle(physical_qubit_register)\n    return Mapping(physical_qubit_register)\n</code></pre>"},{"location":"reference/passes/mapper/utils.html","title":"utils","text":""},{"location":"reference/passes/merger/general_merger.html","title":"general_merger","text":""},{"location":"reference/passes/merger/general_merger.html#opensquirrel.passes.merger.general_merger.can_move_before","title":"<code>can_move_before(statement, statement_group)</code>","text":"<p>Checks whether a statement can be moved before a group of statements, following the logic below: - A barrier cannot be moved up. - A (non-barrier) statement cannot be moved before another (non-barrier) statement. - A (non-barrier) statement may be moved before a group of 'linked' barriers.</p> Source code in <code>opensquirrel/passes/merger/general_merger.py</code> <pre><code>def can_move_before(statement: Statement, statement_group: list[Statement]) -&gt; bool:\n    \"\"\"Checks whether a statement can be moved before a group of statements, following the logic below:\n    - A barrier cannot be moved up.\n    - A (non-barrier) statement cannot be moved before another (non-barrier) statement.\n    - A (non-barrier) statement may be moved before a group of 'linked' barriers.\n    \"\"\"\n    if isinstance(statement, Barrier):\n        return False\n    first_statement_from_group = statement_group[0]\n    if not isinstance(first_statement_from_group, Barrier):\n        return False\n    instruction = cast(\"Instruction\", statement)\n    return can_move_statement_before_barrier(instruction, cast(\"list[Instruction]\", statement_group))\n</code></pre>"},{"location":"reference/passes/merger/general_merger.html#opensquirrel.passes.merger.general_merger.can_move_statement_before_barrier","title":"<code>can_move_statement_before_barrier(instruction, barriers)</code>","text":"<p>Checks whether an instruction can be moved before a group of 'linked' barriers. Returns True if none of the qubits used by the instruction are part of any barrier, False otherwise.</p> Source code in <code>opensquirrel/passes/merger/general_merger.py</code> <pre><code>def can_move_statement_before_barrier(instruction: Instruction, barriers: list[Instruction]) -&gt; bool:\n    \"\"\"Checks whether an instruction can be moved before a group of 'linked' barriers.\n    Returns True if none of the qubits used by the instruction are part of any barrier, False otherwise.\n    \"\"\"\n    barriers_group_qubit_operands = set(flatten_list([list(barrier.qubit_operands) for barrier in barriers]))\n    return not any(qubit in barriers_group_qubit_operands for qubit in instruction.qubit_operands)\n</code></pre>"},{"location":"reference/passes/merger/general_merger.html#opensquirrel.passes.merger.general_merger.group_linked_barriers","title":"<code>group_linked_barriers(statements)</code>","text":"<p>Receives a list of statements. Returns a list of lists of statements, where each list of statements is either a single instruction, or a list of 'linked' barriers (consecutive barriers that cannot be split).</p> Source code in <code>opensquirrel/passes/merger/general_merger.py</code> <pre><code>def group_linked_barriers(statements: list[Statement]) -&gt; list[list[Statement]]:\n    \"\"\"Receives a list of statements.\n    Returns a list of lists of statements, where each list of statements is\n    either a single instruction, or a list of 'linked' barriers (consecutive barriers that cannot be split).\n    \"\"\"\n    ret: list[list[Statement]] = []\n    index = -1\n    adding_linked_barriers_to_group = False\n    for statement in statements:\n        if not (adding_linked_barriers_to_group and isinstance(statement, Barrier)):\n            index += 1\n            ret.append([statement])\n        else:\n            ret[-1].append(statement)\n        adding_linked_barriers_to_group = isinstance(statement, Barrier)\n    return ret\n</code></pre>"},{"location":"reference/passes/merger/general_merger.html#opensquirrel.passes.merger.general_merger.rearrange_barriers","title":"<code>rearrange_barriers(ir)</code>","text":"<p>Receives an IR. Builds an enumerated list of lists of statements, where each list of statements is either a single instruction, or a list of 'linked' barriers (consecutive barriers that cannot be split). Then sorts that enumerated list of lists so that instructions can be moved before groups of barriers. And updates the input IR with the flattened list of sorted statements.</p> Source code in <code>opensquirrel/passes/merger/general_merger.py</code> <pre><code>def rearrange_barriers(ir: IR) -&gt; None:\n    \"\"\"Receives an IR.\n    Builds an enumerated list of lists of statements, where each list of statements is\n    either a single instruction, or a list of 'linked' barriers (consecutive barriers that cannot be split).\n    Then sorts that enumerated list of lists so that instructions can be moved before groups of barriers.\n    And updates the input IR with the flattened list of sorted statements.\n    \"\"\"\n    statements_groups = group_linked_barriers(ir.statements)\n    for i, statement_group in enumerate(statements_groups):\n        statement = statement_group[0]\n        if not isinstance(statement, Barrier):\n            assert len(statement_group) == 1\n            previous_statement_groups = reversed(list(enumerate(statements_groups[:i])))\n            for j, previous_statement_group in previous_statement_groups:\n                if not can_move_before(statement, previous_statement_group):\n                    statements_groups.insert(j + 1, [statement])\n                    del statements_groups[i + 1]\n                    break\n    ir.statements = flatten_list(statements_groups)\n</code></pre>"},{"location":"reference/passes/merger/single_qubit_gates_merger.html","title":"single_qubit_gates_merger","text":""},{"location":"reference/passes/merger/single_qubit_gates_merger.html#opensquirrel.passes.merger.single_qubit_gates_merger.SingleQubitGatesMerger","title":"<code>SingleQubitGatesMerger</code>","text":"<p>               Bases: <code>Merger</code></p> Source code in <code>opensquirrel/passes/merger/single_qubit_gates_merger.py</code> <pre><code>class SingleQubitGatesMerger(Merger):\n    def merge(self, ir: IR, qubit_register_size: int) -&gt; None:\n        \"\"\"Merge all consecutive 1-qubit gates in the circuit.\n        Gates obtained from merging other gates become anonymous gates.\n\n        Args:\n            ir: Intermediate representation of the circuit.\n            qubit_register_size: Size of the qubit register\n\n        \"\"\"\n        accumulators_per_qubit: dict[Qubit, SingleQubitGate] = {\n            Qubit(qubit_index): I(qubit_index) for qubit_index in range(qubit_register_size)\n        }\n\n        statement_index = 0\n        while statement_index &lt; len(ir.statements):\n            statement = ir.statements[statement_index]\n\n            # Accumulate consecutive Bloch sphere rotations\n            instruction: Instruction = cast(\"Instruction\", statement)\n            if isinstance(instruction, SingleQubitGate):\n                already_accumulated = accumulators_per_qubit[instruction.qubit]\n                composed = already_accumulated * instruction\n                accumulators_per_qubit[instruction.qubit] = composed\n                del ir.statements[statement_index]\n                continue\n\n            def insert_accumulated_bloch_sphere_rotations(qubits: Iterable[Qubit]) -&gt; None:\n                nonlocal statement_index\n                for qubit in qubits:\n                    if not accumulators_per_qubit[qubit].is_identity():\n                        ir.statements.insert(statement_index, accumulators_per_qubit[qubit])\n                        accumulators_per_qubit[qubit] = I(qubit)\n                        statement_index += 1\n\n            # For barrier directives, insert all accumulated Bloch sphere rotations\n            # For other instructions, insert accumulated Bloch sphere rotations on qubits used by those instructions\n            # In any case, reset the dictionary entry for the inserted accumulated Bloch sphere rotations\n            if isinstance(instruction, Barrier) or isinstance(statement, AsmDeclaration):\n                insert_accumulated_bloch_sphere_rotations([Qubit(i) for i in range(qubit_register_size)])\n            else:\n                insert_accumulated_bloch_sphere_rotations(instruction.qubit_operands)\n            statement_index += 1\n\n        for accumulated_bloch_sphere_rotation in accumulators_per_qubit.values():\n            if not accumulated_bloch_sphere_rotation.is_identity():\n                ir.statements.append(accumulated_bloch_sphere_rotation)\n</code></pre>"},{"location":"reference/passes/merger/single_qubit_gates_merger.html#opensquirrel.passes.merger.single_qubit_gates_merger.SingleQubitGatesMerger.merge","title":"<code>merge(ir, qubit_register_size)</code>","text":"<p>Merge all consecutive 1-qubit gates in the circuit. Gates obtained from merging other gates become anonymous gates.</p> <p>Parameters:</p> Name Type Description Default <code>ir</code> <code>IR</code> <p>Intermediate representation of the circuit.</p> required <code>qubit_register_size</code> <code>int</code> <p>Size of the qubit register</p> required Source code in <code>opensquirrel/passes/merger/single_qubit_gates_merger.py</code> <pre><code>def merge(self, ir: IR, qubit_register_size: int) -&gt; None:\n    \"\"\"Merge all consecutive 1-qubit gates in the circuit.\n    Gates obtained from merging other gates become anonymous gates.\n\n    Args:\n        ir: Intermediate representation of the circuit.\n        qubit_register_size: Size of the qubit register\n\n    \"\"\"\n    accumulators_per_qubit: dict[Qubit, SingleQubitGate] = {\n        Qubit(qubit_index): I(qubit_index) for qubit_index in range(qubit_register_size)\n    }\n\n    statement_index = 0\n    while statement_index &lt; len(ir.statements):\n        statement = ir.statements[statement_index]\n\n        # Accumulate consecutive Bloch sphere rotations\n        instruction: Instruction = cast(\"Instruction\", statement)\n        if isinstance(instruction, SingleQubitGate):\n            already_accumulated = accumulators_per_qubit[instruction.qubit]\n            composed = already_accumulated * instruction\n            accumulators_per_qubit[instruction.qubit] = composed\n            del ir.statements[statement_index]\n            continue\n\n        def insert_accumulated_bloch_sphere_rotations(qubits: Iterable[Qubit]) -&gt; None:\n            nonlocal statement_index\n            for qubit in qubits:\n                if not accumulators_per_qubit[qubit].is_identity():\n                    ir.statements.insert(statement_index, accumulators_per_qubit[qubit])\n                    accumulators_per_qubit[qubit] = I(qubit)\n                    statement_index += 1\n\n        # For barrier directives, insert all accumulated Bloch sphere rotations\n        # For other instructions, insert accumulated Bloch sphere rotations on qubits used by those instructions\n        # In any case, reset the dictionary entry for the inserted accumulated Bloch sphere rotations\n        if isinstance(instruction, Barrier) or isinstance(statement, AsmDeclaration):\n            insert_accumulated_bloch_sphere_rotations([Qubit(i) for i in range(qubit_register_size)])\n        else:\n            insert_accumulated_bloch_sphere_rotations(instruction.qubit_operands)\n        statement_index += 1\n\n    for accumulated_bloch_sphere_rotation in accumulators_per_qubit.values():\n        if not accumulated_bloch_sphere_rotation.is_identity():\n            ir.statements.append(accumulated_bloch_sphere_rotation)\n</code></pre>"},{"location":"reference/passes/router/astar_router.html","title":"astar_router","text":""},{"location":"reference/passes/router/common.html","title":"common","text":""},{"location":"reference/passes/router/common.html#opensquirrel.passes.router.common.ProcessSwaps","title":"<code>ProcessSwaps</code>","text":"Source code in <code>opensquirrel/passes/router/common.py</code> <pre><code>class ProcessSwaps:\n    @staticmethod\n    def process_swaps(\n        ir: IR,\n        qubit_register_size: int,\n        connectivity: Connectivity,\n        pathfinder: PathFinderType,\n    ) -&gt; IR:\n        \"\"\"Processes SWAPs as determined by the pathfinder algorithm.\n\n        Args:\n            ir (IR): The IR of the circuit.\n            qubit_register_size (int): The size of the qubit register.\n            connectivity (dict[str, list[int]]): Connectivity mapping of physical qubits.\n            pathfinder (PathFinderType): The pathfinder algorithm.\n        Returns:\n            IR: IR with the SWAPs processed through.\n\n        \"\"\"\n        graph = get_graph(connectivity)\n        initial_mapping = get_identity_mapping(qubit_register_size)\n        planned_swaps = ProcessSwaps._plan_swaps(ir, graph, initial_mapping, pathfinder)\n        ir.statements = ProcessSwaps._apply_swaps(ir, planned_swaps, initial_mapping)\n        return ir\n\n    @staticmethod\n    def _plan_swaps(\n        ir: IR,\n        graph: nx.Graph,\n        initial_mapping: dict[int, int],\n        pathfinder: PathFinderType,\n    ) -&gt; dict[int, SWAP]:\n        \"\"\"Traverses the IR and determines where SWAPs need to be placed.\n\n        Args:\n            ir (IR): The IR of the circuit.\n            graph (nx.Graph): The NetworkX graph representation of the qubit connectivity.\n            initial_mapping (dict[int, int]): The initial mapping of the qubits.\n            pathfinder (Callable[[nx.Graph, int, int], list[int]]):\n        Returns:\n            dict[int, SWAP]: An mapping from the insert position to SWAP instruction.\n\n        \"\"\"\n        planned_swaps: dict[int, SWAP] = {}\n        temp_mapping = initial_mapping.copy()\n\n        for statement_index, statement in enumerate(ir.statements):\n            if isinstance(statement, TwoQubitGate):\n                q0, q1 = statement.qubit_operands\n                physical_q0_index = temp_mapping[q0.index]\n                physical_q1_index = temp_mapping[q1.index]\n\n                if not graph.has_edge(physical_q0_index, physical_q1_index):\n                    try:\n                        path = pathfinder(graph, physical_q0_index, physical_q1_index)\n                    except nx.NetworkXNoPath as e:\n                        msg = f\"No routing path available between qubit {q0.index} and qubit {q1.index}\"\n                        raise NoRoutingPathError(msg) from e\n\n                    base_offset = len(planned_swaps)\n\n                    # Final edge of the path is skipped as those qubits are already neighbors.\n                    swaps_for_path = itertools.pairwise(path[:-1])\n                    for swap_count, swap_pair in enumerate(swaps_for_path):\n                        insert_position = statement_index + base_offset + swap_count\n                        planned_swaps[insert_position] = SWAP(*swap_pair)\n                        ProcessSwaps._update_mapping_for_swap(temp_mapping, swap_pair)\n        return planned_swaps\n\n    @staticmethod\n    def _apply_swaps(ir: IR, planned_swaps: dict[int, SWAP], initial_mapping: dict[int, int]) -&gt; list[Statement]:\n        \"\"\"Insert planned SWAPs and update qubit indices.\n\n        Args:\n            ir (IR): The IR of the circuit.\n            planned_swaps (dict[int, SWAP]): The mapping from the insert position to SWAP instruction.\n            initial_mapping (dict[int, int]): The initial mapping of the qubits.\n        Returns:\n            list[Statement]: An updated list of IR Statements.\n\n        \"\"\"\n        new_ir_statements: list[Statement] = []\n        new_mapping = initial_mapping.copy()\n\n        for statement in ir.statements:\n            while len(new_ir_statements) in planned_swaps:\n                swap_gate = planned_swaps[len(new_ir_statements)]\n                ProcessSwaps._update_mapping_for_swap(new_mapping, swap_gate.qubit_indices)\n                new_ir_statements.append(swap_gate)\n\n            if isinstance(statement, Instruction):\n                for qubit in statement.qubit_operands:\n                    qubit.index = new_mapping[qubit.index]\n\n            new_ir_statements.append(statement)\n        return new_ir_statements\n\n    @staticmethod\n    def _update_mapping_for_swap(mapping: dict[int, int], swap_qubit_indices: Iterable[int]) -&gt; None:\n        \"\"\"Updates the mapping for the given swap qubit indices.\n\n        Args:\n            mapping (dict[int, int]): The mapping of the qubit indices (logical qubit index: physical qubit index).\n            swap_qubit_indices (tuple[int, int]): The swap qubit indices.\n\n        \"\"\"\n        index_q0, index_q1 = swap_qubit_indices\n        reverse_mapping = {value: key for key, value in mapping.items()}\n        logical_index_q0, logical_index_q1 = reverse_mapping.get(index_q0), reverse_mapping.get(index_q1)\n        if logical_index_q0 is not None:\n            mapping[logical_index_q0] = index_q1\n        if logical_index_q1 is not None:\n            mapping[logical_index_q1] = index_q0\n</code></pre>"},{"location":"reference/passes/router/common.html#opensquirrel.passes.router.common.ProcessSwaps.process_swaps","title":"<code>process_swaps(ir, qubit_register_size, connectivity, pathfinder)</code>  <code>staticmethod</code>","text":"<p>Processes SWAPs as determined by the pathfinder algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>ir</code> <code>IR</code> <p>The IR of the circuit.</p> required <code>qubit_register_size</code> <code>int</code> <p>The size of the qubit register.</p> required <code>connectivity</code> <code>dict[str, list[int]]</code> <p>Connectivity mapping of physical qubits.</p> required <code>pathfinder</code> <code>PathFinderType</code> <p>The pathfinder algorithm.</p> required <p>Returns:     IR: IR with the SWAPs processed through.</p> Source code in <code>opensquirrel/passes/router/common.py</code> <pre><code>@staticmethod\ndef process_swaps(\n    ir: IR,\n    qubit_register_size: int,\n    connectivity: Connectivity,\n    pathfinder: PathFinderType,\n) -&gt; IR:\n    \"\"\"Processes SWAPs as determined by the pathfinder algorithm.\n\n    Args:\n        ir (IR): The IR of the circuit.\n        qubit_register_size (int): The size of the qubit register.\n        connectivity (dict[str, list[int]]): Connectivity mapping of physical qubits.\n        pathfinder (PathFinderType): The pathfinder algorithm.\n    Returns:\n        IR: IR with the SWAPs processed through.\n\n    \"\"\"\n    graph = get_graph(connectivity)\n    initial_mapping = get_identity_mapping(qubit_register_size)\n    planned_swaps = ProcessSwaps._plan_swaps(ir, graph, initial_mapping, pathfinder)\n    ir.statements = ProcessSwaps._apply_swaps(ir, planned_swaps, initial_mapping)\n    return ir\n</code></pre>"},{"location":"reference/passes/router/common.html#opensquirrel.passes.router.common.get_graph","title":"<code>get_graph(connectivity)</code>","text":"<p>Creates a networkx graph from the given connectivity.</p> <p>Parameters:</p> Name Type Description Default <code>connectivity</code> <code>dict[str, list[int]]</code> <p>Connectivity mapping of physical qubits.</p> required <p>Returns:</p> Type Description <code>Graph</code> <p>nx.Graph: Networkx graph from the given connectivity.</p> Source code in <code>opensquirrel/passes/router/common.py</code> <pre><code>def get_graph(connectivity: Connectivity) -&gt; nx.Graph:\n    \"\"\"Creates a networkx graph from the given connectivity.\n\n    Args:\n        connectivity (dict[str, list[int]]): Connectivity mapping of physical qubits.\n\n    Returns:\n        nx.Graph: Networkx graph from the given connectivity.\n\n    \"\"\"\n    return nx.Graph({int(start): ends for start, ends in connectivity.items()})\n</code></pre>"},{"location":"reference/passes/router/common.html#opensquirrel.passes.router.common.get_identity_mapping","title":"<code>get_identity_mapping(qubit_register_size)</code>","text":"<p>Creates an identity mapping.</p> <p>Parameters:</p> Name Type Description Default <code>qubit_register_size</code> <code>int</code> <p>The size of the qubit register.</p> required <p>Returns:</p> Type Description <code>dict[int, int]</code> <p>dict[int, int]: An identity mapping.</p> Source code in <code>opensquirrel/passes/router/common.py</code> <pre><code>def get_identity_mapping(qubit_register_size: int) -&gt; dict[int, int]:\n    \"\"\"Creates an identity mapping.\n\n    Args:\n        qubit_register_size (int): The size of the qubit register.\n\n    Returns:\n        dict[int, int]: An identity mapping.\n\n    \"\"\"\n    return {qubit_index: qubit_index for qubit_index in range(qubit_register_size)}\n</code></pre>"},{"location":"reference/passes/router/general_router.html","title":"general_router","text":""},{"location":"reference/passes/router/general_router.html#opensquirrel.passes.router.general_router.Router","title":"<code>Router</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>opensquirrel/passes/router/general_router.py</code> <pre><code>class Router(ABC):\n    def __init__(self, connectivity: Connectivity, **kwargs: Any) -&gt; None:\n        self._connectivity = connectivity\n        \"\"\"Generic router class\"\"\"\n\n    @abstractmethod\n    def route(self, ir: IR, qubit_register_size: int) -&gt; IR:\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/passes/router/heuristics.html","title":"heuristics","text":""},{"location":"reference/passes/router/heuristics.html#opensquirrel.passes.router.heuristics.calculate_distance","title":"<code>calculate_distance(q0_index, q1_index, num_columns, distance_metric)</code>","text":"<p>Calculate the distance between two qubits based on the specified distance metric. Args:     q0_index (int): The index of the first qubit.     q1_index (int): The index of the second qubit.     num_columns (int): The number of columns in the grid.     distance_metric (DistanceMetric): Distance metric to be used (Manhattan, Euclidean, or Chebyshev). Returns:     float: The distance between the two qubits.</p> Source code in <code>opensquirrel/passes/router/heuristics.py</code> <pre><code>def calculate_distance(q0_index: int, q1_index: int, num_columns: int, distance_metric: DistanceMetric) -&gt; float:\n    \"\"\"\n    Calculate the distance between two qubits based on the specified distance metric.\n    Args:\n        q0_index (int): The index of the first qubit.\n        q1_index (int): The index of the second qubit.\n        num_columns (int): The number of columns in the grid.\n        distance_metric (DistanceMetric): Distance metric to be used (Manhattan, Euclidean, or Chebyshev).\n    Returns:\n        float: The distance between the two qubits.\n    \"\"\"\n    x1, y1 = divmod(q0_index, num_columns)\n    x2, y2 = divmod(q1_index, num_columns)\n\n    match distance_metric:\n        case DistanceMetric.MANHATTAN:\n            return abs(x1 - x2) + abs(y1 - y2)\n\n        case DistanceMetric.EUCLIDEAN:\n            return float(((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5)\n\n        case DistanceMetric.CHEBYSHEV:\n            return max(abs(x1 - x2), abs(y1 - y2))\n\n        case _:\n            msg = \"Invalid distance metric. Choose Manhattan, Euclidean, or Chebyshev.\"\n            raise ValueError(msg)\n</code></pre>"},{"location":"reference/passes/router/shortest_path_router.html","title":"shortest_path_router","text":""},{"location":"reference/passes/validator/general_validator.html","title":"general_validator","text":""},{"location":"reference/passes/validator/general_validator.html#opensquirrel.passes.validator.general_validator.Validator","title":"<code>Validator</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>opensquirrel/passes/validator/general_validator.py</code> <pre><code>class Validator(ABC):\n    def __init__(self, **kwargs: Any) -&gt; None: ...\n\n    @abstractmethod\n    def validate(self, ir: IR) -&gt; None:\n        \"\"\"Base validate method to be implemented by inheriting validator classes.\"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/passes/validator/general_validator.html#opensquirrel.passes.validator.general_validator.Validator.validate","title":"<code>validate(ir)</code>  <code>abstractmethod</code>","text":"<p>Base validate method to be implemented by inheriting validator classes.</p> Source code in <code>opensquirrel/passes/validator/general_validator.py</code> <pre><code>@abstractmethod\ndef validate(self, ir: IR) -&gt; None:\n    \"\"\"Base validate method to be implemented by inheriting validator classes.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/passes/validator/interaction_validator.html","title":"interaction_validator","text":""},{"location":"reference/passes/validator/interaction_validator.html#opensquirrel.passes.validator.interaction_validator.InteractionValidator","title":"<code>InteractionValidator</code>","text":"<p>               Bases: <code>Validator</code></p> Source code in <code>opensquirrel/passes/validator/interaction_validator.py</code> <pre><code>class InteractionValidator(Validator):\n    def __init__(self, connectivity: dict[str, list[int]], **kwargs: Any) -&gt; None:\n        super().__init__(**kwargs)\n        self.connectivity = connectivity\n\n    def validate(self, ir: IR) -&gt; None:\n        \"\"\"\n        Check if the circuit interactions faciliate a 1-to-1 mapping to the target hardware.\n\n        Args:\n            ir (IR): The intermediate representation of the circuit to be checked.\n\n        Raises:\n            ValueError: If the circuit can't be mapped to the target hardware.\n        \"\"\"\n        non_executable_interactions = []\n        for statement in ir.statements:\n            if not isinstance(statement, TwoQubitGate):\n                continue\n            qubit_index_pairs = itertools.pairwise(statement.qubit_indices)\n            for i, j in qubit_index_pairs:\n                if j not in self.connectivity.get(str(i), []):\n                    non_executable_interactions.append((i, j))\n\n        if non_executable_interactions:\n            error_message = (\n                f\"the following qubit interactions in the circuit prevent a 1-to-1 mapping:\"\n                f\"{set(non_executable_interactions)}\"\n            )\n            raise ValueError(error_message)\n</code></pre>"},{"location":"reference/passes/validator/interaction_validator.html#opensquirrel.passes.validator.interaction_validator.InteractionValidator.validate","title":"<code>validate(ir)</code>","text":"<p>Check if the circuit interactions faciliate a 1-to-1 mapping to the target hardware.</p> <p>Parameters:</p> Name Type Description Default <code>ir</code> <code>IR</code> <p>The intermediate representation of the circuit to be checked.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the circuit can't be mapped to the target hardware.</p> Source code in <code>opensquirrel/passes/validator/interaction_validator.py</code> <pre><code>def validate(self, ir: IR) -&gt; None:\n    \"\"\"\n    Check if the circuit interactions faciliate a 1-to-1 mapping to the target hardware.\n\n    Args:\n        ir (IR): The intermediate representation of the circuit to be checked.\n\n    Raises:\n        ValueError: If the circuit can't be mapped to the target hardware.\n    \"\"\"\n    non_executable_interactions = []\n    for statement in ir.statements:\n        if not isinstance(statement, TwoQubitGate):\n            continue\n        qubit_index_pairs = itertools.pairwise(statement.qubit_indices)\n        for i, j in qubit_index_pairs:\n            if j not in self.connectivity.get(str(i), []):\n                non_executable_interactions.append((i, j))\n\n    if non_executable_interactions:\n        error_message = (\n            f\"the following qubit interactions in the circuit prevent a 1-to-1 mapping:\"\n            f\"{set(non_executable_interactions)}\"\n        )\n        raise ValueError(error_message)\n</code></pre>"},{"location":"reference/passes/validator/primitive_gate_validator.html","title":"primitive_gate_validator","text":""},{"location":"reference/passes/validator/primitive_gate_validator.html#opensquirrel.passes.validator.primitive_gate_validator.PrimitiveGateValidator","title":"<code>PrimitiveGateValidator</code>","text":"<p>               Bases: <code>Validator</code></p> Source code in <code>opensquirrel/passes/validator/primitive_gate_validator.py</code> <pre><code>class PrimitiveGateValidator(Validator):\n    def __init__(self, primitive_gate_set: list[str], **kwargs: Any) -&gt; None:\n        super().__init__(**kwargs)\n        self.primitive_gate_set = primitive_gate_set\n\n    def validate(self, ir: IR) -&gt; None:\n        \"\"\"\n        Check if all unitary gates in the circuit are part of the primitive gate set.\n\n        Args:\n            ir (IR): The intermediate representation of the circuit to be checked.\n\n        Raises:\n            ValueError: If any unitary gate in the circuit is not part of the primitive gate set.\n        \"\"\"\n        gates_not_in_primitive_gate_set = [\n            statement.name\n            for statement in ir.statements\n            if isinstance(statement, Instruction) and statement.name not in self.primitive_gate_set\n        ]\n        if gates_not_in_primitive_gate_set:\n            unsupported_gates = list(set(gates_not_in_primitive_gate_set))\n            error_message = \"the following gates are not in the primitive gate set: \" + \", \".join(unsupported_gates)\n            raise ValueError(error_message)\n</code></pre>"},{"location":"reference/passes/validator/primitive_gate_validator.html#opensquirrel.passes.validator.primitive_gate_validator.PrimitiveGateValidator.validate","title":"<code>validate(ir)</code>","text":"<p>Check if all unitary gates in the circuit are part of the primitive gate set.</p> <p>Parameters:</p> Name Type Description Default <code>ir</code> <code>IR</code> <p>The intermediate representation of the circuit to be checked.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If any unitary gate in the circuit is not part of the primitive gate set.</p> Source code in <code>opensquirrel/passes/validator/primitive_gate_validator.py</code> <pre><code>def validate(self, ir: IR) -&gt; None:\n    \"\"\"\n    Check if all unitary gates in the circuit are part of the primitive gate set.\n\n    Args:\n        ir (IR): The intermediate representation of the circuit to be checked.\n\n    Raises:\n        ValueError: If any unitary gate in the circuit is not part of the primitive gate set.\n    \"\"\"\n    gates_not_in_primitive_gate_set = [\n        statement.name\n        for statement in ir.statements\n        if isinstance(statement, Instruction) and statement.name not in self.primitive_gate_set\n    ]\n    if gates_not_in_primitive_gate_set:\n        unsupported_gates = list(set(gates_not_in_primitive_gate_set))\n        error_message = \"the following gates are not in the primitive gate set: \" + \", \".join(unsupported_gates)\n        raise ValueError(error_message)\n</code></pre>"},{"location":"reference/reader/libqasm_parser.html","title":"libqasm_parser","text":""},{"location":"reference/reader/libqasm_parser.html#opensquirrel.reader.libqasm_parser.LibQasmParser","title":"<code>LibQasmParser</code>","text":"Source code in <code>opensquirrel/reader/libqasm_parser.py</code> <pre><code>class LibQasmParser:\n    def __init__(self) -&gt; None:\n        self.ir = IR()\n\n    @staticmethod\n    def _ast_literal_to_ir_literal(\n        ast_literal: cqasm.values.ConstInt | cqasm.values.ConstFloat | None,\n    ) -&gt; Int | Float | None:\n        if type(ast_literal) not in [cqasm.values.ConstInt, cqasm.values.ConstFloat, type(None)]:\n            msg = f\"unrecognized type: {type(ast_literal)}\"\n            raise TypeError(msg)\n        if isinstance(ast_literal, cqasm.values.ConstInt):\n            return Int(ast_literal.value)\n        if isinstance(ast_literal, cqasm.values.ConstFloat):\n            return Float(ast_literal.value)\n        return None\n\n    @staticmethod\n    def _type_of(ast_expression: Any) -&gt; type:\n        if isinstance(ast_expression, cqasm.semantic.Variable):\n            return type(ast_expression.typ)\n        if isinstance(ast_expression, (cqasm.values.IndexRef, cqasm.values.VariableRef)):\n            return type(ast_expression.variable.typ)\n        return type(ast_expression)\n\n    @staticmethod\n    def _size_of(ast_expression: Any) -&gt; int:\n        if isinstance(ast_expression, cqasm.values.IndexRef):\n            return len(ast_expression.indices)\n        if isinstance(ast_expression, cqasm.values.VariableRef):\n            return int(ast_expression.variable.typ.size)\n        return 1\n\n    @staticmethod\n    def _is_qubit_type(ast_expression: Any) -&gt; bool:\n        ast_type = LibQasmParser._type_of(ast_expression)\n        return bool(ast_type == cqasm.types.Qubit or ast_type == cqasm.types.QubitArray)\n\n    @staticmethod\n    def _is_bit_type(ast_expression: Any) -&gt; bool:\n        ast_type = LibQasmParser._type_of(ast_expression)\n        return bool(ast_type == cqasm.types.Bit or ast_type == cqasm.types.BitArray)\n\n    @staticmethod\n    def _is_gate_instruction(ast_node: Any) -&gt; bool:\n        return isinstance(ast_node, cqasm.semantic.GateInstruction)\n\n    @staticmethod\n    def _is_non_gate_instruction(ast_node: Any) -&gt; bool:\n        return isinstance(ast_node, cqasm.semantic.NonGateInstruction)\n\n    @staticmethod\n    def _is_asm_declaration(ast_node: Any) -&gt; bool:\n        return isinstance(ast_node, cqasm.semantic.AsmDeclaration)\n\n    def _get_qubits(self, ast_qubit_expression: cqasm.values.VariableRef | cqasm.values.IndexRef) -&gt; list[Qubit]:\n        ret = []\n        qubit_register = self.register_manager.get_qubit_register(ast_qubit_expression.variable.name)\n        if isinstance(ast_qubit_expression, cqasm.values.VariableRef):\n            index_first = qubit_register.virtual_zero_index\n            index_last = index_first + qubit_register.size\n            ret = [Qubit(index) for index in range(index_first, index_last)]\n        if isinstance(ast_qubit_expression, cqasm.values.IndexRef):\n            int_indices = [int(i.value) for i in ast_qubit_expression.indices]\n            indices = [qubit_register.virtual_zero_index + i for i in int_indices]\n            ret = [Qubit(index) for index in indices]\n        return ret\n\n    def _get_bits(self, ast_bit_expression: cqasm.values.VariableRef | cqasm.values.IndexRef) -&gt; list[Bit]:\n        ret = []\n        bit_register = self.register_manager.get_bit_register(ast_bit_expression.variable.name)\n        if isinstance(ast_bit_expression, cqasm.values.VariableRef):\n            index_first = bit_register.virtual_zero_index\n            index_last = index_first + bit_register.size\n            ret = [Bit(index) for index in range(index_first, index_last)]\n        if isinstance(ast_bit_expression, cqasm.values.IndexRef):\n            int_indices = [int(i.value) for i in ast_bit_expression.indices]\n            indices = [bit_register.virtual_zero_index + i for i in int_indices]\n            ret = [Bit(index) for index in indices]\n        return ret\n\n    def _get_instruction_operands(self, instruction: cqasm.semantic.Instruction) -&gt; list[list[Any]]:\n        \"\"\"Get the list of lists of operands of an instruction.\n        Notice that an instruction just has a list of operands. The outer list is needed to support SGMQ.\n        For example, for CNOT q[0, 1] q[2, 3], this function returns [[Qubit(0), Qubit(1)], [Qubit(2), Qubit(3)]].\n        \"\"\"\n        ret: list[list[Any]] = []\n        for operand in instruction.operands:\n            if self._is_qubit_type(operand):\n                ret.append(self._get_qubits(operand))\n            else:\n                msg = \"argument is not of qubit type\"\n                raise TypeError(msg)\n        return ret\n\n    @classmethod\n    def _get_named_gate_parameters(cls, gate: cqasm.semantic.Gate) -&gt; Any:\n        \"\"\"Get the parameters of a named gate.\n        Notice the input gate can be a composition of gate modifiers acting on a named gate.\n        \"\"\"\n        if gate.name in [\"inv\", \"pow\", \"ctrl\"]:\n            return cls._get_named_gate_parameters(gate.gate)\n        return [cls._ast_literal_to_ir_literal(parameter) for parameter in gate.parameters]\n\n    def _get_expanded_instruction_args(self, instruction: cqasm.semantic.Instruction) -&gt; list[tuple[Any, ...]]:\n        \"\"\"Construct a list with a list of qubits and a list of parameters, then return a zip of both lists.\n        For example, for CRk(2) q[0, 1] q[2, 3], this function:\n        1. constructs the list with a list of qubits [[Qubit(0), Qubit(1)], [Qubit(2), Qubit(3)]],\n        2. appends the list of parameters [[Int(2)], [Int(2)]],\n        3. zips the whole list and returns [(Qubit(0), Qubit(2), Int(2)), (Qubit(1), Qubit(3), Int(2))]\n        \"\"\"\n        extended_operands = self._get_instruction_operands(instruction)\n        if isinstance(instruction, cqasm.semantic.GateInstruction):\n            gate_parameters = self._get_named_gate_parameters(instruction.gate)\n        else:\n            gate_parameters = [self._ast_literal_to_ir_literal(parameter) for parameter in instruction.parameters]\n        if gate_parameters:\n            number_of_operands = len(extended_operands[0])\n            extended_gate_parameters = [gate_parameters] * number_of_operands\n            return [\n                (*operands, *parameters)\n                for operands, parameters in zip(\n                    zip(*extended_operands, strict=False), extended_gate_parameters, strict=False\n                )\n            ]\n        return list(zip(*extended_operands, strict=False))\n\n    def _get_expanded_measure_args(self, ast_args: Any) -&gt; list[tuple[Any, ...]]:\n        \"\"\"Construct a list with a list of bits and a list of qubits, then return a zip of both lists.\n        For example: [(Qubit(0), Bit(0)), (Qubit(1), Bit(1))]\n        \"\"\"\n        # Notice the list is walked in reverse mode\n        # This is because the AST measure node has a bit first operand and a qubit second operand\n        expanded_args: list[list[Any]] = []\n        for ast_arg in reversed(ast_args):\n            if self._is_qubit_type(ast_arg):\n                expanded_args.append(self._get_qubits(ast_arg))\n            elif self._is_bit_type(ast_arg):\n                expanded_args.append(self._get_bits(ast_arg))\n            else:\n                msg = \"argument is neither of qubit nor bit type\"\n                raise TypeError(msg)\n        return list(zip(*expanded_args, strict=False))\n\n    @staticmethod\n    def _create_analyzer() -&gt; cqasm.Analyzer:\n        without_defaults = False\n        return cqasm.Analyzer(\"3.0\", without_defaults)\n\n    @staticmethod\n    def _check_analysis_result(result: Any) -&gt; None:\n        if isinstance(result, list):\n            raise OSError(\"parsing error: \" + \", \".join(result))\n\n    def _get_gate_generator(self, instruction: cqasm.semantic.GateInstruction) -&gt; Callable[..., Gate]:\n        gate_name = instruction.gate.name\n        if gate_name in [\"inv\", \"pow\", \"ctrl\"]:\n            modified_gate_generator = cast(\"Callable[..., SingleQubitGate]\", self._get_gate_generator(instruction.gate))\n\n            match gate_name:\n                case \"inv\":\n                    return InverseGateModifier(modified_gate_generator)\n\n                case \"pow\":\n                    gate = instruction.gate\n                    exponent = gate.parameters[0].value\n                    return PowerGateModifier(exponent, modified_gate_generator)\n\n                case \"ctrl\":\n                    return ControlGateModifier(modified_gate_generator)\n\n                case _:\n                    msg = \"parsing error: unknown unitary instruction\"\n                    raise OSError(msg)\n        return lambda *args: default_gate_set[gate_name](*args)\n\n    def _get_non_gate_instruction_generator(\n        self, instruction: cqasm.semantic.NonGateInstruction\n    ) -&gt; Callable[..., NonUnitary | ControlInstruction]:\n        if instruction.name in default_control_instruction_set:\n            return lambda *args: default_control_instruction_set[instruction.name](*args)\n        return lambda *args: default_non_unitary_set[instruction.name](*args)\n\n    @staticmethod\n    def _get_registry(\n        ast: Any,\n        register_cls: type[QubitRegister | BitRegister],\n        type_check: Callable[[Any], bool],\n    ) -&gt; Registry:\n        registry = OrderedDict()\n        for variable in filter(type_check, ast.variables):\n            registry[variable.name] = register_cls(variable.typ.size, variable.name)\n        return registry\n\n    def _create_register_manager(self, ast: Any) -&gt; RegisterManager:\n        qubit_registry = self._get_registry(ast, QubitRegister, LibQasmParser._is_qubit_type)\n        bit_registry = self._get_registry(ast, BitRegister, LibQasmParser._is_bit_type)\n        return RegisterManager(qubit_registry, bit_registry)\n\n    def circuit_from_string(self, s: str) -&gt; Circuit:\n        # Analysis result will be either an Abstract Syntax Tree (AST) or a list of error messages\n        analyzer = LibQasmParser._create_analyzer()\n        analysis_result = analyzer.analyze_string(s)\n        LibQasmParser._check_analysis_result(analysis_result)\n        ast = analysis_result\n\n        # Create RegisterManager\n        self.register_manager = self._create_register_manager(ast)\n\n        if not self.register_manager:\n            msg = \"parsing error: no registers found\"\n            raise OSError(msg)\n\n        # Parse statements\n        expanded_args: list[tuple[Any, ...]] = []\n        for statement in ast.block.statements:\n            instruction_generator: Callable[..., Statement]\n            if LibQasmParser._is_gate_instruction(statement):\n                instruction_generator = self._get_gate_generator(statement)\n                expanded_args = self._get_expanded_instruction_args(statement)\n            elif LibQasmParser._is_non_gate_instruction(statement):\n                instruction_generator = self._get_non_gate_instruction_generator(statement)\n                expanded_args = (\n                    self._get_expanded_measure_args(statement.operands)\n                    if statement.name == \"measure\"\n                    else self._get_expanded_instruction_args(statement)\n                )\n            elif LibQasmParser._is_asm_declaration(statement):\n                asm_declaration = AsmDeclaration(statement.backend_name, statement.backend_code)\n                self.ir.add_statement(asm_declaration)\n            else:\n                msg = \"parsing error: unknown statement\"\n                raise OSError(msg)\n\n            # For an SGMQ instruction:\n            # expanded_args will contain a list with the list of qubits for each individual instruction,\n            # while args will contain the list of qubits of an individual instruction\n            if expanded_args:\n                for args in expanded_args:\n                    self.ir.add_statement(instruction_generator(*args))\n                expanded_args = []\n        return Circuit(self.register_manager, self.ir)\n</code></pre>"},{"location":"reference/reindexer/qubit_reindexer.html","title":"qubit_reindexer","text":""},{"location":"reference/utils/context.html","title":"context","text":""},{"location":"reference/utils/context.html#opensquirrel.utils.context.temporary_class_attr","title":"<code>temporary_class_attr(cls, attr, value)</code>","text":"<p>Context method to temporarily assign a value to a class attribute.</p> <p>The assigned value will only be held within the context.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type[Any]</code> <p>Class of which the class attribute value is to be assigned.</p> required <code>attr</code> <code>str</code> <p>Name of class attribute.</p> required <code>value</code> <code>Any</code> <p>Value to assign to class attribute (must be correct type).</p> required Source code in <code>opensquirrel/utils/context.py</code> <pre><code>@contextmanager\ndef temporary_class_attr(cls: type[Any], attr: str, value: Any) -&gt; Generator[None, None, None]:\n    \"\"\"Context method to temporarily assign a value to a class attribute.\n\n    The assigned value will only be held within the context.\n\n    Args:\n        cls: Class of which the class attribute value is to be assigned.\n        attr: Name of class attribute.\n        value: Value to assign to class attribute (must be correct type).\n    \"\"\"\n    original_value = getattr(cls, attr)\n    setattr(cls, attr, value)\n    try:\n        yield\n    finally:\n        setattr(cls, attr, original_value)\n</code></pre>"},{"location":"reference/utils/general_math.html","title":"general_math","text":""},{"location":"reference/utils/general_math.html#opensquirrel.utils.general_math.acos","title":"<code>acos(value)</code>","text":"<p>Fix float approximations like 1.0000000000002, which acos does not like.</p> Source code in <code>opensquirrel/utils/general_math.py</code> <pre><code>def acos(value: float) -&gt; float:\n    \"\"\"Fix float approximations like 1.0000000000002, which acos does not like.\"\"\"\n    value = max(min(value, 1.0), -1.0)\n    return math.acos(value)\n</code></pre>"},{"location":"reference/utils/general_math.html#opensquirrel.utils.general_math.are_axes_consecutive","title":"<code>are_axes_consecutive(axis_a_index, axis_b_index)</code>","text":"<p>Check if axis 'a' immediately precedes axis 'b' (in a circular fashion [x, y, z, x...]).</p> Source code in <code>opensquirrel/utils/general_math.py</code> <pre><code>def are_axes_consecutive(axis_a_index: int, axis_b_index: int) -&gt; bool:\n    \"\"\"Check if axis 'a' immediately precedes axis 'b' (in a circular fashion [x, y, z, x...]).\"\"\"\n    return axis_a_index - axis_b_index in (-1, 2)\n</code></pre>"},{"location":"reference/utils/general_math.html#opensquirrel.utils.general_math.matrix_from_u_gate_params","title":"<code>matrix_from_u_gate_params(theta, phi, lmbda)</code>","text":"<p>Convert the U-gate to a matrix using its parameters.</p> Source code in <code>opensquirrel/utils/general_math.py</code> <pre><code>def matrix_from_u_gate_params(theta: float, phi: float, lmbda: float) -&gt; NDArray[np.complex128]:\n    \"\"\"Convert the U-gate to a matrix using its parameters.\"\"\"\n    return np.array(\n        [\n            [math.cos(theta / 2), -cmath.exp(1j * lmbda) * math.sin(theta / 2)],\n            [cmath.exp(1j * phi) * math.sin(theta / 2), cmath.exp(1j * (phi + lmbda)) * math.cos(theta / 2)],\n        ],\n        dtype=np.complex128,\n    )\n</code></pre>"},{"location":"reference/utils/identity_filter.html","title":"identity_filter","text":""},{"location":"reference/utils/list.html","title":"list","text":""},{"location":"reference/utils/matrix_expander.html","title":"matrix_expander","text":""},{"location":"reference/utils/matrix_expander.html#opensquirrel.utils.matrix_expander.expand_ket","title":"<code>expand_ket(base_ket, reduced_ket, qubits)</code>","text":"<p>Given a base quantum ket on n qubits and a reduced ket on a subset of those qubits, this computes the expanded ket where the reduction qubits and the other qubits are set based on the reduced ket and the base ket, respectively. Roughly equivalent to the <code>pdep</code> assembly instruction (bits deposit).</p> <p>Parameters:</p> Name Type Description Default <code>base_ket</code> <code>int</code> <p>A quantum ket, represented by its corresponding non-negative integer.       By convention, qubit #0 corresponds to the least significant bit.</p> required <code>reduced_ket</code> <code>int</code> <p>A quantum ket, represented by its corresponding non-negative integer.          By convention, qubit #0 corresponds to the least significant bit.</p> required <code>qubits</code> <code>Iterable[QubitLike]</code> <p>The indices of the qubits to expand from the reduced ket. Order matters.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The non-negative integer corresponding to the expanded ket.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; expand_ket(0b00000, 0b0, [Qubit(5)])   # 0b000000\n0\n&gt;&gt;&gt; expand_ket(0b00000, 0b1, [Qubit(5)])   # 0b100000\n32\n&gt;&gt;&gt; expand_ket(0b00111, 0b0, [Qubit(5)])   # 0b000111\n7\n&gt;&gt;&gt; expand_ket(0b00111, 0b1, [Qubit(5)])   # 0b100111\n39\n&gt;&gt;&gt; expand_ket(0b0000, 0b000, [Qubit(1), Qubit(2), Qubit(3)])    # 0b0000\n0\n&gt;&gt;&gt; expand_ket(0b0000, 0b001, [Qubit(1), Qubit(2), Qubit(3)])    # 0b0010\n2\n&gt;&gt;&gt; expand_ket(0b0000, 0b011, [Qubit(1), Qubit(2), Qubit(3)])    # 0b0110\n6\n&gt;&gt;&gt; expand_ket(0b0000, 0b101, [Qubit(1), Qubit(2), Qubit(3)])   # 0b1010\n10\n&gt;&gt;&gt; expand_ket(0b0001, 0b101, [Qubit(1), Qubit(2), Qubit(3)])   # 0b1011\n11\n</code></pre> Source code in <code>opensquirrel/utils/matrix_expander.py</code> <pre><code>def expand_ket(base_ket: int, reduced_ket: int, qubits: Iterable[QubitLike]) -&gt; int:\n    \"\"\"\n    Given a base quantum ket on n qubits and a reduced ket on a subset of those qubits, this computes the expanded ket\n    where the reduction qubits and the other qubits are set based on the reduced ket and the base ket, respectively.\n    Roughly equivalent to the `pdep` assembly instruction (bits deposit).\n\n    Args:\n        base_ket: A quantum ket, represented by its corresponding non-negative integer.\n                  By convention, qubit #0 corresponds to the least significant bit.\n        reduced_ket: A quantum ket, represented by its corresponding non-negative integer.\n                     By convention, qubit #0 corresponds to the least significant bit.\n        qubits: The indices of the qubits to expand from the reduced ket. Order matters.\n\n    Returns:\n        The non-negative integer corresponding to the expanded ket.\n\n    Examples:\n        &gt;&gt;&gt; expand_ket(0b00000, 0b0, [Qubit(5)])   # 0b000000\n        0\n        &gt;&gt;&gt; expand_ket(0b00000, 0b1, [Qubit(5)])   # 0b100000\n        32\n        &gt;&gt;&gt; expand_ket(0b00111, 0b0, [Qubit(5)])   # 0b000111\n        7\n        &gt;&gt;&gt; expand_ket(0b00111, 0b1, [Qubit(5)])   # 0b100111\n        39\n        &gt;&gt;&gt; expand_ket(0b0000, 0b000, [Qubit(1), Qubit(2), Qubit(3)])    # 0b0000\n        0\n        &gt;&gt;&gt; expand_ket(0b0000, 0b001, [Qubit(1), Qubit(2), Qubit(3)])    # 0b0010\n        2\n        &gt;&gt;&gt; expand_ket(0b0000, 0b011, [Qubit(1), Qubit(2), Qubit(3)])    # 0b0110\n        6\n        &gt;&gt;&gt; expand_ket(0b0000, 0b101, [Qubit(1), Qubit(2), Qubit(3)])   # 0b1010\n        10\n        &gt;&gt;&gt; expand_ket(0b0001, 0b101, [Qubit(1), Qubit(2), Qubit(3)])   # 0b1011\n        11\n    \"\"\"\n    expanded_ket = base_ket\n    for i, qubit in enumerate(qubits):\n        qubit = Qubit(qubit)\n        expanded_ket &amp;= ~(1 &lt;&lt; qubit.index)  # erase bit\n        expanded_ket |= ((reduced_ket &amp; (1 &lt;&lt; i)) &gt;&gt; i) &lt;&lt; qubit.index  # set bit to value from reduced_ket\n\n    return expanded_ket\n</code></pre>"},{"location":"reference/utils/matrix_expander.html#opensquirrel.utils.matrix_expander.get_matrix","title":"<code>get_matrix(gate, qubit_register_size)</code>","text":"<p>Compute the unitary matrix corresponding to the gate applied to those qubit operands, taken among any number of qubits. This can be used for, e.g., - testing, - permuting the operands of multi-qubit gates, - simulating a circuit (simulation in this way is inefficient for large numbers of qubits).</p> <p>Parameters:</p> Name Type Description Default <code>gate</code> <code>Gate</code> <p>The gate, including the qubits on which it is operated on.</p> required <code>qubit_register_size</code> <code>int</code> <p>The size of the qubit register.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; X = lambda q: BlochSphereRotation(qubit=q, axis=(1, 0, 0), angle=math.pi, phase=math.pi / 2)\n&gt;&gt;&gt; get_matrix(X(1), 2).astype(int)           # X q[1]\narray([[0, 0, 1, 0],\n       [0, 0, 0, 1],\n       [1, 0, 0, 0],\n       [0, 1, 0, 0]])\n</code></pre> <pre><code>&gt;&gt;&gt; CNOT02 = ControlledGate(0, X(2))\n&gt;&gt;&gt; get_matrix(CNOT02, 3).astype(int)     # CNOT q[0], q[2]\narray([[1, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 1, 0, 0],\n       [0, 0, 1, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 1],\n       [0, 0, 0, 0, 1, 0, 0, 0],\n       [0, 1, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 1, 0],\n       [0, 0, 0, 1, 0, 0, 0, 0]])\n&gt;&gt;&gt; get_matrix(ControlledGate(1, X(2)), 3).astype(int)     # CNOT q[1], q[2]\narray([[1, 0, 0, 0, 0, 0, 0, 0],\n       [0, 1, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 1, 0],\n       [0, 0, 0, 0, 0, 0, 0, 1],\n       [0, 0, 0, 0, 1, 0, 0, 0],\n       [0, 0, 0, 0, 0, 1, 0, 0],\n       [0, 0, 1, 0, 0, 0, 0, 0],\n       [0, 0, 0, 1, 0, 0, 0, 0]])\n</code></pre> Source code in <code>opensquirrel/utils/matrix_expander.py</code> <pre><code>def get_matrix(gate: Gate, qubit_register_size: int) -&gt; NDArray[np.complex128]:\n    \"\"\"\n    Compute the unitary matrix corresponding to the gate applied to those qubit operands, taken among any number of\n    qubits. This can be used for, e.g.,\n    - testing,\n    - permuting the operands of multi-qubit gates,\n    - simulating a circuit (simulation in this way is inefficient for large numbers of qubits).\n\n    Args:\n        gate: The gate, including the qubits on which it is operated on.\n        qubit_register_size: The size of the qubit register.\n\n    Examples:\n        &gt;&gt;&gt; X = lambda q: BlochSphereRotation(qubit=q, axis=(1, 0, 0), angle=math.pi, phase=math.pi / 2)\n        &gt;&gt;&gt; get_matrix(X(1), 2).astype(int)           # X q[1]\n        array([[0, 0, 1, 0],\n               [0, 0, 0, 1],\n               [1, 0, 0, 0],\n               [0, 1, 0, 0]])\n\n        &gt;&gt;&gt; CNOT02 = ControlledGate(0, X(2))\n        &gt;&gt;&gt; get_matrix(CNOT02, 3).astype(int)     # CNOT q[0], q[2]\n        array([[1, 0, 0, 0, 0, 0, 0, 0],\n               [0, 0, 0, 0, 0, 1, 0, 0],\n               [0, 0, 1, 0, 0, 0, 0, 0],\n               [0, 0, 0, 0, 0, 0, 0, 1],\n               [0, 0, 0, 0, 1, 0, 0, 0],\n               [0, 1, 0, 0, 0, 0, 0, 0],\n               [0, 0, 0, 0, 0, 0, 1, 0],\n               [0, 0, 0, 1, 0, 0, 0, 0]])\n        &gt;&gt;&gt; get_matrix(ControlledGate(1, X(2)), 3).astype(int)     # CNOT q[1], q[2]\n        array([[1, 0, 0, 0, 0, 0, 0, 0],\n               [0, 1, 0, 0, 0, 0, 0, 0],\n               [0, 0, 0, 0, 0, 0, 1, 0],\n               [0, 0, 0, 0, 0, 0, 0, 1],\n               [0, 0, 0, 0, 1, 0, 0, 0],\n               [0, 0, 0, 0, 0, 1, 0, 0],\n               [0, 0, 1, 0, 0, 0, 0, 0],\n               [0, 0, 0, 1, 0, 0, 0, 0]])\n    \"\"\"\n    expander = MatrixExpander(qubit_register_size)\n    return np.asarray(gate.accept(expander), dtype=np.complex128)\n</code></pre>"},{"location":"reference/utils/matrix_expander.html#opensquirrel.utils.matrix_expander.get_reduced_ket","title":"<code>get_reduced_ket(ket, qubits)</code>","text":"<p>Given a quantum ket represented by its corresponding base-10 integer, this computes the reduced ket where only the given qubits appear, in order. Roughly equivalent to the <code>pext</code> assembly instruction (bits extraction).</p> <p>Parameters:</p> Name Type Description Default <code>ket</code> <code>int</code> <p>A quantum ket, represented by its corresponding non-negative integer.  By convention, qubit #0 corresponds to the least significant bit.</p> required <code>qubits</code> <code>Iterable[QubitLike]</code> <p>The indices of the qubits to extract. Order matters.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The non-negative integer corresponding to the reduced ket.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; get_reduced_ket(1, [Qubit(0)])         # 0b01\n1\n&gt;&gt;&gt; get_reduced_ket(1111, [Qubit(2)])      # 0b01\n1\n&gt;&gt;&gt; get_reduced_ket(1111, [Qubit(5)])      # 0b0\n0\n&gt;&gt;&gt; get_reduced_ket(1111, [Qubit(2), Qubit(5)])   # 0b01\n1\n&gt;&gt;&gt; get_reduced_ket(101, [Qubit(1), Qubit(0)])    # 0b10\n2\n&gt;&gt;&gt; get_reduced_ket(101, [Qubit(0), Qubit(1)])    # 0b01\n1\n</code></pre> Source code in <code>opensquirrel/utils/matrix_expander.py</code> <pre><code>def get_reduced_ket(ket: int, qubits: Iterable[QubitLike]) -&gt; int:\n    \"\"\"\n    Given a quantum ket represented by its corresponding base-10 integer, this computes the reduced ket\n    where only the given qubits appear, in order.\n    Roughly equivalent to the `pext` assembly instruction (bits extraction).\n\n    Args:\n        ket: A quantum ket, represented by its corresponding non-negative integer.\n             By convention, qubit #0 corresponds to the least significant bit.\n        qubits: The indices of the qubits to extract. Order matters.\n\n    Returns:\n        The non-negative integer corresponding to the reduced ket.\n\n    Examples:\n        &gt;&gt;&gt; get_reduced_ket(1, [Qubit(0)])         # 0b01\n        1\n        &gt;&gt;&gt; get_reduced_ket(1111, [Qubit(2)])      # 0b01\n        1\n        &gt;&gt;&gt; get_reduced_ket(1111, [Qubit(5)])      # 0b0\n        0\n        &gt;&gt;&gt; get_reduced_ket(1111, [Qubit(2), Qubit(5)])   # 0b01\n        1\n        &gt;&gt;&gt; get_reduced_ket(101, [Qubit(1), Qubit(0)])    # 0b10\n        2\n        &gt;&gt;&gt; get_reduced_ket(101, [Qubit(0), Qubit(1)])    # 0b01\n        1\n    \"\"\"\n    reduced_ket = 0\n    for i, qubit in enumerate(qubits):\n        qubit = Qubit(qubit)\n        reduced_ket |= ((ket &amp; (1 &lt;&lt; qubit.index)) &gt;&gt; qubit.index) &lt;&lt; i\n\n    return reduced_ket\n</code></pre>"},{"location":"reference/writer/writer.html","title":"writer","text":""},{"location":"tutorial/index.html","title":"Tutorial","text":"<p>The goal of this tutorial is to convey the basic functionalities of OpenSquirrel. In a nutshell, we will do so by</p> <ol> <li>creating a circuit by reading/building a quantum program,</li> <li>applying compilation passes on the circuit, and</li> <li>writing out and exporting the compiled program to various formats.</li> </ol> <p>The diagram below illustrates the basic components of OpenSquirrel. We refer to it in the following sections, where we quickly go through the 3 aforementioned steps.</p> <p></p> <p>1. creating a circuit</p> <p>Note that on the left side of the diagram a quantum program written in the cQASM language can be read-in by the reader, which uses the libQASM parser to generate the circuit. Alternatively, a circuit can be produced by using the programmatic API of OpenSquirrel, given by the circuit builder.</p> <p>Both approaches result in an instance of a <code>Circuit</code>, which comprises OpenSquirrel's main entrypoint. The circuit object contains the attributes of the input quantum program and stores its statements in an Intermediate Representation (IR).</p> <p>Check for more details: Creating a circuit</p> <p>2. applying compilation passes</p> <p>The user can, subsequently, perform certain actions (or methods) on the <code>circuit</code> object; these are (at the moment of writing and in alphabetic order):</p> <ul> <li>decompose</li> <li>export</li> <li>map</li> <li>merge</li> <li>route</li> <li>validate</li> </ul> <p>For each of these actions the user will provide an appropriate compilation pass and potential input arguments. For instance, to obtain the McKay decomposition of the circuit, one would select the <code>McKayDecomposer</code> and perform the <code>decompose</code> action on the <code>circuit</code> object accordingly:</p> <pre><code>circuit.decompose(decomposer=McKayDecomposer())\n</code></pre> <p>This particular pass does not take any input parameters.</p> <p>Each compilation pass will take the circuit or IR as input and perform the specified action on it. Ultimately, these actions either validate or make changes to certain properties/components of the circuit, whilst preserving the semantic content of the program.</p> <p>Order matters</p> <p>Note that the order in which the various compilation passes are applied will have an impact on the final result. In particular, it will make more sense to validate a result after making any changes. For instance, validating wether the gates in the circuit are part of the (specified) primitive gate set, should be done after decomposition.</p> <p>Check for more details: Applying compilation passes</p> <p>3. writing out or exporting the compiled program</p> <p>After the desired actions have been applied to the circuit, one can decide to either write the compiled program to cQASM using the writer, or export the result to a different format, by selecting one of the available exporters.</p> <p>The string representation of the <code>circuit</code> object automatically invokes the writer, so the following line will return the (compiled) program, i.e. program' , in cQASM:</p> <p></p><pre><code>str(circuit)\n</code></pre> Python's <code>print()</code> statement can be used to print the program in cQASM.<p></p> <p>If one wishes to export the (compiled) program to, for example, a quantify-scheduler <code>Schedule</code> one would do the following, using the quantify-scheduler exporter:</p> <pre><code>exported_schedule, _ = circuit.export(exporter=QuantifySchedulerExporter())\n</code></pre> <p>Check for more details: Writing out and exporting</p>"},{"location":"tutorial/applying-compilation-passes.html","title":"Applying compilation passes","text":"<p>Once we have created a circuit, we can now perform actions on it by applying various compilation passes. The actions that were listed in the general tutorial correspond to the following types of compilation (in alphabetic order):</p> <ul> <li>Decomposition</li> <li>Exporting</li> <li>Mapping</li> <li>Merging</li> <li>Routing</li> <li>Validation</li> </ul> <p>All available compilation passes, organized by type, can be found here.</p>"},{"location":"tutorial/applying-compilation-passes.html#input-program","title":"Input program","text":"<p>In this section, we will go through a few compilation passes by applying them to an input program and evaluating the result after each pass. We will use the following example program, from which we can create the <code>circuit</code> object as described in Creating a circuit:</p> <p>Example input program</p> <p>Program as a cQASM string:</p> <pre><code>version 3.0\n\nqubit[3] q\nbit[2] b\n\ninit q\n\nRy(pi/2) q[0]\nX q[0]\nCNOT q[0], q[2]\n\nbarrier q\nb[0, 1] = measure q[0, 2]\n</code></pre> <p>Program as described by the <code>circuit</code> object in OpenSquirrel:</p> <p><code>print(circuit)</code></p> <pre><code>version 3.0\n\nqubit[3] q\nbit[2] b\n\ninit q[0]\ninit q[1]\ninit q[2]\nRy(1.5707963) q[0]\nX q[0]\nCNOT q[0], q[2]\nbarrier q[0]\nbarrier q[1]\nbarrier q[2]\nb[0] = measure q[0]\nb[1] = measure q[2]\n</code></pre>"},{"location":"tutorial/applying-compilation-passes.html#target-qpu-specifications","title":"Target QPU specifications","text":"<p>The purpose of compilation is to be able to execute the user-described program on a particular target quantum processing unit (QPU), also refer to as the target backend. A target backend will have some specific properties that are required by certain compilation passes as input parameters.</p> <p>Here we define an example connectivity and primitive gate set, that will be needed for some of the following passes.</p>"},{"location":"tutorial/applying-compilation-passes.html#connectivity","title":"Connectivity","text":"<p>The connectivity of a QPU describes which qubits are connected and can, therefore, interact with each other. This is essential information for two-qubit gates, as they can only occur between qubits that share a connection.</p> <p>The connectivity is given by a dictionary, where the keys are the qubit indices and the values are a list of qubit indices that the qubit has a (uni-directional) connection with.</p> <pre><code>connectivity= {\n    \"0\": [1],\n    \"1\": [0, 2],\n    \"2\": [1]\n}\n</code></pre> <p>Bi-directional connections</p> <p>Connections are bi-directional, only if defined explicitly so, i.e., the connection between qubits <code>i</code> and <code>j</code> is bi-directional if qubit <code>i</code> is connected to qubit <code>j</code> and qubit <code>j</code> is connected to qubit <code>i</code>.</p> <p>We will use the connectivity when routing the circuit and perform a final validation to check that the interactions occur between connected qubits.</p>"},{"location":"tutorial/applying-compilation-passes.html#primitive-gate-set","title":"Primitive gate set","text":"<p>The primitive gate set describes the set of gates that are supported by the (lower-level software of the) target backend. The primitive gates are not to be confused with the native gates. The latter are the gates that can directly be performed on the QPU, i.e., they are native to the QPU. In general, a translation step will still occur from the primitive gates to the native gates, on the side of the target backend.</p> <p>The primitive gate set, labeled as the <code>pgs</code>, is given by a list of gate names (as they are defined in the cQASM standard gate library):</p> <pre><code>pgs = [\"I\", \"X90\", \"Rx\", \"Rz\", \"CZ\", \"init\", \"barrier\", \"measure\"]\n</code></pre> <p>A target backend expects that the circuit of the compiled program consists solely of gates that appear in the primitive gate set. Accordingly, we will use <code>pgs</code> as an input argument to validate that the fully decomposed circuit is in terms of gates that are in the primitive gate set.</p>"},{"location":"tutorial/applying-compilation-passes.html#routing","title":"Routing","text":"<p>We start the compilation process with an initial routing pass to ensure that the interactions in the circuit occur between neighbouring qubits. The example circuit contains a two-qubit gate, i.e. the CNOT gate, between qubits at indices <code>0</code> and <code>2</code>, respectively. Given the connectivity of the QPU as stated above, we see that these qubits are not connected and therefore cannot interact. By introducing SWAPs in the circuit, the routing pass will ensure that all interactions in the circuit occur between neighbouring qubits.</p> <p>Here we use the <code>route</code> method with the shortest path router <code>ShortestPathRouter</code> to route the circuit.</p> <pre><code>from opensquirrel.passes.router import ShortestPathRouter\n\ncircuit.route(router=ShortestPathRouter(connectivity=connectivity))\n</code></pre> <code>print(circuit)  # Circuit after routing</code> <pre><code>version 3.0\n\nqubit[3] q\nbit[2] b\n\ninit q[0]\ninit q[1]\ninit q[2]\nRy(1.5707963) q[0]\nX q[0]\nSWAP q[0], q[1]\nCNOT q[1], q[2]\nbarrier q[1]\nbarrier q[0]\nbarrier q[2]\nb[0] = measure q[1]\nb[1] = measure q[2]\n</code></pre> <p>Note that, in general, a routing pass will require the connectivity of the QPU as input.</p> <p>Since a routing pass will introduce SWAPs to the circuit, it will need to be applied before any decomposition passes, as SWAPs are generally not supported by the QPU.</p>"},{"location":"tutorial/applying-compilation-passes.html#decomposition-predefined","title":"Decomposition - predefined","text":"<p>We will continue with some predefined decompositions. They are predefined in the sense that the decomposition is defined for a particular gate, e.g. the SWAP gate, and the resultant decomposition is hard-coded.</p> <p>SWAP gates are generally not supported by the target backend (consider the <code>pgs</code>) and need to be decomposed into, e.g., a series of CZ gates and single-qubit gates.</p> <p>Note</p> <p>Currently, OpenSquirrel only has general decomposers for arbitrary two-qubit controlled-gates, i.e, the</p> <ul> <li>the CNOT decomposer (<code>CNOTDecomposer</code>), and</li> <li>the CZ decomposer (<code>CZDecomposer</code>).</li> </ul> <p>Since the SWAP gate is not a controlled-gate, the predefined SWAP-to-CNOT or SWAP-to-CZ decomposers are to be used to decompose a SWAP gate to a series of single-qubit gates and, either, CZs or CNOTs for two-qubit interactions.</p> <p>Since the CZ gate is supported by the target backend, we use the <code>decompose</code> method with the SWAP-to-CZ decomposer (<code>SWAP2CZDecomposer</code>) to decompose the SWAP gate.</p> <pre><code>from opensquirrel.passes.decomposer import SWAP2CZDecomposer\n\ncircuit.decompose(decomposer=SWAP2CZDecomposer())\n</code></pre> <code>print(circuit)  # Circuit after SWAP-to-CZ decomposition</code> <pre><code>version 3.0\n\nqubit[3] q\nbit[2] b\n\ninit q[0]\ninit q[1]\ninit q[2]\nRy(1.5707963) q[0]\nX q[0]\nRy(-1.5707963) q[1]\nCZ q[0], q[1]\nRy(1.5707963) q[1]\nRy(-1.5707963) q[0]\nCZ q[1], q[0]\nRy(1.5707963) q[0]\nRy(-1.5707963) q[1]\nCZ q[0], q[1]\nRy(1.5707963) q[1]\nCNOT q[1], q[2]\nbarrier q[1]\nbarrier q[0]\nbarrier q[2]\nb[0] = measure q[1]\nb[1] = measure q[2]\n</code></pre> <p>Our example circuit also contains a CNOT gate. Since it is not supported by the target backend, we use the <code>decompose</code> method with the CNOT-to-CZ predefined decomposer (<code>CNOT2CZDecomposer</code>) to decompose the CNOT into a series of single-qubit gates and a CZ gate.</p> <pre><code>from opensquirrel.passes.decomposer import CNOT2CZDecomposer\n\ncircuit.decompose(decomposer=CNOT2CZDecomposer())\n</code></pre> <code>print(circuit)  # Circuit after CNOT-to-CZ decomposition</code> <pre><code>version 3.0\n\nqubit[3] q\nbit[2] b\n\ninit q[0]\ninit q[1]\ninit q[2]\nRy(1.5707963) q[0]\nX q[0]\nRy(-1.5707963) q[1]\nCZ q[0], q[1]\nRy(1.5707963) q[1]\nRy(-1.5707963) q[0]\nCZ q[1], q[0]\nRy(1.5707963) q[0]\nRy(-1.5707963) q[1]\nCZ q[0], q[1]\nRy(1.5707963) q[1]\nRy(-1.5707963) q[2]\nCZ q[1], q[2]\nRy(1.5707963) q[2]\nbarrier q[1]\nbarrier q[0]\nbarrier q[2]\nb[0] = measure q[1]\nb[1] = measure q[2]\n</code></pre> <p>Since the CNOT is a controlled-gate, we could also have used the CZ decomposer to achieve the same result. Nevertheless, if available, a predefined decomposer will generally be more efficient as no inference is required.</p>"},{"location":"tutorial/applying-compilation-passes.html#merging","title":"Merging","text":"<p>To reduce the amount of single-qubit gates in the circuit, we can merge consecutive single-qubit gates on the same qubit into one. To do so, we use the <code>merge</code> method with the single-qubit gates merger pass (<code>SingleQubitGatesMerger</code>).</p> <p>Note</p> <p>The single-qubit gate that results from merging multiple single-qubit gates, is generally not supported by the target backend; a single-qubit gate decomposition pass will need to be applied after merging. OpenSquirrel will check if the resultant gate is equal (up to a global phase) to the gates that it replaces.</p> <pre><code>from opensquirrel.passes.merger import SingleQubitGatesMerger\n\ncircuit.merge(merger=SingleQubitGatesMerger())\n</code></pre> <code>print(circuit)  # Circuit after merging single-qubit gates</code> <pre><code>version 3.0\n\nqubit[3] q\nbit[2] b\n\ninit q[0]\ninit q[1]\ninit q[2]\nH q[0]\nRn(0.0, -1.0, 0.0, 1.5707963, 0.0) q[1]\nCZ q[0], q[1]\nRy(1.5707963) q[1]\nRn(0.0, -1.0, 0.0, 1.5707963, 0.0) q[0]\nCZ q[1], q[0]\nRy(1.5707963) q[0]\nRn(0.0, -1.0, 0.0, 1.5707963, 0.0) q[1]\nCZ q[0], q[1]\nRy(1.5707963) q[1]\nRn(0.0, -1.0, 0.0, 1.5707963, 0.0) q[2]\nCZ q[1], q[2]\nRy(1.5707963) q[2]\nbarrier q[1]\nbarrier q[0]\nbarrier q[2]\nb[0] = measure q[1]\nb[1] = measure q[2]\n</code></pre>"},{"location":"tutorial/applying-compilation-passes.html#decomposition-inferred","title":"Decomposition - inferred","text":"<p>To ensure that the single-qubit gates in the circuit can be executed on the target backend, we need to decompose them according to available gates in the primitive gate set, i.e., the <code>pgs</code>. We can see from <code>pgs</code> that our target backend accepts all kinds of rotations about the x- and z- axis.</p> <p>The McKay decomposer decomposes arbitrary single-qubit gates into at most 5 gates: \\(R_z(\\gamma)\\cdot X^{1/2}\\cdot R_z(\\beta)\\cdot X^{1/2}\\cdot R_z(\\alpha)\\), where \\(\\alpha\\), \\(\\beta\\), and \\(\\gamma\\), represent different rotation angles. The rotation angles need to be inferred from the semantic of the single-qubit gate that is to be decomposed, i.e., they are not defined in advance.</p> <p>We invoke the McKay decomposition on the circuit by applying the <code>decompose</code> method with the McKay decomposer pass (<code>McKayDecomposer</code>).</p> <pre><code>from opensquirrel.passes.decomposer import McKayDecomposer\n\ncircuit.decompose(decomposer=McKayDecomposer())\n</code></pre> <code>print(circuit)  # Circuit after McKay decomposition</code> <pre><code>version 3.0\n\nqubit[3] q\nbit[2] b\n\ninit q[0]\ninit q[1]\ninit q[2]\nRz(1.5707963) q[0]\nX90 q[0]\nRz(1.5707963) q[0]\nRz(1.5707963) q[1]\nX90 q[1]\nRz(-1.5707963) q[1]\nCZ q[0], q[1]\nRz(-1.5707963) q[1]\nX90 q[1]\nRz(1.5707963) q[1]\nRz(1.5707963) q[0]\nX90 q[0]\nRz(-1.5707963) q[0]\nCZ q[1], q[0]\nRz(-1.5707963) q[0]\nX90 q[0]\nRz(1.5707963) q[0]\nRz(1.5707963) q[1]\nX90 q[1]\nRz(-1.5707963) q[1]\nCZ q[0], q[1]\nRz(-1.5707963) q[1]\nX90 q[1]\nRz(1.5707963) q[1]\nRz(1.5707963) q[2]\nX90 q[2]\nRz(-1.5707963) q[2]\nCZ q[1], q[2]\nRz(-1.5707963) q[2]\nX90 q[2]\nRz(1.5707963) q[2]\nbarrier q[1]\nbarrier q[0]\nbarrier q[2]\nb[0] = measure q[1]\nb[1] = measure q[2]\n</code></pre>"},{"location":"tutorial/applying-compilation-passes.html#validation","title":"Validation","text":"<p>It is good practice to validate certain properties of the program before exporting it. Here we check whether the interactions in the final circuit are valid given the connectivity and whether all gates appear in the primitive gate set.</p> <p>Even though, validation is not a compilation pass per se, it is called in the same way on the circuit. Accordingly, we treat it as a pass that is part of the compilation pass library.</p>"},{"location":"tutorial/applying-compilation-passes.html#routing-validation","title":"Routing validation","text":"<p>To check the validity of the interactions in the circuit, we use the <code>validate</code> method with the interactions validator pass (<code>InteractionValidator</code>) and the connectivity as an input argument for the validator.</p> <pre><code>from opensquirrel.passes.validator import InteractionValidator\n\ncircuit.validate(validator=InteractionValidator(connectivity=connectivity))\n</code></pre> <p>An exception will be thrown if any interaction in the circuit is invalid.</p>"},{"location":"tutorial/applying-compilation-passes.html#primitive-gate-set-validation","title":"Primitive gate set validation","text":"<p>To check if all gates in the circuit are part of the primitive gate set, we use the <code>validate</code> method with the primitive gate validator pass (<code>PrimitiveGateValidator</code>) and the <code>pgs</code>, i.e. primitive gate set, as an input argument for the validator.</p> <pre><code>from opensquirrel.passes.validator import PrimitiveGateValidator\n\ncircuit.validate(validator=PrimitiveGateValidator(primitive_gate_set=pgs))\n</code></pre> <p>An exception will be thrown if any gate is not part of the primitive gate set.</p>"},{"location":"tutorial/applying-compilation-passes.html#exporting","title":"Exporting","text":"<p>Now that we have the performed the desired compilation passes and validated certain aspects of the circuit, we can either choose to write it out to cQASM or export it to a different format.</p> <p>Proceed to Writing out and exporting to learn how.</p>"},{"location":"tutorial/applying-compilation-passes.html#full-example-compilation","title":"Full example compilation","text":"<p>Find below the full example compilation procedure in a single Python script (including reading and writing out of the program).</p> Full example compilation <p>The Python script, taking as input the example program:</p> <pre><code>from opensquirrel import Circuit\nfrom opensquirrel.passes.router import ShortestPathRouter\nfrom opensquirrel.passes.decomposer import SWAP2CZDecomposer, CNOT2CZDecomposer, McKayDecomposer\nfrom opensquirrel.passes.merger import SingleQubitGatesMerger\nfrom opensquirrel.passes.validator import RoutingValidator, PrimitiveGateValidator\n\n# Target QPU specifications\nconnectivity= {\n    \"0\": [1],\n    \"1\": [0, 2],\n    \"2\": [1]\n}\npgs = [\"I\", \"X\", \"Z\", \"X90\", \"mX90\", \"S\", \"Sdag\", \"T\", \"Tdag\", \"Rx\", \"Rz\", \"CZ\"]\n\n# Reading the example program\ncircuit = Circuit.from_string(\n    \"\"\"\n    version 3.0\n\n    qubit[3] q\n    bit[2] b\n\n    init q\n\n    Ry(pi/2) q[0]\n    X q[0]\n    CNOT q[0], q[2]\n\n    barrier q\n    b[0, 1] = measure q[0, 2]\n    \"\"\"\n)\n\n# Applying compilation passes (to the circuit)\ncircuit.route(router=ShortestPathRouter(connectivity=connectivity))\ncircuit.decompose(decomposer=SWAP2CZDecomposer())\ncircuit.decompose(decomposer=CNOT2CZDecomposer())\ncircuit.merge(merger=SingleQubitGatesMerger())\ncircuit.decompose(decomposer=McKayDecomposer())\n\n# Validating circuit aspects\ncircuit.validate(validator=RoutingValidator(connectivity=connectivity))\ncircuit.validate(validator=PrimitiveGateValidator(pgs=pgs))\n\n# Writing out the compiled program to cQASM (one can also use the 'str()' method)\nprint(circuit)\n</code></pre> <p>The compiled program (in cQASM):</p> <pre><code>version 3.0\n\nqubit[3] q\nbit[2] b\n\ninit q[0]\ninit q[1]\ninit q[2]\nRz(1.5707963) q[0]\nX90 q[0]\nRz(1.5707963) q[0]\nRz(1.5707963) q[1]\nX90 q[1]\nRz(-1.5707963) q[1]\nCZ q[0], q[1]\nRz(-1.5707963) q[1]\nX90 q[1]\nRz(1.5707963) q[1]\nRz(1.5707963) q[0]\nX90 q[0]\nRz(-1.5707963) q[0]\nCZ q[1], q[0]\nRz(-1.5707963) q[0]\nX90 q[0]\nRz(1.5707963) q[0]\nRz(1.5707963) q[1]\nX90 q[1]\nRz(-1.5707963) q[1]\nCZ q[0], q[1]\nRz(-1.5707963) q[1]\nX90 q[1]\nRz(1.5707963) q[1]\nRz(1.5707963) q[2]\nX90 q[2]\nRz(-1.5707963) q[2]\nCZ q[1], q[2]\nRz(-1.5707963) q[2]\nX90 q[2]\nRz(1.5707963) q[2]\nbarrier q[1]\nbarrier q[0]\nbarrier q[2]\nb[0] = measure q[1]\nb[1] = measure q[2]\n</code></pre>"},{"location":"tutorial/creating-a-circuit.html","title":"Creating a circuit","text":"<p>As described in the tutorial, a circuit can be created in two ways:</p> <ol> <li>from a cQASM string, or</li> <li>by using the circuit builder in Python.</li> </ol> <p>Consider the following example quantum program written in the cQASM language:</p> <pre><code>// Version statement\nversion 3.0\n\n// Qubit register declaration\nqubit[3] q\n\n// Bit register declaration\nbit[2] b\n\n// Qubit register initialization (with SGMQ notation)\ninit q\n\n// Single-qubit gates\nRy(pi / 2) q[0]\nX q[0]\n\n// Two-qubit gate\nCNOT q[0], q[2]\n\n// Control instruction (with SGMQ notation)\nbarrier q\n\n// Measure instruction (with SGMQ notation)\nb[0, 1] = measure q[0, 2]\n</code></pre>"},{"location":"tutorial/creating-a-circuit.html#1-from-a-cqasm-string","title":"1. from a cQASM string","text":"<p>Here we demonstrate how a circuit can be created from a cQASM string, using the <code>Circuit.from_string</code> method with the above example program as an input argument:</p> <pre><code>from opensquirrel import Circuit\n\ncircuit = Circuit.from_string(\n    \"\"\"\n    // Version statement\n    version 3.0\n\n    // Qubit register declaration\n    qubit[3] q\n\n    // Bit register declaration\n    bit[2] b\n\n    // Qubit register initialization (with SGMQ notation)\n    init q\n\n    // Single-qubit gates\n    Ry(pi / 2) q[0]\n    X q[0]\n\n    // Two-qubit gate\n    CNOT q[0], q[2]\n\n    // Control instruction (with SGMQ notation)\n    barrier q\n\n    // Measure instruction (with SGMQ notation)\n    b[0, 1] = measure q[0, 2]\n\n    \"\"\"\n)\n</code></pre> <code>print(circuit)</code> <pre><code>version 3.0\n\nqubit[3] q\nbit[2] b\n\ninit q[0]\ninit q[1]\ninit q[2]\nRy(1.5707963) q[0]\nX q[0]\nCNOT q[0], q[2]\nbarrier q[0]\nbarrier q[1]\nbarrier q[2]\nb[0] = measure q[0]\nb[1] = measure q[2]\n</code></pre> <p>The <code>Circuit.from_string</code> method invokes OpenSquirrel's reader which uses the libQASM parser to parse the input program.</p> <p>Some important things to note about how OpenSquirrel reads the input cQASM string: the OpenSquirrel reader</p> <ul> <li>ignores any comments;   they are simply not registered during the parsing phase,</li> <li>combines all logical (qu)bit registers into a single virtual (qu)bit register   with identifiers <code>q</code> and <code>b</code>, signifying the qubit and bit registers, respectively,</li> <li>unpacks any SGMQ notation   as separate consecutive statements,</li> <li>evaluates complex expressions (e.g., <code>pi/2</code> becomes <code>1.5707963</code>), and</li> <li>normalizes the values of the parameters for the rotation angle \\(\\theta\\) and phase \\(\\phi\\) to within the range   \\(\\left(-\\pi, \\pi \\right]\\).</li> </ul> <p>Regarding the latter point, when using the inverse or power gate modifiers, the modifier is applied first and only then are the values of the parameters normalized, e.g., <code>pow(1/2).Rx(3 * pi)</code> becomes <code>Rx(-pi / 2)</code>, instead of <code>Rx(pi / 2)</code>.</p> <p>OpenSquirrel's native tongue is cQASM</p> <p>The OpenSquirrel reader only accepts quantum programs written in cQASM. The same applies to OpenSquirrel's writer, i.e., the string representation of a <code>circuit</code> is in cQASM. Nonetheless, using exporter passes one can export to circuit to a different language, e.g., quantify-scheduler Schedule or cQASM 1.0.</p> <p>One can now proceed to apply compilation passes to the <code>circuit</code> object.</p>"},{"location":"tutorial/creating-a-circuit.html#2-by-using-the-circuit-builder","title":"2. by using the circuit builder","text":"<p>Circuits can also be defined using Python functionalities, via the circuit builder, as shown below. For this, the user will first need to import the <code>CircuitBuilder</code> from <code>opensquirrel</code>.</p> <pre><code>import math\nfrom opensquirrel import CircuitBuilder\n\nbuilder = CircuitBuilder(qubit_register_size=3, bit_register_size=2)\nbuilder.init(0).init(1).init(2)\nbuilder.Ry(0, math.pi / 2)\nbuilder.X(0)\nbuilder.CNOT(0, 2)\nbuilder.barrier(0).barrier(1).barrier(2)\nbuilder.measure(0, 0).measure(1, 2)\ncircuit = builder.to_circuit()\n</code></pre> <code>print(circuit)</code> <pre><code>version 3.0\n\nqubit[3] q\nbit[2] b\n\ninit q[0]\ninit q[1]\ninit q[2]\nRy(1.5707963) q[0]\nX q[0]\nCNOT q[0], q[2]\nbarrier q[0]\nbarrier q[1]\nbarrier q[2]\nb[0] = measure q[0]\nb[1] = measure q[2]\n</code></pre> <p>Note that the representation of the printed circuit is the same as the one obtained from the cQASM string above.</p> <p>The real power of the circuit builder lies in that fact that it can be used in combination with the functionalities available in Python to create your circuit:</p> <pre><code>from opensquirrel import CircuitBuilder\n\nqreg_size = 10\nbuilder = CircuitBuilder(qubit_register_size=qreg_size)\nfor qubit_index in range(0, qreg_size, 2):\n    builder.H(qubit_index)\ncircuit = builder.to_circuit()\n</code></pre> <code>print(circuit)</code> <pre><code>version 3.0\n\nqubit[10] q\n\nH q[0]\nH q[2]\nH q[4]\nH q[6]\nH q[8]\n</code></pre> <p>For instance, you can straightforwardly generate a quantum fourier transform (QFT) circuit as follows:</p> <pre><code>from opensquirrel import CircuitBuilder\n\nqreg_size = 5\nbuilder = CircuitBuilder(qubit_register_size=qreg_size)\nfor qubit_index in range(qreg_size):\n      builder.H(qubit_index)\n      for control_index in range(qubit_index + 1, qreg_size):\n            target_index = qubit_index\n            k = control_index - target_index + 1\n            builder.CRk(control_index, target_index, k)\ncircuit_qft = builder.to_circuit()\n</code></pre> <code>print(circuit_qft)</code> <pre><code>version 3.0\n\nqubit[5] q\n\nH q[0]\nCRk(2) q[1], q[0]\nCRk(3) q[2], q[0]\nCRk(4) q[3], q[0]\nCRk(5) q[4], q[0]\nH q[1]\nCRk(2) q[2], q[1]\nCRk(3) q[3], q[1]\nCRk(4) q[4], q[1]\nH q[2]\nCRk(2) q[3], q[2]\nCRk(3) q[4], q[2]\nH q[3]\nCRk(2) q[4], q[3]\nH q[4]\n</code></pre> <p>One can now proceed to apply compilation passes to the <code>circuit</code> object.</p>"},{"location":"tutorial/writing-out-and-exporting.html","title":"Writing out and exporting","text":""},{"location":"tutorial/writing-out-and-exporting.html#writing-out","title":"Writing out","text":"<p>OpenSquirrel's native tongue is cQASM. Accordingly, it is straightforward to write out a circuit, since the string representation of a circuit is a cQASM string.</p> <p>Use the Python built-in methods <code>str</code> or <code>print</code> to obtain the cQASM string of the circuit.</p> <p>In the case of the example program that we compiled in the previous section, we simply do the following to write out the circuit:</p> <pre><code># To return the cQASM string\ncqasm_string = str(circuit)\n\n# To print the cQASM string\nprint(circuit)\n</code></pre>"},{"location":"tutorial/writing-out-and-exporting.html#exporting","title":"Exporting","text":"<p>Alternatively, it is possible to export the circuit to a different format. This can be done by using the <code>export</code> method with the desired format as an input argument.</p> <p>For instance, if we want to export our circuit to cQASM 1.0 (given by the export format <code>CQASM_V1</code>) we write the following:</p> <pre><code>from opensquirrel.passes.exporter import CqasmV1Exporter\n\nexported_circuit = circuit.export(exporter=CqasmV1Exporter())\n</code></pre> <p>This uses the cQASMv1 exporter to export the circuit to a cQASM 1.0 string.</p> <code>print(exported_circuit)  # Compiled program in terms of cQASM 1.0</code> <pre><code>version 1.0\n\nqubits 3\n\nprep_z q[0]\nprep_z q[1]\nprep_z q[2]\nrz q[0], 1.5707963\nx90 q[0]\nrz q[0], 1.5707963\nrz q[1], 1.5707963\nx90 q[1]\nrz q[1], -1.5707963\ncz q[0], q[1]\nrz q[1], -1.5707963\nx90 q[1]\nrz q[1], 1.5707963\nrz q[0], 1.5707963\nx90 q[0]\nrz q[0], -1.5707963\ncz q[1], q[0]\nrz q[0], -1.5707963\nx90 q[0]\nrz q[0], 1.5707963\nrz q[1], 1.5707963\nx90 q[1]\nrz q[1], -1.5707963\ncz q[0], q[1]\nrz q[1], -1.5707963\nx90 q[1]\nrz q[1], 1.5707963\nrz q[2], 1.5707963\nx90 q[2]\nrz q[2], -1.5707963\ncz q[1], q[2]\nrz q[2], -1.5707963\nx90 q[2]\nrz q[2], 1.5707963\nbarrier q[1, 0, 2]\nmeasure_z q[1]\nmeasure_z q[2]\n</code></pre> <p>Note that there may be language constructs that do not have a straightforward translation from cQASM to the chosen format. For example, cQASM 1.0 does not support the declaration of bit registers. Consequently, any information regarding bit registers and variables will be lost-in-translation, e.g., in cQASM 1.0, measurement outcomes cannot be written to a specific bit register variable even if this has been done in the original cQASM program.</p> <p>Translation is not always straightforward</p> <p>Make sure to check the documentation on the specific exporters to understand how the translation is done, since not all language constructs can be straightforwardly translated from cQASM into any alternative format.</p>"}]}