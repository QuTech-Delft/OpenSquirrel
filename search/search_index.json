{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"OpenSquirrel","text":"<p>This site contains the project documentation for OpenSquirrel, i.e., a quantum circuit transformation and manipulation tool.</p> <p>&lt;Brief intro to OpenSquirrel&gt;</p> <p>GitHub repository: https://github.com/QuTech-Delft/OpenSquirrel</p> <p>PyPI: https://pypi.org/project/opensquirrel/</p>"},{"location":"#table-of-contents","title":"Table of Contents","text":"<p>The following documentation structure is used: Di\u00e1taxis documentation framework.</p> <ol> <li>Tutorials</li> <li>How-To Guides</li> <li>Reference</li> <li>Explanation</li> </ol>"},{"location":"#authors","title":"Authors","text":"<ul> <li> <p>Pablo Le Henaff (p.lehenaff@tudelft.nl)</p> </li> <li> <p>Roberto Turrado Camblor (r.turradocamblor@tudelft.nl)</p> </li> <li> <p>Chris Elenbaas (chris.elenbaas@tno.nl)</p> </li> </ul>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>&lt;Who made OpenSquirrel possible?&gt;</p>"},{"location":"how-to-guides/","title":"How-To Guides","text":"<p>The purpose of a How-to Guide is to help the user accomplish at task.</p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#opensquirrel.circuit.Circuit","title":"<code>Circuit</code>","text":"<p>The Circuit class is the only interface to access OpenSquirrel's features.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; c = Circuit.from_string(\"version 3.0; qubit[3] q; h q[0]\")\n&gt;&gt;&gt; c\nversion 3.0\n\nqubit[3] q\n\nh q[0]\n\n&gt;&gt;&gt; c.decompose_mckay()\n&gt;&gt;&gt; c\nversion 3.0\n\nqubit[3] q\n\nx90 q[0]\nrz q[0], 1.5707963\nx90 q[0]\n</code></pre> Source code in <code>opensquirrel\\circuit.py</code> <pre><code>class Circuit:\n    \"\"\"The Circuit class is the only interface to access OpenSquirrel's features.\n\n    Examples:\n        &gt;&gt;&gt; c = Circuit.from_string(\"version 3.0; qubit[3] q; h q[0]\")\n        &gt;&gt;&gt; c\n        version 3.0\n        &lt;BLANKLINE&gt;\n        qubit[3] q\n        &lt;BLANKLINE&gt;\n        h q[0]\n        &lt;BLANKLINE&gt;\n        &gt;&gt;&gt; c.decompose_mckay()\n        &gt;&gt;&gt; c\n        version 3.0\n        &lt;BLANKLINE&gt;\n        qubit[3] q\n        &lt;BLANKLINE&gt;\n        x90 q[0]\n        rz q[0], 1.5707963\n        x90 q[0]\n        &lt;BLANKLINE&gt;\n    \"\"\"\n\n    def __init__(self, squirrel_ir: SquirrelIR):\n        \"\"\"Create a circuit object from a SquirrelIR object.\"\"\"\n\n        self.squirrel_ir = squirrel_ir\n\n    @classmethod\n    def from_string(\n        cls,\n        cqasm3_string: str,\n        gate_set: [Callable[..., Gate]] = default_gate_set,\n        gate_aliases: Dict[str, Callable[..., Gate]] = default_gate_aliases,\n        use_libqasm: bool = False,\n    ):\n        \"\"\"Create a circuit object from a cQasm3 string. All the gates in the circuit need to be defined in\n        the `gates` argument.\n\n        * type-checking is performed, eliminating qubit indices errors and incoherencies\n        * checks that used gates are supported and mentioned in `gates` with appropriate signatures\n        * does not support map or variables, and other things...\n        * for example of `gates` dictionary, please look at TestGates.py\n\n\n        Args:\n            cqasm3_string: a cqasm 3 string\n            gate_set: an array of gate semantic functions. See default_gates for examples\n            gate_aliases: a dictionary of extra aliases, mapping strings to functions in the gate set\n            use_libqasm: if True, use libqasm instead of build-in ANTLR parser.\n                Note: those two separate implementations may diverge and libqasm should be taken as reference.\n\n        Returns:\n            A Circuit object corresponding to the input string. Throws on parsing errors.\n        \"\"\"\n\n        if use_libqasm:\n            libqasm_ir_creator = LibqasmIRCreator(gate_set=gate_set, gate_aliases=gate_aliases)\n            return Circuit(libqasm_ir_creator.squirrel_ir_from_string(cqasm3_string))\n\n        return Circuit(\n            opensquirrel.parsing.antlr.squirrel_ir_from_string.squirrel_ir_from_string(\n                cqasm3_string, gate_set=gate_set, gate_aliases=gate_aliases\n            )\n        )\n\n    @property\n    def number_of_qubits(self) -&gt; int:\n        return self.squirrel_ir.number_of_qubits\n\n    @property\n    def qubit_register_name(self) -&gt; str:\n        return self.squirrel_ir.qubit_register_name\n\n    def decompose_mckay(self):\n        \"\"\"Perform gate fusion on all one-qubit gates and decompose them in the McKay style.\n\n        * all one-qubit gates on same qubit are merged together, without attempting to commute any gate\n        * two-or-more-qubit gates are left as-is\n        * merged one-qubit gates are decomposed according to McKay decomposition, that is:\n                gate   ----&gt;    Rz.Rx(pi/2).Rz.Rx(pi/2).Rz\n        * _global phase is deemed irrelevant_, therefore a simulator backend might produce different output\n            for the input and output circuit - those outputs should be equivalent modulo global phase.\n        \"\"\"\n\n        self.squirrel_ir = mckay_decomposer.decompose_mckay(self.squirrel_ir)  # FIXME: inplace\n\n    def replace(self, gate_name: str, f):\n        \"\"\"Manually replace occurrences of a given gate with a list of gates.\n\n        * this can be called decomposition - but it's the least fancy version of it\n        * function parameter gives the decomposition based on parameters of original gate\n        \"\"\"\n\n        replacer.replace(self.squirrel_ir, gate_name, f)\n\n    def test_get_circuit_matrix(self) -&gt; np.ndarray:\n        \"\"\"Get the (large) unitary matrix corresponding to the circuit.\n\n        * this matrix has 4**n elements, where n is the number of qubits\n        * therefore this function is only here for testing purposes on small number of qubits\n        * result is stored as a numpy array of complex numbers\n        \"\"\"\n\n        return circuit_matrix_calculator.get_circuit_matrix(self.squirrel_ir)\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Write the circuit to a cQasm3 string.\n\n        * comments are removed\n        \"\"\"\n\n        return writer.squirrel_ir_to_string(self.squirrel_ir)\n</code></pre>"},{"location":"reference/#opensquirrel.circuit.Circuit.__init__","title":"<code>__init__(squirrel_ir)</code>","text":"<p>Create a circuit object from a SquirrelIR object.</p> Source code in <code>opensquirrel\\circuit.py</code> <pre><code>def __init__(self, squirrel_ir: SquirrelIR):\n    \"\"\"Create a circuit object from a SquirrelIR object.\"\"\"\n\n    self.squirrel_ir = squirrel_ir\n</code></pre>"},{"location":"reference/#opensquirrel.circuit.Circuit.__repr__","title":"<code>__repr__()</code>","text":"<p>Write the circuit to a cQasm3 string.</p> <ul> <li>comments are removed</li> </ul> Source code in <code>opensquirrel\\circuit.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Write the circuit to a cQasm3 string.\n\n    * comments are removed\n    \"\"\"\n\n    return writer.squirrel_ir_to_string(self.squirrel_ir)\n</code></pre>"},{"location":"reference/#opensquirrel.circuit.Circuit.decompose_mckay","title":"<code>decompose_mckay()</code>","text":"<p>Perform gate fusion on all one-qubit gates and decompose them in the McKay style.</p> <ul> <li>all one-qubit gates on same qubit are merged together, without attempting to commute any gate</li> <li>two-or-more-qubit gates are left as-is</li> <li>merged one-qubit gates are decomposed according to McKay decomposition, that is:         gate   ----&gt;    Rz.Rx(pi/2).Rz.Rx(pi/2).Rz</li> <li>global phase is deemed irrelevant, therefore a simulator backend might produce different output     for the input and output circuit - those outputs should be equivalent modulo global phase.</li> </ul> Source code in <code>opensquirrel\\circuit.py</code> <pre><code>def decompose_mckay(self):\n    \"\"\"Perform gate fusion on all one-qubit gates and decompose them in the McKay style.\n\n    * all one-qubit gates on same qubit are merged together, without attempting to commute any gate\n    * two-or-more-qubit gates are left as-is\n    * merged one-qubit gates are decomposed according to McKay decomposition, that is:\n            gate   ----&gt;    Rz.Rx(pi/2).Rz.Rx(pi/2).Rz\n    * _global phase is deemed irrelevant_, therefore a simulator backend might produce different output\n        for the input and output circuit - those outputs should be equivalent modulo global phase.\n    \"\"\"\n\n    self.squirrel_ir = mckay_decomposer.decompose_mckay(self.squirrel_ir)  # FIXME: inplace\n</code></pre>"},{"location":"reference/#opensquirrel.circuit.Circuit.from_string","title":"<code>from_string(cqasm3_string, gate_set=default_gate_set, gate_aliases=default_gate_aliases, use_libqasm=False)</code>  <code>classmethod</code>","text":"<p>Create a circuit object from a cQasm3 string. All the gates in the circuit need to be defined in the <code>gates</code> argument.</p> <ul> <li>type-checking is performed, eliminating qubit indices errors and incoherencies</li> <li>checks that used gates are supported and mentioned in <code>gates</code> with appropriate signatures</li> <li>does not support map or variables, and other things...</li> <li>for example of <code>gates</code> dictionary, please look at TestGates.py</li> </ul> <p>Parameters:</p> Name Type Description Default <code>cqasm3_string</code> <code>str</code> <p>a cqasm 3 string</p> required <code>gate_set</code> <code>[Callable[..., Gate]]</code> <p>an array of gate semantic functions. See default_gates for examples</p> <code>default_gate_set</code> <code>gate_aliases</code> <code>Dict[str, Callable[..., Gate]]</code> <p>a dictionary of extra aliases, mapping strings to functions in the gate set</p> <code>default_gate_aliases</code> <code>use_libqasm</code> <code>bool</code> <p>if True, use libqasm instead of build-in ANTLR parser. Note: those two separate implementations may diverge and libqasm should be taken as reference.</p> <code>False</code> <p>Returns:</p> Type Description <p>A Circuit object corresponding to the input string. Throws on parsing errors.</p> Source code in <code>opensquirrel\\circuit.py</code> <pre><code>@classmethod\ndef from_string(\n    cls,\n    cqasm3_string: str,\n    gate_set: [Callable[..., Gate]] = default_gate_set,\n    gate_aliases: Dict[str, Callable[..., Gate]] = default_gate_aliases,\n    use_libqasm: bool = False,\n):\n    \"\"\"Create a circuit object from a cQasm3 string. All the gates in the circuit need to be defined in\n    the `gates` argument.\n\n    * type-checking is performed, eliminating qubit indices errors and incoherencies\n    * checks that used gates are supported and mentioned in `gates` with appropriate signatures\n    * does not support map or variables, and other things...\n    * for example of `gates` dictionary, please look at TestGates.py\n\n\n    Args:\n        cqasm3_string: a cqasm 3 string\n        gate_set: an array of gate semantic functions. See default_gates for examples\n        gate_aliases: a dictionary of extra aliases, mapping strings to functions in the gate set\n        use_libqasm: if True, use libqasm instead of build-in ANTLR parser.\n            Note: those two separate implementations may diverge and libqasm should be taken as reference.\n\n    Returns:\n        A Circuit object corresponding to the input string. Throws on parsing errors.\n    \"\"\"\n\n    if use_libqasm:\n        libqasm_ir_creator = LibqasmIRCreator(gate_set=gate_set, gate_aliases=gate_aliases)\n        return Circuit(libqasm_ir_creator.squirrel_ir_from_string(cqasm3_string))\n\n    return Circuit(\n        opensquirrel.parsing.antlr.squirrel_ir_from_string.squirrel_ir_from_string(\n            cqasm3_string, gate_set=gate_set, gate_aliases=gate_aliases\n        )\n    )\n</code></pre>"},{"location":"reference/#opensquirrel.circuit.Circuit.replace","title":"<code>replace(gate_name, f)</code>","text":"<p>Manually replace occurrences of a given gate with a list of gates.</p> <ul> <li>this can be called decomposition - but it's the least fancy version of it</li> <li>function parameter gives the decomposition based on parameters of original gate</li> </ul> Source code in <code>opensquirrel\\circuit.py</code> <pre><code>def replace(self, gate_name: str, f):\n    \"\"\"Manually replace occurrences of a given gate with a list of gates.\n\n    * this can be called decomposition - but it's the least fancy version of it\n    * function parameter gives the decomposition based on parameters of original gate\n    \"\"\"\n\n    replacer.replace(self.squirrel_ir, gate_name, f)\n</code></pre>"},{"location":"reference/#opensquirrel.circuit.Circuit.test_get_circuit_matrix","title":"<code>test_get_circuit_matrix()</code>","text":"<p>Get the (large) unitary matrix corresponding to the circuit.</p> <ul> <li>this matrix has 4**n elements, where n is the number of qubits</li> <li>therefore this function is only here for testing purposes on small number of qubits</li> <li>result is stored as a numpy array of complex numbers</li> </ul> Source code in <code>opensquirrel\\circuit.py</code> <pre><code>def test_get_circuit_matrix(self) -&gt; np.ndarray:\n    \"\"\"Get the (large) unitary matrix corresponding to the circuit.\n\n    * this matrix has 4**n elements, where n is the number of qubits\n    * therefore this function is only here for testing purposes on small number of qubits\n    * result is stored as a numpy array of complex numbers\n    \"\"\"\n\n    return circuit_matrix_calculator.get_circuit_matrix(self.squirrel_ir)\n</code></pre>"},{"location":"reference/#opensquirrel.circuit_builder.CircuitBuilder","title":"<code>CircuitBuilder</code>","text":"<p>             Bases: <code>GateLibrary</code></p> <p>A class using the builder pattern to make construction of circuits easy from Python. Adds corresponding gate when a method is called. Checks gates are known and called with the right arguments. Mainly here to allow for Qiskit-style circuit construction:</p> <p>CircuitBuilder(number_of_qubits=3).h(Qubit(0)).cnot(Qubit(0), Qubit(1)).cnot(Qubit(0), Qubit(2)).to_circuit() version 3.0  qubit[3] q  h q[0] cnot q[0], q[1] cnot q[0], q[2]  Source code in <code>opensquirrel\\circuit_builder.py</code> <pre><code>class CircuitBuilder(GateLibrary):\n    \"\"\"\n    A class using the builder pattern to make construction of circuits easy from Python.\n    Adds corresponding gate when a method is called. Checks gates are known and called with the right arguments.\n    Mainly here to allow for Qiskit-style circuit construction:\n\n    &gt;&gt;&gt; CircuitBuilder(number_of_qubits=3).h(Qubit(0)).cnot(Qubit(0), Qubit(1)).cnot(Qubit(0), Qubit(2)).to_circuit()\n    version 3.0\n    &lt;BLANKLINE&gt;\n    qubit[3] q\n    &lt;BLANKLINE&gt;\n    h q[0]\n    cnot q[0], q[1]\n    cnot q[0], q[2]\n    &lt;BLANKLINE&gt;\n    \"\"\"\n\n    _default_qubit_register_name = \"q\"\n\n    def __init__(\n        self,\n        number_of_qubits: int,\n        gate_set: [Callable[..., Gate]] = default_gate_set,\n        gate_aliases: Dict[str, Callable[..., Gate]] = default_gate_aliases,\n    ):\n        GateLibrary.__init__(self, gate_set, gate_aliases)\n        self.squirrel_ir = SquirrelIR(\n            number_of_qubits=number_of_qubits, qubit_register_name=self._default_qubit_register_name\n        )\n\n    def __getattr__(self, attr):\n        def add_comment(comment_string: str):\n            self.squirrel_ir.add_comment(Comment(comment_string))\n            return self\n\n        def add_this_gate(*args):\n            generator_f = GateLibrary.get_gate_f(self, attr)\n\n            for i, par in enumerate(inspect.signature(generator_f).parameters.values()):\n                if not isinstance(args[i], par.annotation):\n                    raise TypeError(\n                        f\"Wrong argument type for gate `{attr}`, got {type(args[i])} but expected {par.annotation}\"\n                    )\n\n            self.squirrel_ir.add_gate(generator_f(*args))\n            return self\n\n        return add_comment if attr == \"comment\" else add_this_gate\n\n    def to_circuit(self) -&gt; Circuit:\n        return Circuit(self.squirrel_ir)\n</code></pre>"},{"location":"reference/#opensquirrel.circuit_matrix_calculator.get_circuit_matrix","title":"<code>get_circuit_matrix(squirrel_ir)</code>","text":"<p>Compute the Numpy unitary matrix corresponding to the circuit. The size of this matrix grows exponentially with the number of qubits.</p> Source code in <code>opensquirrel\\circuit_matrix_calculator.py</code> <pre><code>def get_circuit_matrix(squirrel_ir: SquirrelIR):\n    \"\"\"\n    Compute the Numpy unitary matrix corresponding to the circuit.\n    The size of this matrix grows exponentially with the number of qubits.\n    \"\"\"\n\n    impl = _CircuitMatrixCalculator(squirrel_ir.number_of_qubits)\n\n    squirrel_ir.accept(impl)\n\n    return impl.matrix\n</code></pre>"},{"location":"reference/#opensquirrel.parsing.antlr.qubit_range_checker.QubitRangeChecker","title":"<code>QubitRangeChecker</code>","text":"<p>             Bases: <code>CQasm3Visitor</code></p> <p>This class checks that all qubit indices make sense in an ANTLR parse tree. It is an instance of the ANTLR abstract syntax tree visitor class. Therefore, method names are fixed and based on rule names in the Grammar .g4 file.</p> Source code in <code>opensquirrel\\parsing\\antlr\\qubit_range_checker.py</code> <pre><code>class QubitRangeChecker(CQasm3Visitor.CQasm3Visitor):\n    \"\"\"\n    This class checks that all qubit indices make sense in an ANTLR parse tree.\n    It is an instance of the ANTLR abstract syntax tree visitor class.\n    Therefore, method names are fixed and based on rule names in the Grammar .g4 file.\n    \"\"\"\n\n    def __init__(self):\n        self.number_of_qubits = 0\n\n    def visitProg(self, ctx):\n        self.visit(ctx.qubitRegisterDeclaration())\n        for gate_application in ctx.gateApplication():\n            self.visit(gate_application)\n\n    def visitQubitRegisterDeclaration(self, ctx):\n        self.number_of_qubits = int(str(ctx.INT()))\n\n    def visitGateApplication(self, ctx):\n        visited_args = (self.visit(arg) for arg in ctx.expr())\n        qubit_argument_sizes = [qubit_range_size for qubit_range_size in visited_args if qubit_range_size is not None]\n\n        if len(qubit_argument_sizes) &gt; 0 and not all(s == qubit_argument_sizes[0] for s in qubit_argument_sizes):\n            raise Exception(\"Invalid gate call with qubit arguments of different sizes\")\n\n    def visitQubit(self, ctx):\n        qubit_index = int(str(ctx.INT()))\n        if qubit_index &gt;= self.number_of_qubits:\n            raise Exception(f\"Qubit index {qubit_index} out of range\")\n\n        return 1\n\n    def visitQubits(self, ctx):\n        qubit_indices = list(map(int, map(str, ctx.INT())))\n        for qubit_index in qubit_indices:\n            if qubit_index &gt;= self.number_of_qubits:\n                raise Exception(f\"Qubit index {qubit_index} out of range\")\n\n        return len(qubit_indices)\n\n    def visitQubitRange(self, ctx):\n        first_qubit_index = int(str(ctx.INT(0)))\n        last_qubit_index = int(str(ctx.INT(1)))\n\n        if first_qubit_index &gt; last_qubit_index:\n            raise Exception(f\"Qubit index range {first_qubit_index}:{last_qubit_index} malformed\")\n\n        if max(first_qubit_index, last_qubit_index) &gt;= self.number_of_qubits:\n            raise Exception(f\"Qubit index range {first_qubit_index}:{last_qubit_index} out of range\")\n\n        return last_qubit_index - first_qubit_index + 1\n\n    def visitIntLiteral(self, ctx):\n        return None\n\n    def visitNegatedIntLiteral(self, ctx):\n        return None\n\n    def visitFloatLiteral(self, ctx):\n        return None\n\n    def visitNegatedFloatLiteral(self, ctx):\n        return None\n</code></pre>"},{"location":"reference/#opensquirrel.parsing.antlr.squirrel_ir_creator.SquirrelIRCreator","title":"<code>SquirrelIRCreator</code>","text":"<p>             Bases: <code>GateLibrary</code>, <code>CQasm3Visitor</code></p> <p>This class creates a SquirrelIR object from an ANTLR parse tree. It is an instance of the ANTLR abstract syntax tree visitor class. Therefore, method names are fixed and based on rule names in the Grammar .g4 file.</p> Source code in <code>opensquirrel\\parsing\\antlr\\squirrel_ir_creator.py</code> <pre><code>class SquirrelIRCreator(GateLibrary, CQasm3Visitor.CQasm3Visitor):\n    \"\"\"\n    This class creates a SquirrelIR object from an ANTLR parse tree.\n    It is an instance of the ANTLR abstract syntax tree visitor class.\n    Therefore, method names are fixed and based on rule names in the Grammar .g4 file.\n    \"\"\"\n\n    def __init__(self, gate_set=default_gate_set, gate_aliases=default_gate_aliases):\n        GateLibrary.__init__(self, gate_set, gate_aliases)\n        self.squirrel_ir = None\n\n    def visitProg(self, ctx):\n        number_of_qubits, qubit_register_name = self.visit(ctx.qubitRegisterDeclaration())\n\n        self.squirrel_ir = SquirrelIR(number_of_qubits=number_of_qubits, qubit_register_name=qubit_register_name)\n\n        for gate_application in ctx.gateApplication():\n            self.visit(gate_application)\n\n        return self.squirrel_ir\n\n    def visitGateApplication(self, ctx):\n        gate_name = str(ctx.ID())\n\n        generator_f = GateLibrary.get_gate_f(self, gate_name)\n        parameters = inspect.signature(generator_f).parameters\n\n        number_of_operands = next(\n            len(self.visit(ctx.expr(i))) for i, par in enumerate(parameters.values()) if par.annotation == Qubit\n        )\n\n        # The below is for handling e.g. `cr q[1:3], q[5:7], 1.23`\n        expanded_args = [\n            self.visit(ctx.expr(i)) if par.annotation == Qubit else [self.visit(ctx.expr(i))] * number_of_operands\n            for i, par in enumerate(parameters.values())\n        ]\n\n        for individual_args in zip(*expanded_args):\n            self.squirrel_ir.add_gate(generator_f(*individual_args))\n\n    def visitQubitRegisterDeclaration(self, ctx):\n        return int(str(ctx.INT())), str(ctx.ID())\n\n    def visitQubit(self, ctx):\n        return [Qubit(int(str(ctx.INT())))]\n\n    def visitQubits(self, ctx):\n        return list(map(Qubit, map(int, map(str, ctx.INT()))))\n\n    def visitQubitRange(self, ctx):\n        first_qubit_index = int(str(ctx.INT(0)))\n        last_qubit_index = int(str(ctx.INT(1)))\n        return list(map(Qubit, range(first_qubit_index, last_qubit_index + 1)))\n\n    def visitFloatLiteral(self, ctx):\n        return Float(float(str(ctx.FLOAT())))\n\n    def visitNegatedFloatLiteral(self, ctx):\n        return Float(-float(str(ctx.FLOAT())))\n\n    def visitIntLiteral(self, ctx):\n        return Int(int(str(ctx.INT())))\n\n    def visitNegatedIntLiteral(self, ctx):\n        return Int(-int(str(ctx.INT())))\n</code></pre>"},{"location":"reference/#opensquirrel.parsing.antlr.squirrel_ir_from_string.squirrel_ir_from_string","title":"<code>squirrel_ir_from_string(s, gate_set, gate_aliases)</code>","text":"<p>ANTLR parsing entrypoint. Performs type checking based on provided gate semantics and check that the qubit indices are valid. Creates the IR where each gate node is mapped to its semantic function and arguments.</p> <p>Parameters:</p> Name Type Description Default <code>gate_set</code> <p>The set of supported gate semantics.</p> required <code>gate_aliases</code> <p>Dictionary mapping extra gate names to their semantic.</p> required <p>Returns:</p> Type Description <p>A corresponding SquirrelIR object. Throws in case of parsing error.</p> Source code in <code>opensquirrel\\parsing\\antlr\\squirrel_ir_from_string.py</code> <pre><code>def squirrel_ir_from_string(s: str, gate_set, gate_aliases):\n    \"\"\"\n    ANTLR parsing entrypoint.\n    Performs type checking based on provided gate semantics and check that the qubit indices are valid.\n    Creates the IR where each gate node is mapped to its semantic function and arguments.\n\n    Args:\n        gate_set: The set of supported gate semantics.\n        gate_aliases: Dictionary mapping extra gate names to their semantic.\n\n    Returns:\n        A corresponding SquirrelIR object. Throws in case of parsing error.\n    \"\"\"\n    tree = antlr_tree_from_string(s)\n\n    type_check_antlr_tree(tree, gate_set=gate_set, gate_aliases=gate_aliases)\n\n    check_qubit_ranges_of_antlr_tree(tree)\n\n    squirrel_ir_creator = SquirrelIRCreator(gate_set=gate_set, gate_aliases=gate_aliases)\n\n    return squirrel_ir_creator.visit(tree)\n</code></pre>"},{"location":"reference/#opensquirrel.parsing.antlr.type_checker.TypeChecker","title":"<code>TypeChecker</code>","text":"<p>             Bases: <code>GateLibrary</code>, <code>CQasm3Visitor</code></p> <p>This class checks that all gate parameter types make sense in an ANTLR parse tree. It is an instance of the ANTLR abstract syntax tree visitor class. Therefore, method names are fixed and based on rule names in the Grammar .g4 file.</p> Source code in <code>opensquirrel\\parsing\\antlr\\type_checker.py</code> <pre><code>class TypeChecker(GateLibrary, CQasm3Visitor.CQasm3Visitor):\n    \"\"\"\n    This class checks that all gate parameter types make sense in an ANTLR parse tree.\n    It is an instance of the ANTLR abstract syntax tree visitor class.\n    Therefore, method names are fixed and based on rule names in the Grammar .g4 file.\n    \"\"\"\n\n    def __init__(self, gate_set=default_gate_set, gate_aliases=default_gate_aliases):\n        GateLibrary.__init__(self, gate_set, gate_aliases)\n        self.qubit_register_name = None\n\n    def visitProg(self, ctx):\n        self.visit(ctx.qubitRegisterDeclaration())\n        for gate_application in ctx.gateApplication():\n            self.visit(gate_application)\n\n    def visitQubitRegisterDeclaration(self, ctx):\n        self.qubit_register_name = str(ctx.ID())\n\n    def visitGateApplication(self, ctx):\n        # Check that the types of the operands match the gate generator function.\n        gate_name = str(ctx.ID())\n        generator_f = GateLibrary.get_gate_f(self, gate_name)\n\n        parameters = inspect.signature(generator_f).parameters\n\n        if len(ctx.expr()) &gt; len(parameters):\n            raise Exception(f\"Gate `{gate_name}` takes {len(parameters)} arguments, but {len(ctx.expr())} were given!\")\n\n        for i, param in enumerate(parameters.values()):\n            actual_type = self.visit(ctx.expr(i))\n            expected_type = param.annotation\n            if actual_type != expected_type:\n                raise Exception(\n                    f\"Argument #{i} passed to gate `{gate_name}` is of type\"\n                    f\" {actual_type} but should be {expected_type}\"\n                )\n\n    def visitQubit(self, ctx):\n        if str(ctx.ID()) != self.qubit_register_name:\n            raise Exception(f\"Qubit register {str(ctx.ID())} not declared\")\n\n        return Qubit\n\n    def visitQubits(self, ctx):\n        if str(ctx.ID()) != self.qubit_register_name:\n            raise Exception(f\"Qubit register {str(ctx.ID())} not declared\")\n\n        return Qubit\n\n    def visitQubitRange(self, ctx):\n        if str(ctx.ID()) != self.qubit_register_name:\n            raise Exception(f\"Qubit register {str(ctx.ID())} not declared\")\n\n        return Qubit\n\n    def visitIntLiteral(self, ctx):\n        return Int\n\n    def visitNegatedIntLiteral(self, ctx):\n        return Int\n\n    def visitFloatLiteral(self, ctx):\n        return Float\n\n    def visitNegatedFloatLiteral(self, ctx):\n        return Float\n</code></pre>"},{"location":"reference/#opensquirrel.utils.matrix_expander.expand_ket","title":"<code>expand_ket(base_ket, reduced_ket, qubits)</code>","text":"<p>Given a base quantum ket on n qubits and a reduced ket on a subset of those qubits, this computes the expanded ket where the reduction qubits and the other qubits are set based on the reduced ket and the base ket, respectively. Roughly equivalent to the <code>pdep</code> assembly instruction (bits deposit).</p> <p>Parameters:</p> Name Type Description Default <code>base_ket</code> <code>int</code> <p>A quantum ket, represented by its corresponding non-negative integer.       By convention, qubit #0 corresponds to the least significant bit.</p> required <code>reduced_ket</code> <code>int</code> <p>A quantum ket, represented by its corresponding non-negative integer.          By convention, qubit #0 corresponds to the least significant bit.</p> required <code>qubits</code> <code>List[Qubit]</code> <p>The indices of the qubits to expand from the reduced ket. Order matters.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The non-negative integer corresponding to the expanded ket.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; expand_ket(0b00000, 0b0, [Qubit(5)])   # 0b000000\n0\n&gt;&gt;&gt; expand_ket(0b00000, 0b1, [Qubit(5)])   # 0b100000\n32\n&gt;&gt;&gt; expand_ket(0b00111, 0b0, [Qubit(5)])   # 0b000111\n7\n&gt;&gt;&gt; expand_ket(0b00111, 0b1, [Qubit(5)])   # 0b100111\n39\n&gt;&gt;&gt; expand_ket(0b0000, 0b000, [Qubit(1), Qubit(2), Qubit(3)])    # 0b0000\n0\n&gt;&gt;&gt; expand_ket(0b0000, 0b001, [Qubit(1), Qubit(2), Qubit(3)])    # 0b0010\n2\n&gt;&gt;&gt; expand_ket(0b0000, 0b011, [Qubit(1), Qubit(2), Qubit(3)])    # 0b0110\n6\n&gt;&gt;&gt; expand_ket(0b0000, 0b101, [Qubit(1), Qubit(2), Qubit(3)])   # 0b1010\n10\n&gt;&gt;&gt; expand_ket(0b0001, 0b101, [Qubit(1), Qubit(2), Qubit(3)])   # 0b1011\n11\n</code></pre> Source code in <code>opensquirrel\\utils\\matrix_expander.py</code> <pre><code>def expand_ket(base_ket: int, reduced_ket: int, qubits: List[Qubit]) -&gt; int:\n    \"\"\"\n    Given a base quantum ket on n qubits and a reduced ket on a subset of those qubits, this computes the expanded ket\n    where the reduction qubits and the other qubits are set based on the reduced ket and the base ket, respectively.\n    Roughly equivalent to the `pdep` assembly instruction (bits deposit).\n\n    Args:\n        base_ket: A quantum ket, represented by its corresponding non-negative integer.\n                  By convention, qubit #0 corresponds to the least significant bit.\n        reduced_ket: A quantum ket, represented by its corresponding non-negative integer.\n                     By convention, qubit #0 corresponds to the least significant bit.\n        qubits: The indices of the qubits to expand from the reduced ket. Order matters.\n\n    Returns:\n        The non-negative integer corresponding to the expanded ket.\n\n    Examples:\n        &gt;&gt;&gt; expand_ket(0b00000, 0b0, [Qubit(5)])   # 0b000000\n        0\n        &gt;&gt;&gt; expand_ket(0b00000, 0b1, [Qubit(5)])   # 0b100000\n        32\n        &gt;&gt;&gt; expand_ket(0b00111, 0b0, [Qubit(5)])   # 0b000111\n        7\n        &gt;&gt;&gt; expand_ket(0b00111, 0b1, [Qubit(5)])   # 0b100111\n        39\n        &gt;&gt;&gt; expand_ket(0b0000, 0b000, [Qubit(1), Qubit(2), Qubit(3)])    # 0b0000\n        0\n        &gt;&gt;&gt; expand_ket(0b0000, 0b001, [Qubit(1), Qubit(2), Qubit(3)])    # 0b0010\n        2\n        &gt;&gt;&gt; expand_ket(0b0000, 0b011, [Qubit(1), Qubit(2), Qubit(3)])    # 0b0110\n        6\n        &gt;&gt;&gt; expand_ket(0b0000, 0b101, [Qubit(1), Qubit(2), Qubit(3)])   # 0b1010\n        10\n        &gt;&gt;&gt; expand_ket(0b0001, 0b101, [Qubit(1), Qubit(2), Qubit(3)])   # 0b1011\n        11\n    \"\"\"\n    expanded_ket = base_ket\n    for i, qubit in enumerate(qubits):\n        expanded_ket &amp;= ~(1 &lt;&lt; qubit.index)  # Erase bit.\n        expanded_ket |= ((reduced_ket &amp; (1 &lt;&lt; i)) &gt;&gt; i) &lt;&lt; qubit.index  # Set bit to value from reduced_ket.\n\n    return expanded_ket\n</code></pre>"},{"location":"reference/#opensquirrel.utils.matrix_expander.get_matrix","title":"<code>get_matrix(gate, number_of_qubits)</code>","text":"<p>Compute the unitary matrix corresponding to the gate applied to those qubit operands, taken among any number of qubits. This can be used for, e.g., - testing, - permuting the operands of multi-qubit gates, - simulating a circuit (simulation in this way is inefficient for large numbers of qubits).</p> <p>Parameters:</p> Name Type Description Default <code>gate</code> <code>Gate</code> <p>The gate, including the qubits on which it is operated on.</p> required <code>number_of_qubits</code> <code>int</code> <p>The total number of qubits.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; X = lambda q: BlochSphereRotation(qubit=q, axis=(1, 0, 0), angle=math.pi, phase=math.pi / 2)\n&gt;&gt;&gt; get_matrix(X(Qubit(1)), 2).astype(int)           # X q[1]\narray([[0, 0, 1, 0],\n       [0, 0, 0, 1],\n       [1, 0, 0, 0],\n       [0, 1, 0, 0]])\n</code></pre> <pre><code>&gt;&gt;&gt; CNOT02 = ControlledGate(Qubit(0), X(Qubit(2)))\n&gt;&gt;&gt; get_matrix(CNOT02, 3).astype(int)     # CNOT q[0], q[2]\narray([[1, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 1, 0, 0],\n       [0, 0, 1, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 1],\n       [0, 0, 0, 0, 1, 0, 0, 0],\n       [0, 1, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 1, 0],\n       [0, 0, 0, 1, 0, 0, 0, 0]])\n&gt;&gt;&gt; get_matrix(ControlledGate(Qubit(1), X(Qubit(2))), 3).astype(int)     # CNOT q[1], q[2]\narray([[1, 0, 0, 0, 0, 0, 0, 0],\n       [0, 1, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 1, 0],\n       [0, 0, 0, 0, 0, 0, 0, 1],\n       [0, 0, 0, 0, 1, 0, 0, 0],\n       [0, 0, 0, 0, 0, 1, 0, 0],\n       [0, 0, 1, 0, 0, 0, 0, 0],\n       [0, 0, 0, 1, 0, 0, 0, 0]])\n</code></pre> Source code in <code>opensquirrel\\utils\\matrix_expander.py</code> <pre><code>def get_matrix(gate: Gate, number_of_qubits: int) -&gt; np.ndarray:\n    \"\"\"\n    Compute the unitary matrix corresponding to the gate applied to those qubit operands, taken among any number of qubits.\n    This can be used for, e.g.,\n    - testing,\n    - permuting the operands of multi-qubit gates,\n    - simulating a circuit (simulation in this way is inefficient for large numbers of qubits).\n\n    Args:\n        gate: The gate, including the qubits on which it is operated on.\n        number_of_qubits: The total number of qubits.\n\n    Examples:\n        &gt;&gt;&gt; X = lambda q: BlochSphereRotation(qubit=q, axis=(1, 0, 0), angle=math.pi, phase=math.pi / 2)\n        &gt;&gt;&gt; get_matrix(X(Qubit(1)), 2).astype(int)           # X q[1]\n        array([[0, 0, 1, 0],\n               [0, 0, 0, 1],\n               [1, 0, 0, 0],\n               [0, 1, 0, 0]])\n\n        &gt;&gt;&gt; CNOT02 = ControlledGate(Qubit(0), X(Qubit(2)))\n        &gt;&gt;&gt; get_matrix(CNOT02, 3).astype(int)     # CNOT q[0], q[2]\n        array([[1, 0, 0, 0, 0, 0, 0, 0],\n               [0, 0, 0, 0, 0, 1, 0, 0],\n               [0, 0, 1, 0, 0, 0, 0, 0],\n               [0, 0, 0, 0, 0, 0, 0, 1],\n               [0, 0, 0, 0, 1, 0, 0, 0],\n               [0, 1, 0, 0, 0, 0, 0, 0],\n               [0, 0, 0, 0, 0, 0, 1, 0],\n               [0, 0, 0, 1, 0, 0, 0, 0]])\n        &gt;&gt;&gt; get_matrix(ControlledGate(Qubit(1), X(Qubit(2))), 3).astype(int)     # CNOT q[1], q[2]\n        array([[1, 0, 0, 0, 0, 0, 0, 0],\n               [0, 1, 0, 0, 0, 0, 0, 0],\n               [0, 0, 0, 0, 0, 0, 1, 0],\n               [0, 0, 0, 0, 0, 0, 0, 1],\n               [0, 0, 0, 0, 1, 0, 0, 0],\n               [0, 0, 0, 0, 0, 1, 0, 0],\n               [0, 0, 1, 0, 0, 0, 0, 0],\n               [0, 0, 0, 1, 0, 0, 0, 0]])\n    \"\"\"\n\n    expander = MatrixExpander(number_of_qubits)\n    return gate.accept(expander)\n</code></pre>"},{"location":"reference/#opensquirrel.utils.matrix_expander.get_reduced_ket","title":"<code>get_reduced_ket(ket, qubits)</code>","text":"<p>Given a quantum ket represented by its corresponding base-10 integer, this computes the reduced ket where only the given qubits appear, in order. Roughly equivalent to the <code>pext</code> assembly instruction (bits extraction).</p> <p>Parameters:</p> Name Type Description Default <code>ket</code> <code>int</code> <p>A quantum ket, represented by its corresponding non-negative integer.  By convention, qubit #0 corresponds to the least significant bit.</p> required <code>qubits</code> <code>List[Qubit]</code> <p>The indices of the qubits to extract. Order matters.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The non-negative integer corresponding to the reduced ket.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; get_reduced_ket(1, [Qubit(0)])         # 0b01\n1\n&gt;&gt;&gt; get_reduced_ket(1111, [Qubit(2)])      # 0b01\n1\n&gt;&gt;&gt; get_reduced_ket(1111, [Qubit(5)])      # 0b0\n0\n&gt;&gt;&gt; get_reduced_ket(1111, [Qubit(2), Qubit(5)])   # 0b01\n1\n&gt;&gt;&gt; get_reduced_ket(101, [Qubit(1), Qubit(0)])    # 0b10\n2\n&gt;&gt;&gt; get_reduced_ket(101, [Qubit(0), Qubit(1)])    # 0b01\n1\n</code></pre> Source code in <code>opensquirrel\\utils\\matrix_expander.py</code> <pre><code>def get_reduced_ket(ket: int, qubits: List[Qubit]) -&gt; int:\n    \"\"\"\n    Given a quantum ket represented by its corresponding base-10 integer, this computes the reduced ket\n    where only the given qubits appear, in order.\n    Roughly equivalent to the `pext` assembly instruction (bits extraction).\n\n    Args:\n        ket: A quantum ket, represented by its corresponding non-negative integer.\n             By convention, qubit #0 corresponds to the least significant bit.\n        qubits: The indices of the qubits to extract. Order matters.\n\n    Returns:\n        The non-negative integer corresponding to the reduced ket.\n\n    Examples:\n        &gt;&gt;&gt; get_reduced_ket(1, [Qubit(0)])         # 0b01\n        1\n        &gt;&gt;&gt; get_reduced_ket(1111, [Qubit(2)])      # 0b01\n        1\n        &gt;&gt;&gt; get_reduced_ket(1111, [Qubit(5)])      # 0b0\n        0\n        &gt;&gt;&gt; get_reduced_ket(1111, [Qubit(2), Qubit(5)])   # 0b01\n        1\n        &gt;&gt;&gt; get_reduced_ket(101, [Qubit(1), Qubit(0)])    # 0b10\n        2\n        &gt;&gt;&gt; get_reduced_ket(101, [Qubit(0), Qubit(1)])    # 0b01\n        1\n    \"\"\"\n    reduced_ket = 0\n    for i, qubit in enumerate(qubits):\n        reduced_ket |= ((ket &amp; (1 &lt;&lt; qubit.index)) &gt;&gt; qubit.index) &lt;&lt; i\n\n    return reduced_ket\n</code></pre>"},{"location":"tutorials/","title":"Tutorials","text":"<p>The purpose of a tutorial is to provide the user with a successful learning experience.</p>"},{"location":"C%3A/Users/plehenaff/PycharmProjects/OpenSquirrel/docs/reference/","title":"Reference","text":""},{"location":"C%3A/Users/plehenaff/PycharmProjects/OpenSquirrel/docs/reference/#opensquirrel.circuit.Circuit","title":"<code>Circuit</code>","text":"<p>The Circuit class is the only interface to access OpenSquirrel's features.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; c = Circuit.from_string(\"version 3.0; qubit[3] q; h q[0]\")\n&gt;&gt;&gt; c\nversion 3.0\n\nqubit[3] q\n\nh q[0]\n\n&gt;&gt;&gt; c.decompose_mckay()\n&gt;&gt;&gt; c\nversion 3.0\n\nqubit[3] q\n\nx90 q[0]\nrz q[0], 1.5707963\nx90 q[0]\n</code></pre> Source code in <code>opensquirrel\\circuit.py</code> <pre><code>class Circuit:\n    \"\"\"The Circuit class is the only interface to access OpenSquirrel's features.\n\n    Examples:\n        &gt;&gt;&gt; c = Circuit.from_string(\"version 3.0; qubit[3] q; h q[0]\")\n        &gt;&gt;&gt; c\n        version 3.0\n        &lt;BLANKLINE&gt;\n        qubit[3] q\n        &lt;BLANKLINE&gt;\n        h q[0]\n        &lt;BLANKLINE&gt;\n        &gt;&gt;&gt; c.decompose_mckay()\n        &gt;&gt;&gt; c\n        version 3.0\n        &lt;BLANKLINE&gt;\n        qubit[3] q\n        &lt;BLANKLINE&gt;\n        x90 q[0]\n        rz q[0], 1.5707963\n        x90 q[0]\n        &lt;BLANKLINE&gt;\n    \"\"\"\n\n    def __init__(self, squirrel_ir: SquirrelIR):\n        \"\"\"Create a circuit object from a SquirrelIR object.\"\"\"\n\n        self.squirrel_ir = squirrel_ir\n\n    @classmethod\n    def from_string(\n        cls,\n        cqasm3_string: str,\n        gate_set: [Callable[..., Gate]] = default_gate_set,\n        gate_aliases: Dict[str, Callable[..., Gate]] = default_gate_aliases,\n        use_libqasm: bool = False,\n    ):\n        \"\"\"Create a circuit object from a cQasm3 string. All the gates in the circuit need to be defined in\n        the `gates` argument.\n\n        * type-checking is performed, eliminating qubit indices errors and incoherencies\n        * checks that used gates are supported and mentioned in `gates` with appropriate signatures\n        * does not support map or variables, and other things...\n        * for example of `gates` dictionary, please look at TestGates.py\n\n\n        Args:\n            cqasm3_string: a cqasm 3 string\n            gate_set: an array of gate semantic functions. See default_gates for examples\n            gate_aliases: a dictionary of extra aliases, mapping strings to functions in the gate set\n            use_libqasm: if True, use libqasm instead of build-in ANTLR parser.\n                Note: those two separate implementations may diverge and libqasm should be taken as reference.\n\n        Returns:\n            A Circuit object corresponding to the input string. Throws on parsing errors.\n        \"\"\"\n\n        if use_libqasm:\n            libqasm_ir_creator = LibqasmIRCreator(gate_set=gate_set, gate_aliases=gate_aliases)\n            return Circuit(libqasm_ir_creator.squirrel_ir_from_string(cqasm3_string))\n\n        return Circuit(\n            opensquirrel.parsing.antlr.squirrel_ir_from_string.squirrel_ir_from_string(\n                cqasm3_string, gate_set=gate_set, gate_aliases=gate_aliases\n            )\n        )\n\n    @property\n    def number_of_qubits(self) -&gt; int:\n        return self.squirrel_ir.number_of_qubits\n\n    @property\n    def qubit_register_name(self) -&gt; str:\n        return self.squirrel_ir.qubit_register_name\n\n    def decompose_mckay(self):\n        \"\"\"Perform gate fusion on all one-qubit gates and decompose them in the McKay style.\n\n        * all one-qubit gates on same qubit are merged together, without attempting to commute any gate\n        * two-or-more-qubit gates are left as-is\n        * merged one-qubit gates are decomposed according to McKay decomposition, that is:\n                gate   ----&gt;    Rz.Rx(pi/2).Rz.Rx(pi/2).Rz\n        * _global phase is deemed irrelevant_, therefore a simulator backend might produce different output\n            for the input and output circuit - those outputs should be equivalent modulo global phase.\n        \"\"\"\n\n        self.squirrel_ir = mckay_decomposer.decompose_mckay(self.squirrel_ir)  # FIXME: inplace\n\n    def replace(self, gate_name: str, f):\n        \"\"\"Manually replace occurrences of a given gate with a list of gates.\n\n        * this can be called decomposition - but it's the least fancy version of it\n        * function parameter gives the decomposition based on parameters of original gate\n        \"\"\"\n\n        replacer.replace(self.squirrel_ir, gate_name, f)\n\n    def test_get_circuit_matrix(self) -&gt; np.ndarray:\n        \"\"\"Get the (large) unitary matrix corresponding to the circuit.\n\n        * this matrix has 4**n elements, where n is the number of qubits\n        * therefore this function is only here for testing purposes on small number of qubits\n        * result is stored as a numpy array of complex numbers\n        \"\"\"\n\n        return circuit_matrix_calculator.get_circuit_matrix(self.squirrel_ir)\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Write the circuit to a cQasm3 string.\n\n        * comments are removed\n        \"\"\"\n\n        return writer.squirrel_ir_to_string(self.squirrel_ir)\n</code></pre>"},{"location":"C%3A/Users/plehenaff/PycharmProjects/OpenSquirrel/docs/reference/#opensquirrel.circuit.Circuit.__init__","title":"<code>__init__(squirrel_ir)</code>","text":"<p>Create a circuit object from a SquirrelIR object.</p> Source code in <code>opensquirrel\\circuit.py</code> <pre><code>def __init__(self, squirrel_ir: SquirrelIR):\n    \"\"\"Create a circuit object from a SquirrelIR object.\"\"\"\n\n    self.squirrel_ir = squirrel_ir\n</code></pre>"},{"location":"C%3A/Users/plehenaff/PycharmProjects/OpenSquirrel/docs/reference/#opensquirrel.circuit.Circuit.__repr__","title":"<code>__repr__()</code>","text":"<p>Write the circuit to a cQasm3 string.</p> <ul> <li>comments are removed</li> </ul> Source code in <code>opensquirrel\\circuit.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Write the circuit to a cQasm3 string.\n\n    * comments are removed\n    \"\"\"\n\n    return writer.squirrel_ir_to_string(self.squirrel_ir)\n</code></pre>"},{"location":"C%3A/Users/plehenaff/PycharmProjects/OpenSquirrel/docs/reference/#opensquirrel.circuit.Circuit.decompose_mckay","title":"<code>decompose_mckay()</code>","text":"<p>Perform gate fusion on all one-qubit gates and decompose them in the McKay style.</p> <ul> <li>all one-qubit gates on same qubit are merged together, without attempting to commute any gate</li> <li>two-or-more-qubit gates are left as-is</li> <li>merged one-qubit gates are decomposed according to McKay decomposition, that is:         gate   ----&gt;    Rz.Rx(pi/2).Rz.Rx(pi/2).Rz</li> <li>global phase is deemed irrelevant, therefore a simulator backend might produce different output     for the input and output circuit - those outputs should be equivalent modulo global phase.</li> </ul> Source code in <code>opensquirrel\\circuit.py</code> <pre><code>def decompose_mckay(self):\n    \"\"\"Perform gate fusion on all one-qubit gates and decompose them in the McKay style.\n\n    * all one-qubit gates on same qubit are merged together, without attempting to commute any gate\n    * two-or-more-qubit gates are left as-is\n    * merged one-qubit gates are decomposed according to McKay decomposition, that is:\n            gate   ----&gt;    Rz.Rx(pi/2).Rz.Rx(pi/2).Rz\n    * _global phase is deemed irrelevant_, therefore a simulator backend might produce different output\n        for the input and output circuit - those outputs should be equivalent modulo global phase.\n    \"\"\"\n\n    self.squirrel_ir = mckay_decomposer.decompose_mckay(self.squirrel_ir)  # FIXME: inplace\n</code></pre>"},{"location":"C%3A/Users/plehenaff/PycharmProjects/OpenSquirrel/docs/reference/#opensquirrel.circuit.Circuit.from_string","title":"<code>from_string(cqasm3_string, gate_set=default_gate_set, gate_aliases=default_gate_aliases, use_libqasm=False)</code>  <code>classmethod</code>","text":"<p>Create a circuit object from a cQasm3 string. All the gates in the circuit need to be defined in the <code>gates</code> argument.</p> <ul> <li>type-checking is performed, eliminating qubit indices errors and incoherencies</li> <li>checks that used gates are supported and mentioned in <code>gates</code> with appropriate signatures</li> <li>does not support map or variables, and other things...</li> <li>for example of <code>gates</code> dictionary, please look at TestGates.py</li> </ul> <p>Parameters:</p> Name Type Description Default <code>cqasm3_string</code> <code>str</code> <p>a cqasm 3 string</p> required <code>gate_set</code> <code>[Callable[..., Gate]]</code> <p>an array of gate semantic functions. See default_gates for examples</p> <code>default_gate_set</code> <code>gate_aliases</code> <code>Dict[str, Callable[..., Gate]]</code> <p>a dictionary of extra aliases, mapping strings to functions in the gate set</p> <code>default_gate_aliases</code> <code>use_libqasm</code> <code>bool</code> <p>if True, use libqasm instead of build-in ANTLR parser. Note: those two separate implementations may diverge and libqasm should be taken as reference.</p> <code>False</code> <p>Returns:</p> Type Description <p>A Circuit object corresponding to the input string. Throws on parsing errors.</p> Source code in <code>opensquirrel\\circuit.py</code> <pre><code>@classmethod\ndef from_string(\n    cls,\n    cqasm3_string: str,\n    gate_set: [Callable[..., Gate]] = default_gate_set,\n    gate_aliases: Dict[str, Callable[..., Gate]] = default_gate_aliases,\n    use_libqasm: bool = False,\n):\n    \"\"\"Create a circuit object from a cQasm3 string. All the gates in the circuit need to be defined in\n    the `gates` argument.\n\n    * type-checking is performed, eliminating qubit indices errors and incoherencies\n    * checks that used gates are supported and mentioned in `gates` with appropriate signatures\n    * does not support map or variables, and other things...\n    * for example of `gates` dictionary, please look at TestGates.py\n\n\n    Args:\n        cqasm3_string: a cqasm 3 string\n        gate_set: an array of gate semantic functions. See default_gates for examples\n        gate_aliases: a dictionary of extra aliases, mapping strings to functions in the gate set\n        use_libqasm: if True, use libqasm instead of build-in ANTLR parser.\n            Note: those two separate implementations may diverge and libqasm should be taken as reference.\n\n    Returns:\n        A Circuit object corresponding to the input string. Throws on parsing errors.\n    \"\"\"\n\n    if use_libqasm:\n        libqasm_ir_creator = LibqasmIRCreator(gate_set=gate_set, gate_aliases=gate_aliases)\n        return Circuit(libqasm_ir_creator.squirrel_ir_from_string(cqasm3_string))\n\n    return Circuit(\n        opensquirrel.parsing.antlr.squirrel_ir_from_string.squirrel_ir_from_string(\n            cqasm3_string, gate_set=gate_set, gate_aliases=gate_aliases\n        )\n    )\n</code></pre>"},{"location":"C%3A/Users/plehenaff/PycharmProjects/OpenSquirrel/docs/reference/#opensquirrel.circuit.Circuit.replace","title":"<code>replace(gate_name, f)</code>","text":"<p>Manually replace occurrences of a given gate with a list of gates.</p> <ul> <li>this can be called decomposition - but it's the least fancy version of it</li> <li>function parameter gives the decomposition based on parameters of original gate</li> </ul> Source code in <code>opensquirrel\\circuit.py</code> <pre><code>def replace(self, gate_name: str, f):\n    \"\"\"Manually replace occurrences of a given gate with a list of gates.\n\n    * this can be called decomposition - but it's the least fancy version of it\n    * function parameter gives the decomposition based on parameters of original gate\n    \"\"\"\n\n    replacer.replace(self.squirrel_ir, gate_name, f)\n</code></pre>"},{"location":"C%3A/Users/plehenaff/PycharmProjects/OpenSquirrel/docs/reference/#opensquirrel.circuit.Circuit.test_get_circuit_matrix","title":"<code>test_get_circuit_matrix()</code>","text":"<p>Get the (large) unitary matrix corresponding to the circuit.</p> <ul> <li>this matrix has 4**n elements, where n is the number of qubits</li> <li>therefore this function is only here for testing purposes on small number of qubits</li> <li>result is stored as a numpy array of complex numbers</li> </ul> Source code in <code>opensquirrel\\circuit.py</code> <pre><code>def test_get_circuit_matrix(self) -&gt; np.ndarray:\n    \"\"\"Get the (large) unitary matrix corresponding to the circuit.\n\n    * this matrix has 4**n elements, where n is the number of qubits\n    * therefore this function is only here for testing purposes on small number of qubits\n    * result is stored as a numpy array of complex numbers\n    \"\"\"\n\n    return circuit_matrix_calculator.get_circuit_matrix(self.squirrel_ir)\n</code></pre>"},{"location":"C%3A/Users/plehenaff/PycharmProjects/OpenSquirrel/docs/reference/#opensquirrel.circuit_builder.CircuitBuilder","title":"<code>CircuitBuilder</code>","text":"<p>             Bases: <code>GateLibrary</code></p> <p>A class using the builder pattern to make construction of circuits easy from Python. Adds corresponding gate when a method is called. Checks gates are known and called with the right arguments. Mainly here to allow for Qiskit-style circuit construction:</p> <p>CircuitBuilder(number_of_qubits=3).h(Qubit(0)).cnot(Qubit(0), Qubit(1)).cnot(Qubit(0), Qubit(2)).to_circuit() version 3.0  qubit[3] q  h q[0] cnot q[0], q[1] cnot q[0], q[2]  Source code in <code>opensquirrel\\circuit_builder.py</code> <pre><code>class CircuitBuilder(GateLibrary):\n    \"\"\"\n    A class using the builder pattern to make construction of circuits easy from Python.\n    Adds corresponding gate when a method is called. Checks gates are known and called with the right arguments.\n    Mainly here to allow for Qiskit-style circuit construction:\n\n    &gt;&gt;&gt; CircuitBuilder(number_of_qubits=3).h(Qubit(0)).cnot(Qubit(0), Qubit(1)).cnot(Qubit(0), Qubit(2)).to_circuit()\n    version 3.0\n    &lt;BLANKLINE&gt;\n    qubit[3] q\n    &lt;BLANKLINE&gt;\n    h q[0]\n    cnot q[0], q[1]\n    cnot q[0], q[2]\n    &lt;BLANKLINE&gt;\n    \"\"\"\n\n    _default_qubit_register_name = \"q\"\n\n    def __init__(\n        self,\n        number_of_qubits: int,\n        gate_set: [Callable[..., Gate]] = default_gate_set,\n        gate_aliases: Dict[str, Callable[..., Gate]] = default_gate_aliases,\n    ):\n        GateLibrary.__init__(self, gate_set, gate_aliases)\n        self.squirrel_ir = SquirrelIR(\n            number_of_qubits=number_of_qubits, qubit_register_name=self._default_qubit_register_name\n        )\n\n    def __getattr__(self, attr):\n        def add_comment(comment_string: str):\n            self.squirrel_ir.add_comment(Comment(comment_string))\n            return self\n\n        def add_this_gate(*args):\n            generator_f = GateLibrary.get_gate_f(self, attr)\n\n            for i, par in enumerate(inspect.signature(generator_f).parameters.values()):\n                if not isinstance(args[i], par.annotation):\n                    raise TypeError(\n                        f\"Wrong argument type for gate `{attr}`, got {type(args[i])} but expected {par.annotation}\"\n                    )\n\n            self.squirrel_ir.add_gate(generator_f(*args))\n            return self\n\n        return add_comment if attr == \"comment\" else add_this_gate\n\n    def to_circuit(self) -&gt; Circuit:\n        return Circuit(self.squirrel_ir)\n</code></pre>"},{"location":"C%3A/Users/plehenaff/PycharmProjects/OpenSquirrel/docs/reference/#opensquirrel.circuit_matrix_calculator.get_circuit_matrix","title":"<code>get_circuit_matrix(squirrel_ir)</code>","text":"<p>Compute the Numpy unitary matrix corresponding to the circuit. The size of this matrix grows exponentially with the number of qubits.</p> Source code in <code>opensquirrel\\circuit_matrix_calculator.py</code> <pre><code>def get_circuit_matrix(squirrel_ir: SquirrelIR):\n    \"\"\"\n    Compute the Numpy unitary matrix corresponding to the circuit.\n    The size of this matrix grows exponentially with the number of qubits.\n    \"\"\"\n\n    impl = _CircuitMatrixCalculator(squirrel_ir.number_of_qubits)\n\n    squirrel_ir.accept(impl)\n\n    return impl.matrix\n</code></pre>"},{"location":"C%3A/Users/plehenaff/PycharmProjects/OpenSquirrel/docs/reference/#opensquirrel.parsing.antlr.qubit_range_checker.QubitRangeChecker","title":"<code>QubitRangeChecker</code>","text":"<p>             Bases: <code>CQasm3Visitor</code></p> <p>This class checks that all qubit indices make sense in an ANTLR parse tree. It is an instance of the ANTLR abstract syntax tree visitor class. Therefore, method names are fixed and based on rule names in the Grammar .g4 file.</p> Source code in <code>opensquirrel\\parsing\\antlr\\qubit_range_checker.py</code> <pre><code>class QubitRangeChecker(CQasm3Visitor.CQasm3Visitor):\n    \"\"\"\n    This class checks that all qubit indices make sense in an ANTLR parse tree.\n    It is an instance of the ANTLR abstract syntax tree visitor class.\n    Therefore, method names are fixed and based on rule names in the Grammar .g4 file.\n    \"\"\"\n\n    def __init__(self):\n        self.number_of_qubits = 0\n\n    def visitProg(self, ctx):\n        self.visit(ctx.qubitRegisterDeclaration())\n        for gate_application in ctx.gateApplication():\n            self.visit(gate_application)\n\n    def visitQubitRegisterDeclaration(self, ctx):\n        self.number_of_qubits = int(str(ctx.INT()))\n\n    def visitGateApplication(self, ctx):\n        visited_args = (self.visit(arg) for arg in ctx.expr())\n        qubit_argument_sizes = [qubit_range_size for qubit_range_size in visited_args if qubit_range_size is not None]\n\n        if len(qubit_argument_sizes) &gt; 0 and not all(s == qubit_argument_sizes[0] for s in qubit_argument_sizes):\n            raise Exception(\"Invalid gate call with qubit arguments of different sizes\")\n\n    def visitQubit(self, ctx):\n        qubit_index = int(str(ctx.INT()))\n        if qubit_index &gt;= self.number_of_qubits:\n            raise Exception(f\"Qubit index {qubit_index} out of range\")\n\n        return 1\n\n    def visitQubits(self, ctx):\n        qubit_indices = list(map(int, map(str, ctx.INT())))\n        for qubit_index in qubit_indices:\n            if qubit_index &gt;= self.number_of_qubits:\n                raise Exception(f\"Qubit index {qubit_index} out of range\")\n\n        return len(qubit_indices)\n\n    def visitQubitRange(self, ctx):\n        first_qubit_index = int(str(ctx.INT(0)))\n        last_qubit_index = int(str(ctx.INT(1)))\n\n        if first_qubit_index &gt; last_qubit_index:\n            raise Exception(f\"Qubit index range {first_qubit_index}:{last_qubit_index} malformed\")\n\n        if max(first_qubit_index, last_qubit_index) &gt;= self.number_of_qubits:\n            raise Exception(f\"Qubit index range {first_qubit_index}:{last_qubit_index} out of range\")\n\n        return last_qubit_index - first_qubit_index + 1\n\n    def visitIntLiteral(self, ctx):\n        return None\n\n    def visitNegatedIntLiteral(self, ctx):\n        return None\n\n    def visitFloatLiteral(self, ctx):\n        return None\n\n    def visitNegatedFloatLiteral(self, ctx):\n        return None\n</code></pre>"},{"location":"C%3A/Users/plehenaff/PycharmProjects/OpenSquirrel/docs/reference/#opensquirrel.parsing.antlr.squirrel_ir_creator.SquirrelIRCreator","title":"<code>SquirrelIRCreator</code>","text":"<p>             Bases: <code>GateLibrary</code>, <code>CQasm3Visitor</code></p> <p>This class creates a SquirrelIR object from an ANTLR parse tree. It is an instance of the ANTLR abstract syntax tree visitor class. Therefore, method names are fixed and based on rule names in the Grammar .g4 file.</p> Source code in <code>opensquirrel\\parsing\\antlr\\squirrel_ir_creator.py</code> <pre><code>class SquirrelIRCreator(GateLibrary, CQasm3Visitor.CQasm3Visitor):\n    \"\"\"\n    This class creates a SquirrelIR object from an ANTLR parse tree.\n    It is an instance of the ANTLR abstract syntax tree visitor class.\n    Therefore, method names are fixed and based on rule names in the Grammar .g4 file.\n    \"\"\"\n\n    def __init__(self, gate_set=default_gate_set, gate_aliases=default_gate_aliases):\n        GateLibrary.__init__(self, gate_set, gate_aliases)\n        self.squirrel_ir = None\n\n    def visitProg(self, ctx):\n        number_of_qubits, qubit_register_name = self.visit(ctx.qubitRegisterDeclaration())\n\n        self.squirrel_ir = SquirrelIR(number_of_qubits=number_of_qubits, qubit_register_name=qubit_register_name)\n\n        for gate_application in ctx.gateApplication():\n            self.visit(gate_application)\n\n        return self.squirrel_ir\n\n    def visitGateApplication(self, ctx):\n        gate_name = str(ctx.ID())\n\n        generator_f = GateLibrary.get_gate_f(self, gate_name)\n        parameters = inspect.signature(generator_f).parameters\n\n        number_of_operands = next(\n            len(self.visit(ctx.expr(i))) for i, par in enumerate(parameters.values()) if par.annotation == Qubit\n        )\n\n        # The below is for handling e.g. `cr q[1:3], q[5:7], 1.23`\n        expanded_args = [\n            self.visit(ctx.expr(i)) if par.annotation == Qubit else [self.visit(ctx.expr(i))] * number_of_operands\n            for i, par in enumerate(parameters.values())\n        ]\n\n        for individual_args in zip(*expanded_args):\n            self.squirrel_ir.add_gate(generator_f(*individual_args))\n\n    def visitQubitRegisterDeclaration(self, ctx):\n        return int(str(ctx.INT())), str(ctx.ID())\n\n    def visitQubit(self, ctx):\n        return [Qubit(int(str(ctx.INT())))]\n\n    def visitQubits(self, ctx):\n        return list(map(Qubit, map(int, map(str, ctx.INT()))))\n\n    def visitQubitRange(self, ctx):\n        first_qubit_index = int(str(ctx.INT(0)))\n        last_qubit_index = int(str(ctx.INT(1)))\n        return list(map(Qubit, range(first_qubit_index, last_qubit_index + 1)))\n\n    def visitFloatLiteral(self, ctx):\n        return Float(float(str(ctx.FLOAT())))\n\n    def visitNegatedFloatLiteral(self, ctx):\n        return Float(-float(str(ctx.FLOAT())))\n\n    def visitIntLiteral(self, ctx):\n        return Int(int(str(ctx.INT())))\n\n    def visitNegatedIntLiteral(self, ctx):\n        return Int(-int(str(ctx.INT())))\n</code></pre>"},{"location":"C%3A/Users/plehenaff/PycharmProjects/OpenSquirrel/docs/reference/#opensquirrel.parsing.antlr.squirrel_ir_from_string.squirrel_ir_from_string","title":"<code>squirrel_ir_from_string(s, gate_set, gate_aliases)</code>","text":"<p>ANTLR parsing entrypoint. Performs type checking based on provided gate semantics and check that the qubit indices are valid. Creates the IR where each gate node is mapped to its semantic function and arguments.</p> <p>Parameters:</p> Name Type Description Default <code>gate_set</code> <p>The set of supported gate semantics.</p> required <code>gate_aliases</code> <p>Dictionary mapping extra gate names to their semantic.</p> required <p>Returns:</p> Type Description <p>A corresponding SquirrelIR object. Throws in case of parsing error.</p> Source code in <code>opensquirrel\\parsing\\antlr\\squirrel_ir_from_string.py</code> <pre><code>def squirrel_ir_from_string(s: str, gate_set, gate_aliases):\n    \"\"\"\n    ANTLR parsing entrypoint.\n    Performs type checking based on provided gate semantics and check that the qubit indices are valid.\n    Creates the IR where each gate node is mapped to its semantic function and arguments.\n\n    Args:\n        gate_set: The set of supported gate semantics.\n        gate_aliases: Dictionary mapping extra gate names to their semantic.\n\n    Returns:\n        A corresponding SquirrelIR object. Throws in case of parsing error.\n    \"\"\"\n    tree = antlr_tree_from_string(s)\n\n    type_check_antlr_tree(tree, gate_set=gate_set, gate_aliases=gate_aliases)\n\n    check_qubit_ranges_of_antlr_tree(tree)\n\n    squirrel_ir_creator = SquirrelIRCreator(gate_set=gate_set, gate_aliases=gate_aliases)\n\n    return squirrel_ir_creator.visit(tree)\n</code></pre>"},{"location":"C%3A/Users/plehenaff/PycharmProjects/OpenSquirrel/docs/reference/#opensquirrel.parsing.antlr.type_checker.TypeChecker","title":"<code>TypeChecker</code>","text":"<p>             Bases: <code>GateLibrary</code>, <code>CQasm3Visitor</code></p> <p>This class checks that all gate parameter types make sense in an ANTLR parse tree. It is an instance of the ANTLR abstract syntax tree visitor class. Therefore, method names are fixed and based on rule names in the Grammar .g4 file.</p> Source code in <code>opensquirrel\\parsing\\antlr\\type_checker.py</code> <pre><code>class TypeChecker(GateLibrary, CQasm3Visitor.CQasm3Visitor):\n    \"\"\"\n    This class checks that all gate parameter types make sense in an ANTLR parse tree.\n    It is an instance of the ANTLR abstract syntax tree visitor class.\n    Therefore, method names are fixed and based on rule names in the Grammar .g4 file.\n    \"\"\"\n\n    def __init__(self, gate_set=default_gate_set, gate_aliases=default_gate_aliases):\n        GateLibrary.__init__(self, gate_set, gate_aliases)\n        self.qubit_register_name = None\n\n    def visitProg(self, ctx):\n        self.visit(ctx.qubitRegisterDeclaration())\n        for gate_application in ctx.gateApplication():\n            self.visit(gate_application)\n\n    def visitQubitRegisterDeclaration(self, ctx):\n        self.qubit_register_name = str(ctx.ID())\n\n    def visitGateApplication(self, ctx):\n        # Check that the types of the operands match the gate generator function.\n        gate_name = str(ctx.ID())\n        generator_f = GateLibrary.get_gate_f(self, gate_name)\n\n        parameters = inspect.signature(generator_f).parameters\n\n        if len(ctx.expr()) &gt; len(parameters):\n            raise Exception(f\"Gate `{gate_name}` takes {len(parameters)} arguments, but {len(ctx.expr())} were given!\")\n\n        for i, param in enumerate(parameters.values()):\n            actual_type = self.visit(ctx.expr(i))\n            expected_type = param.annotation\n            if actual_type != expected_type:\n                raise Exception(\n                    f\"Argument #{i} passed to gate `{gate_name}` is of type\"\n                    f\" {actual_type} but should be {expected_type}\"\n                )\n\n    def visitQubit(self, ctx):\n        if str(ctx.ID()) != self.qubit_register_name:\n            raise Exception(f\"Qubit register {str(ctx.ID())} not declared\")\n\n        return Qubit\n\n    def visitQubits(self, ctx):\n        if str(ctx.ID()) != self.qubit_register_name:\n            raise Exception(f\"Qubit register {str(ctx.ID())} not declared\")\n\n        return Qubit\n\n    def visitQubitRange(self, ctx):\n        if str(ctx.ID()) != self.qubit_register_name:\n            raise Exception(f\"Qubit register {str(ctx.ID())} not declared\")\n\n        return Qubit\n\n    def visitIntLiteral(self, ctx):\n        return Int\n\n    def visitNegatedIntLiteral(self, ctx):\n        return Int\n\n    def visitFloatLiteral(self, ctx):\n        return Float\n\n    def visitNegatedFloatLiteral(self, ctx):\n        return Float\n</code></pre>"},{"location":"C%3A/Users/plehenaff/PycharmProjects/OpenSquirrel/docs/reference/#opensquirrel.utils.matrix_expander.expand_ket","title":"<code>expand_ket(base_ket, reduced_ket, qubits)</code>","text":"<p>Given a base quantum ket on n qubits and a reduced ket on a subset of those qubits, this computes the expanded ket where the reduction qubits and the other qubits are set based on the reduced ket and the base ket, respectively. Roughly equivalent to the <code>pdep</code> assembly instruction (bits deposit).</p> <p>Parameters:</p> Name Type Description Default <code>base_ket</code> <code>int</code> <p>A quantum ket, represented by its corresponding non-negative integer.       By convention, qubit #0 corresponds to the least significant bit.</p> required <code>reduced_ket</code> <code>int</code> <p>A quantum ket, represented by its corresponding non-negative integer.          By convention, qubit #0 corresponds to the least significant bit.</p> required <code>qubits</code> <code>List[Qubit]</code> <p>The indices of the qubits to expand from the reduced ket. Order matters.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The non-negative integer corresponding to the expanded ket.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; expand_ket(0b00000, 0b0, [Qubit(5)])   # 0b000000\n0\n&gt;&gt;&gt; expand_ket(0b00000, 0b1, [Qubit(5)])   # 0b100000\n32\n&gt;&gt;&gt; expand_ket(0b00111, 0b0, [Qubit(5)])   # 0b000111\n7\n&gt;&gt;&gt; expand_ket(0b00111, 0b1, [Qubit(5)])   # 0b100111\n39\n&gt;&gt;&gt; expand_ket(0b0000, 0b000, [Qubit(1), Qubit(2), Qubit(3)])    # 0b0000\n0\n&gt;&gt;&gt; expand_ket(0b0000, 0b001, [Qubit(1), Qubit(2), Qubit(3)])    # 0b0010\n2\n&gt;&gt;&gt; expand_ket(0b0000, 0b011, [Qubit(1), Qubit(2), Qubit(3)])    # 0b0110\n6\n&gt;&gt;&gt; expand_ket(0b0000, 0b101, [Qubit(1), Qubit(2), Qubit(3)])   # 0b1010\n10\n&gt;&gt;&gt; expand_ket(0b0001, 0b101, [Qubit(1), Qubit(2), Qubit(3)])   # 0b1011\n11\n</code></pre> Source code in <code>opensquirrel\\utils\\matrix_expander.py</code> <pre><code>def expand_ket(base_ket: int, reduced_ket: int, qubits: List[Qubit]) -&gt; int:\n    \"\"\"\n    Given a base quantum ket on n qubits and a reduced ket on a subset of those qubits, this computes the expanded ket\n    where the reduction qubits and the other qubits are set based on the reduced ket and the base ket, respectively.\n    Roughly equivalent to the `pdep` assembly instruction (bits deposit).\n\n    Args:\n        base_ket: A quantum ket, represented by its corresponding non-negative integer.\n                  By convention, qubit #0 corresponds to the least significant bit.\n        reduced_ket: A quantum ket, represented by its corresponding non-negative integer.\n                     By convention, qubit #0 corresponds to the least significant bit.\n        qubits: The indices of the qubits to expand from the reduced ket. Order matters.\n\n    Returns:\n        The non-negative integer corresponding to the expanded ket.\n\n    Examples:\n        &gt;&gt;&gt; expand_ket(0b00000, 0b0, [Qubit(5)])   # 0b000000\n        0\n        &gt;&gt;&gt; expand_ket(0b00000, 0b1, [Qubit(5)])   # 0b100000\n        32\n        &gt;&gt;&gt; expand_ket(0b00111, 0b0, [Qubit(5)])   # 0b000111\n        7\n        &gt;&gt;&gt; expand_ket(0b00111, 0b1, [Qubit(5)])   # 0b100111\n        39\n        &gt;&gt;&gt; expand_ket(0b0000, 0b000, [Qubit(1), Qubit(2), Qubit(3)])    # 0b0000\n        0\n        &gt;&gt;&gt; expand_ket(0b0000, 0b001, [Qubit(1), Qubit(2), Qubit(3)])    # 0b0010\n        2\n        &gt;&gt;&gt; expand_ket(0b0000, 0b011, [Qubit(1), Qubit(2), Qubit(3)])    # 0b0110\n        6\n        &gt;&gt;&gt; expand_ket(0b0000, 0b101, [Qubit(1), Qubit(2), Qubit(3)])   # 0b1010\n        10\n        &gt;&gt;&gt; expand_ket(0b0001, 0b101, [Qubit(1), Qubit(2), Qubit(3)])   # 0b1011\n        11\n    \"\"\"\n    expanded_ket = base_ket\n    for i, qubit in enumerate(qubits):\n        expanded_ket &amp;= ~(1 &lt;&lt; qubit.index)  # Erase bit.\n        expanded_ket |= ((reduced_ket &amp; (1 &lt;&lt; i)) &gt;&gt; i) &lt;&lt; qubit.index  # Set bit to value from reduced_ket.\n\n    return expanded_ket\n</code></pre>"},{"location":"C%3A/Users/plehenaff/PycharmProjects/OpenSquirrel/docs/reference/#opensquirrel.utils.matrix_expander.get_matrix","title":"<code>get_matrix(gate, number_of_qubits)</code>","text":"<p>Compute the unitary matrix corresponding to the gate applied to those qubit operands, taken among any number of qubits. This can be used for, e.g., - testing, - permuting the operands of multi-qubit gates, - simulating a circuit (simulation in this way is inefficient for large numbers of qubits).</p> <p>Parameters:</p> Name Type Description Default <code>gate</code> <code>Gate</code> <p>The gate, including the qubits on which it is operated on.</p> required <code>number_of_qubits</code> <code>int</code> <p>The total number of qubits.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; X = lambda q: BlochSphereRotation(qubit=q, axis=(1, 0, 0), angle=math.pi, phase=math.pi / 2)\n&gt;&gt;&gt; get_matrix(X(Qubit(1)), 2).astype(int)           # X q[1]\narray([[0, 0, 1, 0],\n       [0, 0, 0, 1],\n       [1, 0, 0, 0],\n       [0, 1, 0, 0]])\n</code></pre> <pre><code>&gt;&gt;&gt; CNOT02 = ControlledGate(Qubit(0), X(Qubit(2)))\n&gt;&gt;&gt; get_matrix(CNOT02, 3).astype(int)     # CNOT q[0], q[2]\narray([[1, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 1, 0, 0],\n       [0, 0, 1, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 1],\n       [0, 0, 0, 0, 1, 0, 0, 0],\n       [0, 1, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 1, 0],\n       [0, 0, 0, 1, 0, 0, 0, 0]])\n&gt;&gt;&gt; get_matrix(ControlledGate(Qubit(1), X(Qubit(2))), 3).astype(int)     # CNOT q[1], q[2]\narray([[1, 0, 0, 0, 0, 0, 0, 0],\n       [0, 1, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 1, 0],\n       [0, 0, 0, 0, 0, 0, 0, 1],\n       [0, 0, 0, 0, 1, 0, 0, 0],\n       [0, 0, 0, 0, 0, 1, 0, 0],\n       [0, 0, 1, 0, 0, 0, 0, 0],\n       [0, 0, 0, 1, 0, 0, 0, 0]])\n</code></pre> Source code in <code>opensquirrel\\utils\\matrix_expander.py</code> <pre><code>def get_matrix(gate: Gate, number_of_qubits: int) -&gt; np.ndarray:\n    \"\"\"\n    Compute the unitary matrix corresponding to the gate applied to those qubit operands, taken among any number of qubits.\n    This can be used for, e.g.,\n    - testing,\n    - permuting the operands of multi-qubit gates,\n    - simulating a circuit (simulation in this way is inefficient for large numbers of qubits).\n\n    Args:\n        gate: The gate, including the qubits on which it is operated on.\n        number_of_qubits: The total number of qubits.\n\n    Examples:\n        &gt;&gt;&gt; X = lambda q: BlochSphereRotation(qubit=q, axis=(1, 0, 0), angle=math.pi, phase=math.pi / 2)\n        &gt;&gt;&gt; get_matrix(X(Qubit(1)), 2).astype(int)           # X q[1]\n        array([[0, 0, 1, 0],\n               [0, 0, 0, 1],\n               [1, 0, 0, 0],\n               [0, 1, 0, 0]])\n\n        &gt;&gt;&gt; CNOT02 = ControlledGate(Qubit(0), X(Qubit(2)))\n        &gt;&gt;&gt; get_matrix(CNOT02, 3).astype(int)     # CNOT q[0], q[2]\n        array([[1, 0, 0, 0, 0, 0, 0, 0],\n               [0, 0, 0, 0, 0, 1, 0, 0],\n               [0, 0, 1, 0, 0, 0, 0, 0],\n               [0, 0, 0, 0, 0, 0, 0, 1],\n               [0, 0, 0, 0, 1, 0, 0, 0],\n               [0, 1, 0, 0, 0, 0, 0, 0],\n               [0, 0, 0, 0, 0, 0, 1, 0],\n               [0, 0, 0, 1, 0, 0, 0, 0]])\n        &gt;&gt;&gt; get_matrix(ControlledGate(Qubit(1), X(Qubit(2))), 3).astype(int)     # CNOT q[1], q[2]\n        array([[1, 0, 0, 0, 0, 0, 0, 0],\n               [0, 1, 0, 0, 0, 0, 0, 0],\n               [0, 0, 0, 0, 0, 0, 1, 0],\n               [0, 0, 0, 0, 0, 0, 0, 1],\n               [0, 0, 0, 0, 1, 0, 0, 0],\n               [0, 0, 0, 0, 0, 1, 0, 0],\n               [0, 0, 1, 0, 0, 0, 0, 0],\n               [0, 0, 0, 1, 0, 0, 0, 0]])\n    \"\"\"\n\n    expander = MatrixExpander(number_of_qubits)\n    return gate.accept(expander)\n</code></pre>"},{"location":"C%3A/Users/plehenaff/PycharmProjects/OpenSquirrel/docs/reference/#opensquirrel.utils.matrix_expander.get_reduced_ket","title":"<code>get_reduced_ket(ket, qubits)</code>","text":"<p>Given a quantum ket represented by its corresponding base-10 integer, this computes the reduced ket where only the given qubits appear, in order. Roughly equivalent to the <code>pext</code> assembly instruction (bits extraction).</p> <p>Parameters:</p> Name Type Description Default <code>ket</code> <code>int</code> <p>A quantum ket, represented by its corresponding non-negative integer.  By convention, qubit #0 corresponds to the least significant bit.</p> required <code>qubits</code> <code>List[Qubit]</code> <p>The indices of the qubits to extract. Order matters.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The non-negative integer corresponding to the reduced ket.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; get_reduced_ket(1, [Qubit(0)])         # 0b01\n1\n&gt;&gt;&gt; get_reduced_ket(1111, [Qubit(2)])      # 0b01\n1\n&gt;&gt;&gt; get_reduced_ket(1111, [Qubit(5)])      # 0b0\n0\n&gt;&gt;&gt; get_reduced_ket(1111, [Qubit(2), Qubit(5)])   # 0b01\n1\n&gt;&gt;&gt; get_reduced_ket(101, [Qubit(1), Qubit(0)])    # 0b10\n2\n&gt;&gt;&gt; get_reduced_ket(101, [Qubit(0), Qubit(1)])    # 0b01\n1\n</code></pre> Source code in <code>opensquirrel\\utils\\matrix_expander.py</code> <pre><code>def get_reduced_ket(ket: int, qubits: List[Qubit]) -&gt; int:\n    \"\"\"\n    Given a quantum ket represented by its corresponding base-10 integer, this computes the reduced ket\n    where only the given qubits appear, in order.\n    Roughly equivalent to the `pext` assembly instruction (bits extraction).\n\n    Args:\n        ket: A quantum ket, represented by its corresponding non-negative integer.\n             By convention, qubit #0 corresponds to the least significant bit.\n        qubits: The indices of the qubits to extract. Order matters.\n\n    Returns:\n        The non-negative integer corresponding to the reduced ket.\n\n    Examples:\n        &gt;&gt;&gt; get_reduced_ket(1, [Qubit(0)])         # 0b01\n        1\n        &gt;&gt;&gt; get_reduced_ket(1111, [Qubit(2)])      # 0b01\n        1\n        &gt;&gt;&gt; get_reduced_ket(1111, [Qubit(5)])      # 0b0\n        0\n        &gt;&gt;&gt; get_reduced_ket(1111, [Qubit(2), Qubit(5)])   # 0b01\n        1\n        &gt;&gt;&gt; get_reduced_ket(101, [Qubit(1), Qubit(0)])    # 0b10\n        2\n        &gt;&gt;&gt; get_reduced_ket(101, [Qubit(0), Qubit(1)])    # 0b01\n        1\n    \"\"\"\n    reduced_ket = 0\n    for i, qubit in enumerate(qubits):\n        reduced_ket |= ((ket &amp; (1 &lt;&lt; qubit.index)) &gt;&gt; qubit.index) &lt;&lt; i\n\n    return reduced_ket\n</code></pre>"}]}