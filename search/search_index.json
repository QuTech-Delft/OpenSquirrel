{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"OpenSquirrel","text":"<p>This site contains the documentation for OpenSquirrel, i.e., a flexible quantum program compiler. OpenSquirrel chooses a modular, over a configurable, approach to prepare and optimize quantum circuits for heterogeneous target architectures.</p> <p>It has a user-friendly interface and is straightforwardly extensible with custom made readers, compiler passes, and exporters. As a quantum circuit compiler, it is fully aware of the semantics of each gate and arbitrary quantum gates can be constructed manually. It understands the quantum programming language cQASM 3 and will support additional quantum programming languages in the future. It is developed in modern Python and follows best practices.</p> <p>[GitHub repository][PyPI]</p>"},{"location":"#table-of-contents","title":"Table of Contents","text":"<p>The following documentation structure is used: Di\u00e1taxis documentation framework.</p> <ol> <li>Tutorial</li> <li>How-To Guides</li> <li>Reference</li> </ol>"},{"location":"#authors","title":"Authors","text":"<ul> <li> <p>Pablo Le Henaff (p.lehenaff@tudelft.nl)</p> </li> <li> <p>Roberto Turrado Camblor (r.turradocamblor@tudelft.nl)</p> </li> <li> <p>Chris Elenbaas (chris.elenbaas@tno.nl)</p> </li> </ul>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>The Quantum Inspire project (by QuTech: a collaboration of TNO and TU Delft)</p>"},{"location":"how-to-guides/","title":"How-To Guides","text":"<p>The purpose of a How-to Guide is to help the user accomplish at task.</p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#opensquirrel.circuit.Circuit","title":"<code>Circuit</code>","text":"<p>The Circuit class is the only interface to access OpenSquirrel's features.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; c = Circuit.from_string(\"version 3.0; qubit[3] q; h q[0]\")\n&gt;&gt;&gt; c\nversion 3.0\n\nqubit[3] q\n\nh q[0]\n\n&gt;&gt;&gt; c.decompose(decomposer=mckay_decomposer.McKayDecomposer)\n&gt;&gt;&gt; c\nversion 3.0\n\nqubit[3] q\n\nx90 q[0]\nrz q[0], 1.5707963\nx90 q[0]\n</code></pre> Source code in <code>opensquirrel\\circuit.py</code> <pre><code>class Circuit:\n    \"\"\"The Circuit class is the only interface to access OpenSquirrel's features.\n\n    Examples:\n        &gt;&gt;&gt; c = Circuit.from_string(\"version 3.0; qubit[3] q; h q[0]\")\n        &gt;&gt;&gt; c\n        version 3.0\n        &lt;BLANKLINE&gt;\n        qubit[3] q\n        &lt;BLANKLINE&gt;\n        h q[0]\n        &lt;BLANKLINE&gt;\n        &gt;&gt;&gt; c.decompose(decomposer=mckay_decomposer.McKayDecomposer)\n        &gt;&gt;&gt; c\n        version 3.0\n        &lt;BLANKLINE&gt;\n        qubit[3] q\n        &lt;BLANKLINE&gt;\n        x90 q[0]\n        rz q[0], 1.5707963\n        x90 q[0]\n        &lt;BLANKLINE&gt;\n\n    \"\"\"\n\n    def __init__(self, squirrel_ir: SquirrelIR):\n        \"\"\"Create a circuit object from a SquirrelIR object.\"\"\"\n\n        self.squirrel_ir = squirrel_ir\n\n    @classmethod\n    def from_string(\n        cls,\n        cqasm3_string: str,\n        gate_set: [Callable[..., Gate]] = default_gate_set,\n        gate_aliases: Dict[str, Callable[..., Gate]] = default_gate_aliases,\n        use_libqasm: bool = False,\n    ):\n        \"\"\"Create a circuit object from a cQasm3 string. All the gates in the circuit need to be defined in\n        the `gates` argument.\n\n        * type-checking is performed, eliminating qubit indices errors and incoherencies\n        * checks that used gates are supported and mentioned in `gates` with appropriate signatures\n        * does not support map or variables, and other things...\n        * for example of `gates` dictionary, please look at TestGates.py\n\n\n        Args:\n            cqasm3_string: a cqasm 3 string\n            gate_set: an array of gate semantic functions. See default_gates for examples\n            gate_aliases: a dictionary of extra aliases, mapping strings to functions in the gate set\n            use_libqasm: if True, use libqasm instead of build-in ANTLR parser.\n                Note: those two separate implementations may diverge and libqasm should be taken as reference.\n\n        \"\"\"\n        if use_libqasm:\n            libqasm_ir_creator = LibqasmIRCreator(gate_set=gate_set, gate_aliases=gate_aliases)\n            return Circuit(libqasm_ir_creator.squirrel_ir_from_string(cqasm3_string))\n\n        return Circuit(\n            opensquirrel.parsing.antlr.squirrel_ir_from_string.squirrel_ir_from_string(\n                cqasm3_string, gate_set=gate_set, gate_aliases=gate_aliases\n            )\n        )\n\n    @property\n    def number_of_qubits(self) -&gt; int:\n        return self.squirrel_ir.number_of_qubits\n\n    @property\n    def qubit_register_name(self) -&gt; str:\n        return self.squirrel_ir.qubit_register_name\n\n    def merge_single_qubit_gates(self):\n        \"\"\"Merge all consecutive 1-qubit gates in the circuit.\n        Gates obtained from merging other gates become anonymous gates.\n        \"\"\"\n\n        merger.merge_single_qubit_gates(self.squirrel_ir)\n\n    def decompose(self, decomposer: Decomposer):\n        \"\"\"Generic decomposition pass. It applies the given decomposer function\n        to every gate in the circuit.\"\"\"\n        replacer.decompose(self.squirrel_ir, decomposer)\n\n    def replace(self, gate_generator: Callable[..., Gate], f):\n        \"\"\"Manually replace occurrences of a given gate with a list of gates.\n        `f` is a callable that takes the arguments of the gate that is to be replaced\n        and returns the decomposition as a list of gates.\n        \"\"\"\n\n        replacer.replace(self.squirrel_ir, gate_generator, f)\n\n    def test_get_circuit_matrix(self) -&gt; np.ndarray:\n        \"\"\"Get the (large) unitary matrix corresponding to the circuit.\n\n        * this matrix has 4**n elements, where n is the number of qubits\n        * therefore this function is only here for testing purposes on small number of qubits\n        * result is stored as a numpy array of complex numbers\n        \"\"\"\n\n        return circuit_matrix_calculator.get_circuit_matrix(self.squirrel_ir)\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Write the circuit to a cQasm3 string.\"\"\"\n\n        return writer.squirrel_ir_to_string(self.squirrel_ir)\n\n    def export(self, format: ExportFormat):\n        if format == ExportFormat.QUANTIFY_SCHEDULER:\n            return quantify_scheduler_exporter.export(self.squirrel_ir)\n\n        raise Exception(\"Unknown export format\")\n</code></pre>"},{"location":"reference/#opensquirrel.circuit.Circuit.__init__","title":"<code>__init__(squirrel_ir)</code>","text":"<p>Create a circuit object from a SquirrelIR object.</p> Source code in <code>opensquirrel\\circuit.py</code> <pre><code>def __init__(self, squirrel_ir: SquirrelIR):\n    \"\"\"Create a circuit object from a SquirrelIR object.\"\"\"\n\n    self.squirrel_ir = squirrel_ir\n</code></pre>"},{"location":"reference/#opensquirrel.circuit.Circuit.__repr__","title":"<code>__repr__()</code>","text":"<p>Write the circuit to a cQasm3 string.</p> Source code in <code>opensquirrel\\circuit.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Write the circuit to a cQasm3 string.\"\"\"\n\n    return writer.squirrel_ir_to_string(self.squirrel_ir)\n</code></pre>"},{"location":"reference/#opensquirrel.circuit.Circuit.decompose","title":"<code>decompose(decomposer)</code>","text":"<p>Generic decomposition pass. It applies the given decomposer function to every gate in the circuit.</p> Source code in <code>opensquirrel\\circuit.py</code> <pre><code>def decompose(self, decomposer: Decomposer):\n    \"\"\"Generic decomposition pass. It applies the given decomposer function\n    to every gate in the circuit.\"\"\"\n    replacer.decompose(self.squirrel_ir, decomposer)\n</code></pre>"},{"location":"reference/#opensquirrel.circuit.Circuit.from_string","title":"<code>from_string(cqasm3_string, gate_set=default_gate_set, gate_aliases=default_gate_aliases, use_libqasm=False)</code>  <code>classmethod</code>","text":"<p>Create a circuit object from a cQasm3 string. All the gates in the circuit need to be defined in the <code>gates</code> argument.</p> <ul> <li>type-checking is performed, eliminating qubit indices errors and incoherencies</li> <li>checks that used gates are supported and mentioned in <code>gates</code> with appropriate signatures</li> <li>does not support map or variables, and other things...</li> <li>for example of <code>gates</code> dictionary, please look at TestGates.py</li> </ul> <p>Parameters:</p> Name Type Description Default <code>cqasm3_string</code> <code>str</code> <p>a cqasm 3 string</p> required <code>gate_set</code> <code>[Callable[..., Gate]]</code> <p>an array of gate semantic functions. See default_gates for examples</p> <code>default_gate_set</code> <code>gate_aliases</code> <code>Dict[str, Callable[..., Gate]]</code> <p>a dictionary of extra aliases, mapping strings to functions in the gate set</p> <code>default_gate_aliases</code> <code>use_libqasm</code> <code>bool</code> <p>if True, use libqasm instead of build-in ANTLR parser. Note: those two separate implementations may diverge and libqasm should be taken as reference.</p> <code>False</code> Source code in <code>opensquirrel\\circuit.py</code> <pre><code>@classmethod\ndef from_string(\n    cls,\n    cqasm3_string: str,\n    gate_set: [Callable[..., Gate]] = default_gate_set,\n    gate_aliases: Dict[str, Callable[..., Gate]] = default_gate_aliases,\n    use_libqasm: bool = False,\n):\n    \"\"\"Create a circuit object from a cQasm3 string. All the gates in the circuit need to be defined in\n    the `gates` argument.\n\n    * type-checking is performed, eliminating qubit indices errors and incoherencies\n    * checks that used gates are supported and mentioned in `gates` with appropriate signatures\n    * does not support map or variables, and other things...\n    * for example of `gates` dictionary, please look at TestGates.py\n\n\n    Args:\n        cqasm3_string: a cqasm 3 string\n        gate_set: an array of gate semantic functions. See default_gates for examples\n        gate_aliases: a dictionary of extra aliases, mapping strings to functions in the gate set\n        use_libqasm: if True, use libqasm instead of build-in ANTLR parser.\n            Note: those two separate implementations may diverge and libqasm should be taken as reference.\n\n    \"\"\"\n    if use_libqasm:\n        libqasm_ir_creator = LibqasmIRCreator(gate_set=gate_set, gate_aliases=gate_aliases)\n        return Circuit(libqasm_ir_creator.squirrel_ir_from_string(cqasm3_string))\n\n    return Circuit(\n        opensquirrel.parsing.antlr.squirrel_ir_from_string.squirrel_ir_from_string(\n            cqasm3_string, gate_set=gate_set, gate_aliases=gate_aliases\n        )\n    )\n</code></pre>"},{"location":"reference/#opensquirrel.circuit.Circuit.merge_single_qubit_gates","title":"<code>merge_single_qubit_gates()</code>","text":"<p>Merge all consecutive 1-qubit gates in the circuit. Gates obtained from merging other gates become anonymous gates.</p> Source code in <code>opensquirrel\\circuit.py</code> <pre><code>def merge_single_qubit_gates(self):\n    \"\"\"Merge all consecutive 1-qubit gates in the circuit.\n    Gates obtained from merging other gates become anonymous gates.\n    \"\"\"\n\n    merger.merge_single_qubit_gates(self.squirrel_ir)\n</code></pre>"},{"location":"reference/#opensquirrel.circuit.Circuit.replace","title":"<code>replace(gate_generator, f)</code>","text":"<p>Manually replace occurrences of a given gate with a list of gates. <code>f</code> is a callable that takes the arguments of the gate that is to be replaced and returns the decomposition as a list of gates.</p> Source code in <code>opensquirrel\\circuit.py</code> <pre><code>def replace(self, gate_generator: Callable[..., Gate], f):\n    \"\"\"Manually replace occurrences of a given gate with a list of gates.\n    `f` is a callable that takes the arguments of the gate that is to be replaced\n    and returns the decomposition as a list of gates.\n    \"\"\"\n\n    replacer.replace(self.squirrel_ir, gate_generator, f)\n</code></pre>"},{"location":"reference/#opensquirrel.circuit.Circuit.test_get_circuit_matrix","title":"<code>test_get_circuit_matrix()</code>","text":"<p>Get the (large) unitary matrix corresponding to the circuit.</p> <ul> <li>this matrix has 4**n elements, where n is the number of qubits</li> <li>therefore this function is only here for testing purposes on small number of qubits</li> <li>result is stored as a numpy array of complex numbers</li> </ul> Source code in <code>opensquirrel\\circuit.py</code> <pre><code>def test_get_circuit_matrix(self) -&gt; np.ndarray:\n    \"\"\"Get the (large) unitary matrix corresponding to the circuit.\n\n    * this matrix has 4**n elements, where n is the number of qubits\n    * therefore this function is only here for testing purposes on small number of qubits\n    * result is stored as a numpy array of complex numbers\n    \"\"\"\n\n    return circuit_matrix_calculator.get_circuit_matrix(self.squirrel_ir)\n</code></pre>"},{"location":"reference/#opensquirrel.circuit_builder.CircuitBuilder","title":"<code>CircuitBuilder</code>","text":"<p>             Bases: <code>GateLibrary</code></p> <p>A class using the builder pattern to make construction of circuits easy from Python. Adds corresponding gate when a method is called. Checks gates are known and called with the right arguments. Mainly here to allow for Qiskit-style circuit construction:</p> Example <p>CircuitBuilder(number_of_qubits=3).h(Qubit(0)).cnot(Qubit(0), Qubit(1)).cnot(Qubit(0), Qubit(2)).to_circuit() version 3.0  qubit[3] q  h q[0] cnot q[0], q[1] cnot q[0], q[2]  Source code in <code>opensquirrel\\circuit_builder.py</code> <pre><code>class CircuitBuilder(GateLibrary):\n    \"\"\"\n    A class using the builder pattern to make construction of circuits easy from Python.\n    Adds corresponding gate when a method is called. Checks gates are known and called with the right arguments.\n    Mainly here to allow for Qiskit-style circuit construction:\n\n    Example:\n        &gt;&gt;&gt; CircuitBuilder(number_of_qubits=3).h(Qubit(0)).cnot(Qubit(0), Qubit(1)).cnot(Qubit(0), Qubit(2)).to_circuit()\n        version 3.0\n        &lt;BLANKLINE&gt;\n        qubit[3] q\n        &lt;BLANKLINE&gt;\n        h q[0]\n        cnot q[0], q[1]\n        cnot q[0], q[2]\n        &lt;BLANKLINE&gt;\n    \"\"\"\n\n    _default_qubit_register_name = \"q\"\n\n    def __init__(\n        self,\n        number_of_qubits: int,\n        gate_set: [Callable[..., Gate]] = default_gate_set,\n        gate_aliases: Dict[str, Callable[..., Gate]] = default_gate_aliases,\n    ):\n        GateLibrary.__init__(self, gate_set, gate_aliases)\n        self.squirrel_ir = SquirrelIR(\n            number_of_qubits=number_of_qubits, qubit_register_name=self._default_qubit_register_name\n        )\n\n    def __getattr__(self, attr):\n        def add_comment(comment_string: str):\n            self.squirrel_ir.add_comment(Comment(comment_string))\n            return self\n\n        def add_this_gate(*args):\n            generator_f = GateLibrary.get_gate_f(self, attr)\n\n            for i, par in enumerate(inspect.signature(generator_f).parameters.values()):\n                if not isinstance(args[i], par.annotation):\n                    raise TypeError(\n                        f\"Wrong argument type for gate `{attr}`, got {type(args[i])} but expected {par.annotation}\"\n                    )\n\n            self.squirrel_ir.add_gate(generator_f(*args))\n            return self\n\n        return add_comment if attr == \"comment\" else add_this_gate\n\n    def to_circuit(self) -&gt; Circuit:\n        return Circuit(self.squirrel_ir)\n</code></pre>"},{"location":"reference/#opensquirrel.circuit_matrix_calculator.get_circuit_matrix","title":"<code>get_circuit_matrix(squirrel_ir)</code>","text":"<p>Compute the Numpy unitary matrix corresponding to the circuit. The size of this matrix grows exponentially with the number of qubits.</p> Source code in <code>opensquirrel\\circuit_matrix_calculator.py</code> <pre><code>def get_circuit_matrix(squirrel_ir: SquirrelIR):\n    \"\"\"\n    Compute the Numpy unitary matrix corresponding to the circuit.\n    The size of this matrix grows exponentially with the number of qubits.\n    \"\"\"\n\n    impl = _CircuitMatrixCalculator(squirrel_ir.number_of_qubits)\n\n    squirrel_ir.accept(impl)\n\n    return impl.matrix\n</code></pre>"},{"location":"reference/#opensquirrel.cnot_decomposer.CNOTDecomposer","title":"<code>CNOTDecomposer</code>","text":"<p>             Bases: <code>Decomposer</code></p> <p>Decomposes 2-qubit controlled unitary gates to CNOT + rz/ry. Applying single-qubit gate fusion after this pass might be beneficial.</p> <p>Source of the math: https://threeplusone.com/pubs/on_gates.pdf, chapter 7.5 \"ABC decomposition\"</p> Source code in <code>opensquirrel\\cnot_decomposer.py</code> <pre><code>class CNOTDecomposer(Decomposer):\n    \"\"\"\n    Decomposes 2-qubit controlled unitary gates to CNOT + rz/ry.\n    Applying single-qubit gate fusion after this pass might be beneficial.\n\n    Source of the math: https://threeplusone.com/pubs/on_gates.pdf, chapter 7.5 \"ABC decomposition\"\n    \"\"\"\n\n    @staticmethod\n    def decompose(g: Gate) -&gt; [Gate]:\n        if not isinstance(g, ControlledGate):\n            # Do nothing:\n            # - BlochSphereRotation's are only single-qubit,\n            # - decomposing MatrixGate is currently not supported.\n            return [g]\n\n        if not isinstance(g.target_gate, BlochSphereRotation):\n            # Do nothing.\n            # ControlledGate's with 2+ control qubits are ignored.\n            return [g]\n\n        target_qubit = g.target_gate.qubit\n\n        # Perform ZYZ decomposition on the target gate.\n        # This gives us an ABC decomposition (U = AXBXC, ABC = I) of the target gate.\n        # See https://threeplusone.com/pubs/on_gates.pdf\n\n        # Try special case first, see https://arxiv.org/pdf/quant-ph/9503016.pdf lemma 5.5\n        controlled_rotation_times_x = merger.compose_bloch_sphere_rotations(x(target_qubit), g.target_gate)\n        theta0_with_x, theta1_with_x, theta2_with_x = get_zyz_decomposition_angles(\n            controlled_rotation_times_x.angle, controlled_rotation_times_x.axis\n        )\n        if abs((theta0_with_x - theta2_with_x) % (2 * math.pi)) &lt; ATOL:\n            # The decomposition can use a single CNOT according to the lemma.\n\n            A = [ry(q=target_qubit, theta=Float(-theta1_with_x / 2)), rz(q=target_qubit, theta=Float(-theta2_with_x))]\n\n            B = [\n                rz(q=target_qubit, theta=Float(theta2_with_x)),\n                ry(q=target_qubit, theta=Float(theta1_with_x / 2)),\n            ]\n\n            return filter_out_identities(\n                B\n                + [cnot(control=g.control_qubit, target=target_qubit)]\n                + A\n                + [rz(q=g.control_qubit, theta=Float(g.target_gate.phase - math.pi / 2))]\n            )\n\n        theta0, theta1, theta2 = get_zyz_decomposition_angles(g.target_gate.angle, g.target_gate.axis)\n\n        A = [ry(q=target_qubit, theta=Float(theta1 / 2)), rz(q=target_qubit, theta=Float(theta2))]\n\n        B = [\n            rz(q=target_qubit, theta=Float(-(theta0 + theta2) / 2)),\n            ry(q=target_qubit, theta=Float(-theta1 / 2)),\n        ]\n\n        C = [\n            rz(q=target_qubit, theta=Float((theta0 - theta2) / 2)),\n        ]\n\n        return filter_out_identities(\n            C\n            + [cnot(control=g.control_qubit, target=target_qubit)]\n            + B\n            + [cnot(control=g.control_qubit, target=target_qubit)]\n            + A\n            + [rz(q=g.control_qubit, theta=Float(g.target_gate.phase))]\n        )\n</code></pre>"},{"location":"reference/#opensquirrel.mckay_decomposer.McKayDecomposer","title":"<code>McKayDecomposer</code>","text":"<p>             Bases: <code>Decomposer</code></p> Source code in <code>opensquirrel\\mckay_decomposer.py</code> <pre><code>class McKayDecomposer(Decomposer):\n    @staticmethod\n    def decompose(g: Gate) -&gt; [Gate]:\n        \"\"\"Return the McKay decomposition of a 1-qubit gate as a list of gates.\n                gate   ----&gt;    Rz.Rx(pi/2).Rz.Rx(pi/2).Rz\n\n        The global phase is deemed _irrelevant_, therefore a simulator backend might produce different output\n            for the input and output - the results should be equivalent modulo global phase.\n\n        Relevant literature: https://arxiv.org/abs/1612.00858\n        \"\"\"\n        if not isinstance(g, BlochSphereRotation):\n            return [g]\n\n        if abs(g.angle) &lt; ATOL:\n            return []\n\n        # McKay decomposition\n\n        za_mod = sqrt(cos(g.angle / 2) ** 2 + (g.axis[2] * sin(g.angle / 2)) ** 2)\n        zb_mod = abs(sin(g.angle / 2)) * sqrt(g.axis[0] ** 2 + g.axis[1] ** 2)\n\n        theta = pi - 2 * atan2(zb_mod, za_mod)\n\n        alpha = atan2(-sin(g.angle / 2) * g.axis[2], cos(g.angle / 2))\n        beta = atan2(-sin(g.angle / 2) * g.axis[0], -sin(g.angle / 2) * g.axis[1])\n\n        lam = beta - alpha\n        phi = -beta - alpha - pi\n\n        lam = normalize_angle(lam)\n        phi = normalize_angle(phi)\n        theta = normalize_angle(theta)\n\n        decomposed_g = []\n\n        if abs(lam) &gt; ATOL:\n            decomposed_g.append(rz(g.qubit, Float(lam)))\n\n        decomposed_g.append(x90(g.qubit))\n\n        if abs(theta) &gt; ATOL:\n            decomposed_g.append(rz(g.qubit, Float(theta)))\n\n        decomposed_g.append(x90(g.qubit))\n\n        if abs(phi) &gt; ATOL:\n            decomposed_g.append(rz(g.qubit, Float(phi)))\n\n        return decomposed_g\n</code></pre>"},{"location":"reference/#opensquirrel.mckay_decomposer.McKayDecomposer.decompose","title":"<code>decompose(g)</code>  <code>staticmethod</code>","text":"<p>Return the McKay decomposition of a 1-qubit gate as a list of gates.         gate   ----&gt;    Rz.Rx(pi/2).Rz.Rx(pi/2).Rz</p> <p>The global phase is deemed irrelevant, therefore a simulator backend might produce different output     for the input and output - the results should be equivalent modulo global phase.</p> <p>Relevant literature: https://arxiv.org/abs/1612.00858</p> Source code in <code>opensquirrel\\mckay_decomposer.py</code> <pre><code>@staticmethod\ndef decompose(g: Gate) -&gt; [Gate]:\n    \"\"\"Return the McKay decomposition of a 1-qubit gate as a list of gates.\n            gate   ----&gt;    Rz.Rx(pi/2).Rz.Rx(pi/2).Rz\n\n    The global phase is deemed _irrelevant_, therefore a simulator backend might produce different output\n        for the input and output - the results should be equivalent modulo global phase.\n\n    Relevant literature: https://arxiv.org/abs/1612.00858\n    \"\"\"\n    if not isinstance(g, BlochSphereRotation):\n        return [g]\n\n    if abs(g.angle) &lt; ATOL:\n        return []\n\n    # McKay decomposition\n\n    za_mod = sqrt(cos(g.angle / 2) ** 2 + (g.axis[2] * sin(g.angle / 2)) ** 2)\n    zb_mod = abs(sin(g.angle / 2)) * sqrt(g.axis[0] ** 2 + g.axis[1] ** 2)\n\n    theta = pi - 2 * atan2(zb_mod, za_mod)\n\n    alpha = atan2(-sin(g.angle / 2) * g.axis[2], cos(g.angle / 2))\n    beta = atan2(-sin(g.angle / 2) * g.axis[0], -sin(g.angle / 2) * g.axis[1])\n\n    lam = beta - alpha\n    phi = -beta - alpha - pi\n\n    lam = normalize_angle(lam)\n    phi = normalize_angle(phi)\n    theta = normalize_angle(theta)\n\n    decomposed_g = []\n\n    if abs(lam) &gt; ATOL:\n        decomposed_g.append(rz(g.qubit, Float(lam)))\n\n    decomposed_g.append(x90(g.qubit))\n\n    if abs(theta) &gt; ATOL:\n        decomposed_g.append(rz(g.qubit, Float(theta)))\n\n    decomposed_g.append(x90(g.qubit))\n\n    if abs(phi) &gt; ATOL:\n        decomposed_g.append(rz(g.qubit, Float(phi)))\n\n    return decomposed_g\n</code></pre>"},{"location":"reference/#opensquirrel.merger.compose_bloch_sphere_rotations","title":"<code>compose_bloch_sphere_rotations(a, b)</code>","text":"<p>Computes the Bloch sphere rotation resulting from the composition of two Bloch sphere rotations. The first rotation is applied and then the second. The resulting gate is anonymous except if <code>a</code> is the identity and <code>b</code> is not anonymous, or vice versa.</p> <p>Uses Rodrigues' rotation formula, see for instance https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula.</p> Source code in <code>opensquirrel\\merger.py</code> <pre><code>def compose_bloch_sphere_rotations(a: BlochSphereRotation, b: BlochSphereRotation) -&gt; BlochSphereRotation:\n    \"\"\"Computes the Bloch sphere rotation resulting from the composition of two Bloch sphere rotations.\n    The first rotation is applied and then the second.\n    The resulting gate is anonymous except if `a` is the identity and `b` is not anonymous, or vice versa.\n\n    Uses Rodrigues' rotation formula, see for instance https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula.\n    \"\"\"\n    assert a.qubit == b.qubit, \"Cannot merge two BlochSphereRotation's on different qubits\"\n\n    acos_argument = cos(a.angle / 2) * cos(b.angle / 2) - sin(a.angle / 2) * sin(b.angle / 2) * np.dot(a.axis, b.axis)\n    # This fixes float approximations like 1.0000000000002 which acos doesn't like.\n    acos_argument = max(min(acos_argument, 1.0), -1.0)\n\n    combined_angle = 2 * acos(acos_argument)\n\n    if abs(sin(combined_angle / 2)) &lt; ATOL:\n        return BlochSphereRotation.identity(a.qubit)\n\n    combined_axis = (\n        1\n        / sin(combined_angle / 2)\n        * (\n            sin(a.angle / 2) * cos(b.angle / 2) * a.axis\n            + cos(a.angle / 2) * sin(b.angle / 2) * b.axis\n            + sin(a.angle / 2) * sin(b.angle / 2) * np.cross(a.axis, b.axis)\n        )\n    )\n\n    combined_phase = a.phase + b.phase\n\n    generator = b.generator if a.is_identity() else a.generator if b.is_identity() else None\n    arguments = b.arguments if a.is_identity() else a.arguments if b.is_identity() else None\n\n    return BlochSphereRotation(\n        qubit=a.qubit,\n        axis=combined_axis,\n        angle=combined_angle,\n        phase=combined_phase,\n        generator=generator,\n        arguments=arguments,\n    )\n</code></pre>"},{"location":"reference/#opensquirrel.parsing.antlr.qubit_range_checker.QubitRangeChecker","title":"<code>QubitRangeChecker</code>","text":"<p>             Bases: <code>CQasm3Visitor</code></p> <p>This class checks that all qubit indices make sense in an ANTLR parse tree. It is an instance of the ANTLR abstract syntax tree visitor class. Therefore, method names are fixed and based on rule names in the Grammar .g4 file.</p> Source code in <code>opensquirrel\\parsing\\antlr\\qubit_range_checker.py</code> <pre><code>class QubitRangeChecker(CQasm3Visitor.CQasm3Visitor):\n    \"\"\"\n    This class checks that all qubit indices make sense in an ANTLR parse tree.\n    It is an instance of the ANTLR abstract syntax tree visitor class.\n    Therefore, method names are fixed and based on rule names in the Grammar .g4 file.\n    \"\"\"\n\n    def __init__(self):\n        self.number_of_qubits = 0\n\n    def visitProg(self, ctx):\n        self.visit(ctx.qubitRegisterDeclaration())\n        for gate_application in ctx.gateApplication():\n            self.visit(gate_application)\n\n    def visitQubitRegisterDeclaration(self, ctx):\n        self.number_of_qubits = int(str(ctx.INT()))\n\n    def visitGateApplication(self, ctx):\n        visited_args = (self.visit(arg) for arg in ctx.expr())\n        qubit_argument_sizes = [qubit_range_size for qubit_range_size in visited_args if qubit_range_size is not None]\n\n        if len(qubit_argument_sizes) &gt; 0 and not all(s == qubit_argument_sizes[0] for s in qubit_argument_sizes):\n            raise Exception(\"Invalid gate call with qubit arguments of different sizes\")\n\n    def visitQubit(self, ctx):\n        qubit_index = int(str(ctx.INT()))\n        if qubit_index &gt;= self.number_of_qubits:\n            raise Exception(f\"Qubit index {qubit_index} out of range\")\n\n        return 1\n\n    def visitQubits(self, ctx):\n        qubit_indices = list(map(int, map(str, ctx.INT())))\n        for qubit_index in qubit_indices:\n            if qubit_index &gt;= self.number_of_qubits:\n                raise Exception(f\"Qubit index {qubit_index} out of range\")\n\n        return len(qubit_indices)\n\n    def visitQubitRange(self, ctx):\n        first_qubit_index = int(str(ctx.INT(0)))\n        last_qubit_index = int(str(ctx.INT(1)))\n\n        if first_qubit_index &gt; last_qubit_index:\n            raise Exception(f\"Qubit index range {first_qubit_index}:{last_qubit_index} malformed\")\n\n        if max(first_qubit_index, last_qubit_index) &gt;= self.number_of_qubits:\n            raise Exception(f\"Qubit index range {first_qubit_index}:{last_qubit_index} out of range\")\n\n        return last_qubit_index - first_qubit_index + 1\n\n    def visitIntLiteral(self, ctx):\n        return None\n\n    def visitNegatedIntLiteral(self, ctx):\n        return None\n\n    def visitFloatLiteral(self, ctx):\n        return None\n\n    def visitNegatedFloatLiteral(self, ctx):\n        return None\n</code></pre>"},{"location":"reference/#opensquirrel.parsing.antlr.squirrel_ir_creator.SquirrelIRCreator","title":"<code>SquirrelIRCreator</code>","text":"<p>             Bases: <code>GateLibrary</code>, <code>CQasm3Visitor</code></p> <p>This class creates a SquirrelIR object from an ANTLR parse tree. It is an instance of the ANTLR abstract syntax tree visitor class. Therefore, method names are fixed and based on rule names in the Grammar .g4 file.</p> Source code in <code>opensquirrel\\parsing\\antlr\\squirrel_ir_creator.py</code> <pre><code>class SquirrelIRCreator(GateLibrary, CQasm3Visitor.CQasm3Visitor):\n    \"\"\"\n    This class creates a SquirrelIR object from an ANTLR parse tree.\n    It is an instance of the ANTLR abstract syntax tree visitor class.\n    Therefore, method names are fixed and based on rule names in the Grammar .g4 file.\n    \"\"\"\n\n    def __init__(self, gate_set=default_gate_set, gate_aliases=default_gate_aliases):\n        GateLibrary.__init__(self, gate_set, gate_aliases)\n        self.squirrel_ir = None\n\n    def visitProg(self, ctx):\n        number_of_qubits, qubit_register_name = self.visit(ctx.qubitRegisterDeclaration())\n\n        self.squirrel_ir = SquirrelIR(number_of_qubits=number_of_qubits, qubit_register_name=qubit_register_name)\n\n        for gate_application in ctx.gateApplication():\n            self.visit(gate_application)\n\n        return self.squirrel_ir\n\n    def visitGateApplication(self, ctx):\n        gate_name = str(ctx.ID())\n\n        generator_f = GateLibrary.get_gate_f(self, gate_name)\n        parameters = inspect.signature(generator_f).parameters\n\n        number_of_operands = next(\n            len(self.visit(ctx.expr(i))) for i, par in enumerate(parameters.values()) if par.annotation == Qubit\n        )\n\n        # The below is for handling e.g. `cr q[1:3], q[5:7], 1.23`\n        expanded_args = [\n            self.visit(ctx.expr(i)) if par.annotation == Qubit else [self.visit(ctx.expr(i))] * number_of_operands\n            for i, par in enumerate(parameters.values())\n        ]\n\n        for individual_args in zip(*expanded_args):\n            self.squirrel_ir.add_gate(generator_f(*individual_args))\n\n    def visitQubitRegisterDeclaration(self, ctx):\n        return int(str(ctx.INT())), str(ctx.ID())\n\n    def visitQubit(self, ctx):\n        return [Qubit(int(str(ctx.INT())))]\n\n    def visitQubits(self, ctx):\n        return list(map(Qubit, map(int, map(str, ctx.INT()))))\n\n    def visitQubitRange(self, ctx):\n        first_qubit_index = int(str(ctx.INT(0)))\n        last_qubit_index = int(str(ctx.INT(1)))\n        return list(map(Qubit, range(first_qubit_index, last_qubit_index + 1)))\n\n    def visitFloatLiteral(self, ctx):\n        return Float(float(str(ctx.FLOAT())))\n\n    def visitNegatedFloatLiteral(self, ctx):\n        return Float(-float(str(ctx.FLOAT())))\n\n    def visitIntLiteral(self, ctx):\n        return Int(int(str(ctx.INT())))\n\n    def visitNegatedIntLiteral(self, ctx):\n        return Int(-int(str(ctx.INT())))\n</code></pre>"},{"location":"reference/#opensquirrel.parsing.antlr.squirrel_ir_from_string.squirrel_ir_from_string","title":"<code>squirrel_ir_from_string(s, gate_set, gate_aliases)</code>","text":"<p>ANTLR parsing entrypoint. Performs type checking based on provided gate semantics and check that the qubit indices are valid. Creates the IR where each gate node is mapped to its semantic function and arguments.</p> <p>Parameters:</p> Name Type Description Default <code>gate_set</code> <code>list</code> <p>The set of supported gate semantics.</p> required <code>gate_aliases</code> <code>dict</code> <p>Dictionary mapping extra gate names to their semantic.</p> required <p>Returns:</p> Type Description <code>SquirrelIR</code> <p>A corresponding SquirrelIR object. Throws in case of parsing error.</p> Source code in <code>opensquirrel\\parsing\\antlr\\squirrel_ir_from_string.py</code> <pre><code>def squirrel_ir_from_string(s: str, gate_set: list, gate_aliases: dict) -&gt; SquirrelIR:\n    \"\"\"\n    ANTLR parsing entrypoint.\n    Performs type checking based on provided gate semantics and check that the qubit indices are valid.\n    Creates the IR where each gate node is mapped to its semantic function and arguments.\n\n    Args:\n        gate_set: The set of supported gate semantics.\n        gate_aliases: Dictionary mapping extra gate names to their semantic.\n\n    Returns:\n        A corresponding SquirrelIR object. Throws in case of parsing error.\n    \"\"\"\n    tree = antlr_tree_from_string(s)\n\n    type_check_antlr_tree(tree, gate_set=gate_set, gate_aliases=gate_aliases)\n\n    check_qubit_ranges_of_antlr_tree(tree)\n\n    squirrel_ir_creator = SquirrelIRCreator(gate_set=gate_set, gate_aliases=gate_aliases)\n\n    return squirrel_ir_creator.visit(tree)\n</code></pre>"},{"location":"reference/#opensquirrel.parsing.antlr.type_checker.TypeChecker","title":"<code>TypeChecker</code>","text":"<p>             Bases: <code>GateLibrary</code>, <code>CQasm3Visitor</code></p> <p>This class checks that all gate parameter types make sense in an ANTLR parse tree. It is an instance of the ANTLR abstract syntax tree visitor class. Therefore, method names are fixed and based on rule names in the Grammar .g4 file.</p> Source code in <code>opensquirrel\\parsing\\antlr\\type_checker.py</code> <pre><code>class TypeChecker(GateLibrary, CQasm3Visitor.CQasm3Visitor):\n    \"\"\"\n    This class checks that all gate parameter types make sense in an ANTLR parse tree.\n    It is an instance of the ANTLR abstract syntax tree visitor class.\n    Therefore, method names are fixed and based on rule names in the Grammar .g4 file.\n    \"\"\"\n\n    def __init__(self, gate_set=default_gate_set, gate_aliases=default_gate_aliases):\n        GateLibrary.__init__(self, gate_set, gate_aliases)\n        self.qubit_register_name = None\n\n    def visitProg(self, ctx):\n        self.visit(ctx.qubitRegisterDeclaration())\n        for gate_application in ctx.gateApplication():\n            self.visit(gate_application)\n\n    def visitQubitRegisterDeclaration(self, ctx):\n        self.qubit_register_name = str(ctx.ID())\n\n    def visitGateApplication(self, ctx):\n        # Check that the types of the operands match the gate generator function.\n        gate_name = str(ctx.ID())\n        generator_f = GateLibrary.get_gate_f(self, gate_name)\n\n        parameters = inspect.signature(generator_f).parameters\n\n        if len(ctx.expr()) &gt; len(parameters):\n            raise Exception(f\"Gate `{gate_name}` takes {len(parameters)} arguments, but {len(ctx.expr())} were given!\")\n\n        for i, param in enumerate(parameters.values()):\n            actual_type = self.visit(ctx.expr(i))\n            expected_type = param.annotation\n            if actual_type != expected_type:\n                raise Exception(\n                    f\"Argument #{i} passed to gate `{gate_name}` is of type\"\n                    f\" {actual_type} but should be {expected_type}\"\n                )\n\n    def visitQubit(self, ctx):\n        if str(ctx.ID()) != self.qubit_register_name:\n            raise Exception(f\"Qubit register {str(ctx.ID())} not declared\")\n\n        return Qubit\n\n    def visitQubits(self, ctx):\n        if str(ctx.ID()) != self.qubit_register_name:\n            raise Exception(f\"Qubit register {str(ctx.ID())} not declared\")\n\n        return Qubit\n\n    def visitQubitRange(self, ctx):\n        if str(ctx.ID()) != self.qubit_register_name:\n            raise Exception(f\"Qubit register {str(ctx.ID())} not declared\")\n\n        return Qubit\n\n    def visitIntLiteral(self, ctx):\n        return Int\n\n    def visitNegatedIntLiteral(self, ctx):\n        return Int\n\n    def visitFloatLiteral(self, ctx):\n        return Float\n\n    def visitNegatedFloatLiteral(self, ctx):\n        return Float\n</code></pre>"},{"location":"reference/#opensquirrel.replacer.decompose","title":"<code>decompose(squirrel_ir, decomposer)</code>","text":"<p>Applies <code>decomposer</code> to every gate in the circuit, replacing each gate by the output of <code>decomposer</code>. When <code>decomposer</code> decides to not decompose a gate, it needs to return a list with the intact gate as single element.</p> Source code in <code>opensquirrel\\replacer.py</code> <pre><code>def decompose(squirrel_ir: SquirrelIR, decomposer: Decomposer):\n    \"\"\"Applies `decomposer` to every gate in the circuit, replacing each gate by the output of `decomposer`.\n    When `decomposer` decides to not decompose a gate, it needs to return a list with the intact gate as single element.\n    \"\"\"\n    statement_index = 0\n    while statement_index &lt; len(squirrel_ir.statements):\n        statement = squirrel_ir.statements[statement_index]\n\n        if not isinstance(statement, Gate):\n            statement_index += 1\n            continue\n\n        replacement: List[Gate] = decomposer.decompose(statement)\n\n        check_valid_replacement(statement, replacement)\n\n        squirrel_ir.statements[statement_index : statement_index + 1] = replacement\n        statement_index += len(replacement)\n</code></pre>"},{"location":"reference/#opensquirrel.replacer.replace","title":"<code>replace(squirrel_ir, gate_generator, f)</code>","text":"<p>Does the same as decomposer, but only applies to a given gate.</p> Source code in <code>opensquirrel\\replacer.py</code> <pre><code>def replace(squirrel_ir: SquirrelIR, gate_generator: Callable[..., Gate], f):\n    \"\"\"Does the same as decomposer, but only applies to a given gate.\"\"\"\n\n    def generic_replacer(g: Gate) -&gt; [Gate]:\n        if g.is_anonymous or g.generator != gate_generator:\n            return [g]\n        return f(*g.arguments)\n\n    generic_replacer = _GenericReplacer(gate_generator, f)\n\n    decompose(squirrel_ir, generic_replacer)\n</code></pre>"},{"location":"reference/#opensquirrel.utils.matrix_expander.expand_ket","title":"<code>expand_ket(base_ket, reduced_ket, qubits)</code>","text":"<p>Given a base quantum ket on n qubits and a reduced ket on a subset of those qubits, this computes the expanded ket where the reduction qubits and the other qubits are set based on the reduced ket and the base ket, respectively. Roughly equivalent to the <code>pdep</code> assembly instruction (bits deposit).</p> <p>Parameters:</p> Name Type Description Default <code>base_ket</code> <code>int</code> <p>A quantum ket, represented by its corresponding non-negative integer.       By convention, qubit #0 corresponds to the least significant bit.</p> required <code>reduced_ket</code> <code>int</code> <p>A quantum ket, represented by its corresponding non-negative integer.          By convention, qubit #0 corresponds to the least significant bit.</p> required <code>qubits</code> <code>List[Qubit]</code> <p>The indices of the qubits to expand from the reduced ket. Order matters.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The non-negative integer corresponding to the expanded ket.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; expand_ket(0b00000, 0b0, [Qubit(5)])   # 0b000000\n0\n&gt;&gt;&gt; expand_ket(0b00000, 0b1, [Qubit(5)])   # 0b100000\n32\n&gt;&gt;&gt; expand_ket(0b00111, 0b0, [Qubit(5)])   # 0b000111\n7\n&gt;&gt;&gt; expand_ket(0b00111, 0b1, [Qubit(5)])   # 0b100111\n39\n&gt;&gt;&gt; expand_ket(0b0000, 0b000, [Qubit(1), Qubit(2), Qubit(3)])    # 0b0000\n0\n&gt;&gt;&gt; expand_ket(0b0000, 0b001, [Qubit(1), Qubit(2), Qubit(3)])    # 0b0010\n2\n&gt;&gt;&gt; expand_ket(0b0000, 0b011, [Qubit(1), Qubit(2), Qubit(3)])    # 0b0110\n6\n&gt;&gt;&gt; expand_ket(0b0000, 0b101, [Qubit(1), Qubit(2), Qubit(3)])   # 0b1010\n10\n&gt;&gt;&gt; expand_ket(0b0001, 0b101, [Qubit(1), Qubit(2), Qubit(3)])   # 0b1011\n11\n</code></pre> Source code in <code>opensquirrel\\utils\\matrix_expander.py</code> <pre><code>def expand_ket(base_ket: int, reduced_ket: int, qubits: List[Qubit]) -&gt; int:\n    \"\"\"\n    Given a base quantum ket on n qubits and a reduced ket on a subset of those qubits, this computes the expanded ket\n    where the reduction qubits and the other qubits are set based on the reduced ket and the base ket, respectively.\n    Roughly equivalent to the `pdep` assembly instruction (bits deposit).\n\n    Args:\n        base_ket: A quantum ket, represented by its corresponding non-negative integer.\n                  By convention, qubit #0 corresponds to the least significant bit.\n        reduced_ket: A quantum ket, represented by its corresponding non-negative integer.\n                     By convention, qubit #0 corresponds to the least significant bit.\n        qubits: The indices of the qubits to expand from the reduced ket. Order matters.\n\n    Returns:\n        The non-negative integer corresponding to the expanded ket.\n\n    Examples:\n        &gt;&gt;&gt; expand_ket(0b00000, 0b0, [Qubit(5)])   # 0b000000\n        0\n        &gt;&gt;&gt; expand_ket(0b00000, 0b1, [Qubit(5)])   # 0b100000\n        32\n        &gt;&gt;&gt; expand_ket(0b00111, 0b0, [Qubit(5)])   # 0b000111\n        7\n        &gt;&gt;&gt; expand_ket(0b00111, 0b1, [Qubit(5)])   # 0b100111\n        39\n        &gt;&gt;&gt; expand_ket(0b0000, 0b000, [Qubit(1), Qubit(2), Qubit(3)])    # 0b0000\n        0\n        &gt;&gt;&gt; expand_ket(0b0000, 0b001, [Qubit(1), Qubit(2), Qubit(3)])    # 0b0010\n        2\n        &gt;&gt;&gt; expand_ket(0b0000, 0b011, [Qubit(1), Qubit(2), Qubit(3)])    # 0b0110\n        6\n        &gt;&gt;&gt; expand_ket(0b0000, 0b101, [Qubit(1), Qubit(2), Qubit(3)])   # 0b1010\n        10\n        &gt;&gt;&gt; expand_ket(0b0001, 0b101, [Qubit(1), Qubit(2), Qubit(3)])   # 0b1011\n        11\n    \"\"\"\n    expanded_ket = base_ket\n    for i, qubit in enumerate(qubits):\n        expanded_ket &amp;= ~(1 &lt;&lt; qubit.index)  # Erase bit.\n        expanded_ket |= ((reduced_ket &amp; (1 &lt;&lt; i)) &gt;&gt; i) &lt;&lt; qubit.index  # Set bit to value from reduced_ket.\n\n    return expanded_ket\n</code></pre>"},{"location":"reference/#opensquirrel.utils.matrix_expander.get_matrix","title":"<code>get_matrix(gate, number_of_qubits)</code>","text":"<p>Compute the unitary matrix corresponding to the gate applied to those qubit operands, taken among any number of qubits. This can be used for, e.g., - testing, - permuting the operands of multi-qubit gates, - simulating a circuit (simulation in this way is inefficient for large numbers of qubits).</p> <p>Parameters:</p> Name Type Description Default <code>gate</code> <code>Gate</code> <p>The gate, including the qubits on which it is operated on.</p> required <code>number_of_qubits</code> <code>int</code> <p>The total number of qubits.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; X = lambda q: BlochSphereRotation(qubit=q, axis=(1, 0, 0), angle=math.pi, phase=math.pi / 2)\n&gt;&gt;&gt; get_matrix(X(Qubit(1)), 2).astype(int)           # X q[1]\narray([[0, 0, 1, 0],\n       [0, 0, 0, 1],\n       [1, 0, 0, 0],\n       [0, 1, 0, 0]])\n</code></pre> <pre><code>&gt;&gt;&gt; CNOT02 = ControlledGate(Qubit(0), X(Qubit(2)))\n&gt;&gt;&gt; get_matrix(CNOT02, 3).astype(int)     # CNOT q[0], q[2]\narray([[1, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 1, 0, 0],\n       [0, 0, 1, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 1],\n       [0, 0, 0, 0, 1, 0, 0, 0],\n       [0, 1, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 1, 0],\n       [0, 0, 0, 1, 0, 0, 0, 0]])\n&gt;&gt;&gt; get_matrix(ControlledGate(Qubit(1), X(Qubit(2))), 3).astype(int)     # CNOT q[1], q[2]\narray([[1, 0, 0, 0, 0, 0, 0, 0],\n       [0, 1, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 1, 0],\n       [0, 0, 0, 0, 0, 0, 0, 1],\n       [0, 0, 0, 0, 1, 0, 0, 0],\n       [0, 0, 0, 0, 0, 1, 0, 0],\n       [0, 0, 1, 0, 0, 0, 0, 0],\n       [0, 0, 0, 1, 0, 0, 0, 0]])\n</code></pre> Source code in <code>opensquirrel\\utils\\matrix_expander.py</code> <pre><code>def get_matrix(gate: Gate, number_of_qubits: int) -&gt; np.ndarray:\n    \"\"\"\n    Compute the unitary matrix corresponding to the gate applied to those qubit operands, taken among any number of qubits.\n    This can be used for, e.g.,\n    - testing,\n    - permuting the operands of multi-qubit gates,\n    - simulating a circuit (simulation in this way is inefficient for large numbers of qubits).\n\n    Args:\n        gate: The gate, including the qubits on which it is operated on.\n        number_of_qubits: The total number of qubits.\n\n    Examples:\n        &gt;&gt;&gt; X = lambda q: BlochSphereRotation(qubit=q, axis=(1, 0, 0), angle=math.pi, phase=math.pi / 2)\n        &gt;&gt;&gt; get_matrix(X(Qubit(1)), 2).astype(int)           # X q[1]\n        array([[0, 0, 1, 0],\n               [0, 0, 0, 1],\n               [1, 0, 0, 0],\n               [0, 1, 0, 0]])\n\n        &gt;&gt;&gt; CNOT02 = ControlledGate(Qubit(0), X(Qubit(2)))\n        &gt;&gt;&gt; get_matrix(CNOT02, 3).astype(int)     # CNOT q[0], q[2]\n        array([[1, 0, 0, 0, 0, 0, 0, 0],\n               [0, 0, 0, 0, 0, 1, 0, 0],\n               [0, 0, 1, 0, 0, 0, 0, 0],\n               [0, 0, 0, 0, 0, 0, 0, 1],\n               [0, 0, 0, 0, 1, 0, 0, 0],\n               [0, 1, 0, 0, 0, 0, 0, 0],\n               [0, 0, 0, 0, 0, 0, 1, 0],\n               [0, 0, 0, 1, 0, 0, 0, 0]])\n        &gt;&gt;&gt; get_matrix(ControlledGate(Qubit(1), X(Qubit(2))), 3).astype(int)     # CNOT q[1], q[2]\n        array([[1, 0, 0, 0, 0, 0, 0, 0],\n               [0, 1, 0, 0, 0, 0, 0, 0],\n               [0, 0, 0, 0, 0, 0, 1, 0],\n               [0, 0, 0, 0, 0, 0, 0, 1],\n               [0, 0, 0, 0, 1, 0, 0, 0],\n               [0, 0, 0, 0, 0, 1, 0, 0],\n               [0, 0, 1, 0, 0, 0, 0, 0],\n               [0, 0, 0, 1, 0, 0, 0, 0]])\n    \"\"\"\n\n    expander = MatrixExpander(number_of_qubits)\n    return gate.accept(expander)\n</code></pre>"},{"location":"reference/#opensquirrel.utils.matrix_expander.get_reduced_ket","title":"<code>get_reduced_ket(ket, qubits)</code>","text":"<p>Given a quantum ket represented by its corresponding base-10 integer, this computes the reduced ket where only the given qubits appear, in order. Roughly equivalent to the <code>pext</code> assembly instruction (bits extraction).</p> <p>Parameters:</p> Name Type Description Default <code>ket</code> <code>int</code> <p>A quantum ket, represented by its corresponding non-negative integer.  By convention, qubit #0 corresponds to the least significant bit.</p> required <code>qubits</code> <code>List[Qubit]</code> <p>The indices of the qubits to extract. Order matters.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The non-negative integer corresponding to the reduced ket.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; get_reduced_ket(1, [Qubit(0)])         # 0b01\n1\n&gt;&gt;&gt; get_reduced_ket(1111, [Qubit(2)])      # 0b01\n1\n&gt;&gt;&gt; get_reduced_ket(1111, [Qubit(5)])      # 0b0\n0\n&gt;&gt;&gt; get_reduced_ket(1111, [Qubit(2), Qubit(5)])   # 0b01\n1\n&gt;&gt;&gt; get_reduced_ket(101, [Qubit(1), Qubit(0)])    # 0b10\n2\n&gt;&gt;&gt; get_reduced_ket(101, [Qubit(0), Qubit(1)])    # 0b01\n1\n</code></pre> Source code in <code>opensquirrel\\utils\\matrix_expander.py</code> <pre><code>def get_reduced_ket(ket: int, qubits: List[Qubit]) -&gt; int:\n    \"\"\"\n    Given a quantum ket represented by its corresponding base-10 integer, this computes the reduced ket\n    where only the given qubits appear, in order.\n    Roughly equivalent to the `pext` assembly instruction (bits extraction).\n\n    Args:\n        ket: A quantum ket, represented by its corresponding non-negative integer.\n             By convention, qubit #0 corresponds to the least significant bit.\n        qubits: The indices of the qubits to extract. Order matters.\n\n    Returns:\n        The non-negative integer corresponding to the reduced ket.\n\n    Examples:\n        &gt;&gt;&gt; get_reduced_ket(1, [Qubit(0)])         # 0b01\n        1\n        &gt;&gt;&gt; get_reduced_ket(1111, [Qubit(2)])      # 0b01\n        1\n        &gt;&gt;&gt; get_reduced_ket(1111, [Qubit(5)])      # 0b0\n        0\n        &gt;&gt;&gt; get_reduced_ket(1111, [Qubit(2), Qubit(5)])   # 0b01\n        1\n        &gt;&gt;&gt; get_reduced_ket(101, [Qubit(1), Qubit(0)])    # 0b10\n        2\n        &gt;&gt;&gt; get_reduced_ket(101, [Qubit(0), Qubit(1)])    # 0b01\n        1\n    \"\"\"\n    reduced_ket = 0\n    for i, qubit in enumerate(qubits):\n        reduced_ket |= ((ket &amp; (1 &lt;&lt; qubit.index)) &gt;&gt; qubit.index) &lt;&lt; i\n\n    return reduced_ket\n</code></pre>"},{"location":"reference/#opensquirrel.zyz_decomposer.get_zyz_decomposition_angles","title":"<code>get_zyz_decomposition_angles(alpha, axis)</code>","text":"<p>Gives the angles used in the Z-Y-Z decomposition of the Bloch sphere rotation characterized by a rotation around <code>axis</code> of angle <code>alpha</code>.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>float</code> <p>angle of the Bloch sphere rotation</p> required <code>axis</code> <code>Tuple[float, float, float]</code> <p>normalized axis of the Bloch sphere rotation</p> required <p>Returns:</p> Type Description <code>float</code> <p>A triple (theta1, theta2, theta3) corresponding to the decomposition of the</p> <code>float</code> <p>arbitrary Bloch sphere rotation into U = rz(theta3) ry(theta2) rz(theta1)</p> Source code in <code>opensquirrel\\zyz_decomposer.py</code> <pre><code>def get_zyz_decomposition_angles(alpha: float, axis: Tuple[float, float, float]) -&gt; Tuple[float, float, float]:\n    \"\"\"\n    Gives the angles used in the Z-Y-Z decomposition of the Bloch sphere rotation\n    characterized by a rotation around `axis` of angle `alpha`.\n\n    Parameters:\n        alpha: angle of the Bloch sphere rotation\n        axis: _normalized_ axis of the Bloch sphere rotation\n\n    Returns:\n        A triple (theta1, theta2, theta3) corresponding to the decomposition of the\n        arbitrary Bloch sphere rotation into U = rz(theta3) ry(theta2) rz(theta1)\n\n    \"\"\"\n    nx, ny, nz = axis\n\n    assert abs(nx**2 + ny**2 + nz**2 - 1) &lt; ATOL, \"Axis needs to be normalized\"\n\n    assert -math.pi + ATOL &lt; alpha &lt;= math.pi + ATOL, \"Angle needs to be normalized\"\n\n    if abs(alpha - math.pi) &lt; ATOL:\n        # alpha == pi, math.tan(alpha / 2) is not defined.\n\n        if abs(nz) &lt; ATOL:\n            theta2 = math.pi\n            p = 0\n            m = 2 * math.acos(ny)\n\n        else:\n            p = math.pi\n            theta2 = 2 * math.acos(nz)\n\n            if abs(nz - 1) &lt; ATOL or abs(nz + 1) &lt; ATOL:\n                m = p  # This can be anything, but setting m = p means theta3 == 0, which is better for gate count.\n            else:\n                m = 2 * math.acos(ny / math.sqrt(1 - nz**2))\n\n    else:\n        p = 2 * math.atan2(nz * math.sin(alpha / 2), math.cos(alpha / 2))\n\n        acos_argument = math.cos(alpha / 2) * math.sqrt(1 + (nz * math.tan(alpha / 2)) ** 2)\n\n        # This fixes float approximations like 1.0000000000002 which acos doesn't like.\n        acos_argument = max(min(acos_argument, 1.0), -1.0)\n\n        theta2 = 2 * math.acos(acos_argument)\n        theta2 = math.copysign(theta2, alpha)\n\n        if abs(math.sin(theta2 / 2)) &lt; ATOL:\n            m = p  # This can be anything, but setting m = p means theta3 == 0, which is better for gate count.\n        else:\n            acos_argument = ny * math.sin(alpha / 2) / math.sin(theta2 / 2)\n\n            # This fixes float approximations like 1.0000000000002 which acos doesn't like.\n            acos_argument = max(min(acos_argument, 1.0), -1.0)\n\n            m = 2 * math.acos(acos_argument)\n\n    theta1 = (p + m) / 2\n\n    theta3 = p - theta1\n\n    return theta1, theta2, theta3\n</code></pre>"},{"location":"tutorial/","title":"Tutorial","text":""},{"location":"tutorial/#installation","title":"Installation","text":"<p>OpenSquirrel is available through the Python Package Index (PyPI). Accordingly, the installation is as easy as ABC:</p> <pre><code>! pip install opensquirrel\n\nimport opensquirrel\n</code></pre>"},{"location":"tutorial/#creating-a-circuit","title":"Creating a circuit","text":"<p>OpenSquirrel's entrypoint is the <code>Circuit</code>, which represents a quantum circuit. You can create a circuit in two different ways:  1. form a string written in the cQASM 3.0 quantum programming language, or;  2. by using OpenSquirrel's <code>CircuitBuilder</code> in Python.</p>"},{"location":"tutorial/#1-from-a-cqasm-30-string","title":"1. From a cQASM 3.0 string","text":"<pre><code>from opensquirrel import Circuit\n\nmy_circuit = Circuit.from_string(\n    \"\"\"\n    version 3.0\n\n    qubit[2] q\n    h q[0]; cnot q[0], q[1] // Create a Bell pair\n    \"\"\"\n)\nmy_circuit\n</code></pre> <pre><code>version 3.0\n\nqubit[2] q\n\nh q[0]\ncnot q[0], q[1]\n</code></pre> <p>Note: Currently OpenSquirrel only supports a limited version of the quantum programming language cQASM 3.0. This is due to the fact that the latter is still under development. When new features are introduced to the language, OpenSquirrel will follow in due course. For example, at the time of writing, OpenSquirrel only supports the declaration of a single qubit register per quantum program, whereas the language already allows for the declaration of multiple qubit registers within the global scope of the quantum program. Both the language and OpenSquirrel are under continuous development. Nevertheless, the language features that are supported by OpenSquirrel function properly.</p>"},{"location":"tutorial/#2-using-opensquirrels-circuitbuilder","title":"2. Using OpenSquirrel's <code>CircuitBuilder</code>","text":"<p>For creation of a circuit through Python, the <code>CircuitBuilder</code> can be used accordingly:</p> <pre><code>from opensquirrel import CircuitBuilder\nfrom opensquirrel.squirrel_ir import Qubit, Int, Float\n\nmy_circuit_from_builder = CircuitBuilder(number_of_qubits=2).ry(Qubit(0), Float(0.23)).cnot(Qubit(0), Qubit(1)).to_circuit()\nmy_circuit_from_builder\n</code></pre> <pre><code>version 3.0\n\nqubit[2] q\n\nry q[0], 0.23\ncnot q[0], q[1]\n</code></pre> <p>You can naturally use the functionalities available in Python to create your circuit:</p> <pre><code>builder = CircuitBuilder(number_of_qubits=10)\nfor i in range(0, 10, 2):\n    builder.h(Qubit(i))\n\nbuilder.to_circuit()\n</code></pre> <pre><code>version 3.0\n\nqubit[10] q\n\nh q[0]\nh q[2]\nh q[4]\nh q[6]\nh q[8]\n</code></pre> <p>For instance, you can generate a quantum fourier transform (QFT) circuit as follows:</p> <pre><code>number_of_qubits = 5\nqft = CircuitBuilder(number_of_qubits=number_of_qubits)\nfor i in range(number_of_qubits):\n      qft.h(Qubit(i))\n      for c in range(i + 1, number_of_qubits):\n            qft.crk(Qubit(c), Qubit(i), Int(c-i+1))\n\nqft.to_circuit()\n</code></pre> <pre><code>version 3.0\n\nqubit[5] q\n\nh q[0]\ncrk q[1], q[0], 2\ncrk q[2], q[0], 3\ncrk q[3], q[0], 4\ncrk q[4], q[0], 5\nh q[1]\ncrk q[2], q[1], 2\ncrk q[3], q[1], 3\ncrk q[4], q[1], 4\nh q[2]\ncrk q[3], q[2], 2\ncrk q[4], q[2], 3\nh q[3]\ncrk q[4], q[3], 2\nh q[4]\n</code></pre>"},{"location":"tutorial/#strong-types","title":"Strong types","text":"<p>As you can see, gates require strong types. For instance, you cannot do:</p> <pre><code>try:\n    Circuit.from_string(\n        \"\"\"\n        version 3.0\n        qubit[2] q\n\n        cnot q[0], 3 // The CNOT expects a qubit as second argument.\n        \"\"\"\n    )\nexcept Exception as e:\n    print(e)\n</code></pre> <pre><code>Argument #1 passed to gate `cnot` is of type &lt;class 'opensquirrel.squirrel_ir.Int'&gt; but should be &lt;class 'opensquirrel.squirrel_ir.Qubit'&gt;\n</code></pre> <p>The issue is that the CNOT expects a qubit as second input argument, where an integer has been provided. By default, OpenSquirrel does not use LibQASM (the cQASM parser library), but will do so soon. You can enable this, which changes the error message:</p> <pre><code>try:\n    Circuit.from_string(\n        \"\"\"\n        version 3.0\n        qubit[2] q\n\n        cnot q[0], 3 // The CNOT expects a qubit as second argument.\n        \"\"\",\n        use_libqasm=True\n    )\nexcept Exception as e:\n    print(e)\n</code></pre> <pre><code>Parsing error: Error at &lt;unknown&gt;:5:9..13: failed to resolve overload for cnot with argument pack (qubit, int)\n</code></pre> <p>The same holds for the <code>CircuitBuilder</code>, i.e., it also throws an error if arguments are passed of an unexpected type:</p> <pre><code>try:\n    CircuitBuilder(number_of_qubits=2).cnot(Qubit(0), Int(3))\nexcept Exception as e:\n    print(e)\n</code></pre> <pre><code>Wrong argument type for gate `cnot`, got &lt;class 'opensquirrel.squirrel_ir.Int'&gt; but expected &lt;class 'opensquirrel.squirrel_ir.Qubit'&gt;\n</code></pre>"},{"location":"tutorial/#modifying-a-circuit","title":"Modifying a circuit","text":""},{"location":"tutorial/#merging-gates","title":"Merging gates","text":"<p>OpenSquirrel can merge consecutive quantum gates. Currently, this is only done for single-qubit gates. The resulting gate is labeled as an \"anonymous gate\". Since those gates have no name, the placeholder <code>&lt;anonymous-gate&gt;</code> is used instead.</p> <pre><code>import math\n\nbuilder = CircuitBuilder(number_of_qubits=1)\nfor i in range(16):\n  builder.rx(Qubit(0), Float(math.pi / 16))\n\ncircuit = builder.to_circuit()\n\n# Merge single qubit gates\ncircuit.merge_single_qubit_gates()\ncircuit\n</code></pre> <pre><code>version 3.0\n\nqubit[1] q\n\n&lt;anonymous-gate&gt;\n</code></pre> <p>You can inspect what the gate has become in terms of the Bloch sphere rotation it represents:</p> <pre><code>circuit.squirrel_ir.statements[0]\n</code></pre> <pre><code>BlochSphereRotation(Qubit[0], axis=[1. 0. 0.], angle=3.141592653589795, phase=0.0)\n</code></pre> <p>In the above example, OpenSquirrel has merged all the Rx gates together. Yet, for now, OpenSquirrel does not recognize that this results in a single Rx over the cumulated angle of the individual rotations. Moreover, it does not recognize that the result corresponds to the X-gate (up to a global phase difference). At a later stage, we may want OpenSquirrel to recognize the resultant gate in the case it is part of the set of known gates.</p> <p>The gate set is, however, not immutable. In the following section, we demonstrate how new gates can be defined and added to the default gate set.</p>"},{"location":"tutorial/#defining-your-own-quantum-gates","title":"Defining your own quantum gates","text":"<p>OpenSquirrel accepts any new gate and requires its definition in terms of a semantic. Creating new gates is done using Python functions, decorators, and one of the following gate semantic classes: <code>BlochSphereRotation</code>, <code>ControlledGate</code>, or <code>MatrixGate</code>.</p> <ul> <li>The <code>BlochSphereRotation</code> class is used to define an arbitrary single qubit gate. It accepts a qubit, an axis, an angle, and a phase as arguments. Below is shown how the X-gate is defined in the default gate set of OpenSquirrel:</li> </ul> <pre><code>@named_gate\ndef x(q: Qubit) -&gt; Gate:\n    return BlochSphereRotation(qubit=q, axis=(1, 0, 0), angle=math.pi, phase=math.pi / 2)\n</code></pre> <p>Notice the <code>@named_gate</code> decorator. This tells OpenSquirrel that the function defines a gate and that it should, therefore, have all the nice properties OpenSquirrel expects of it. When you define a gate as such, it also creates a gate in the accompanying cQASM 3.0 parser taking the same arguments as the Python function.</p> <ul> <li>The <code>ControlledGate</code> class is used to define a multiple qubit gate that comprises a controlled operation. For instance, the CNOT gate is defined in the default gate set of OpenSquirrel as follows:</li> </ul> <pre><code>@named_gate\ndef cnot(control: Qubit, target: Qubit) -&gt; Gate:\n    return ControlledGate(control, x(target))\n</code></pre> <ul> <li>The <code>MatrixGate</code> class may be used to define a gate in the generic form of a matrix:</li> </ul> <pre><code>@named_gate\ndef swap(q1: Qubit, q2: Qubit) -&gt; Gate:\n    return MatrixGate(\n        np.array(\n            [\n                [1, 0, 0, 0],\n                [0, 0, 1, 0],\n                [0, 1, 0, 0],\n                [0, 0, 0, 1],\n            ]\n        ),\n        [q1, q2],\n    )\n</code></pre> <p>Once you have defined your new quantum gates, you can pass them as a custom <code>gate_set</code> argument to the <code>Circuit</code> object. Here is how to add, e.g., the Sycamore gate (labeled as <code>syc</code>) on top of the existing default gate set of OpenSquirrel:</p> <pre><code>import numpy as np\nimport cmath\nfrom opensquirrel import default_gates\nfrom opensquirrel.squirrel_ir import named_gate, MatrixGate\n\n# Definition of the Sycamore gate as a MatrixGate\n@named_gate\ndef syc(q1: Qubit, q2: Qubit):\n      return MatrixGate(\n            matrix=np.array([\n                [1, 0, 0, 0],\n                [0, 0, -1j, 0],\n                [0, -1j, 0, 0],\n                [0, 0, 0, cmath.rect(1, - math.pi / 6)]\n                ]),\n            operands=[q1, q2]\n      )\n\nmy_extended_gate_set = default_gates.default_gate_set.copy()\nmy_extended_gate_set.append(syc)\n\nmy_sycamore_circuit = Circuit.from_string(\n    \"\"\"\n    version 3.0\n    qubit[3] q\n\n    h q[1]\n    syc q[1], q[2]\n    cnot q[0], q[1]\n    \"\"\",\n    gate_set=my_extended_gate_set\n)\n</code></pre>"},{"location":"tutorial/#gate-decomposition","title":"Gate decomposition","text":"<p>OpenSquirrel can decompose the gates of a quantum circuit, given a specific decomposition. OpenSquirrel offers several, so-called, decomposers out of the box, but users can also make their own decomposer and apply them to the circuit. Decompositions can be:    1. predefined, or;    2. inferred from the gate semantics.</p>"},{"location":"tutorial/#1-predefined-decomposition","title":"1. Predefined decomposition","text":"<p>The first kind of decomposition is when you want to replace a particular gate in the circuit, like the CNOT gate, with a fixed list of gates. It is commonly known that CNOT can be decomposed as H-CZ-H. This decomposition is demonstrated below using a Python lambda function, which requires the same parameters as the gate that is decomposed:</p> <pre><code>from opensquirrel.default_gates import cnot, h, cz\n\ncircuit = Circuit.from_string(\n    \"\"\"\n    version 3.0\n    qubit[3] q\n\n    x q[0:2]  // Note that this notation is expanded in OpenSquirrel.\n    cnot q[0], q[1]\n    ry q[2], 6.78\n    \"\"\"\n)\n\ncircuit.replace(cnot,\n                lambda control, target:\n                [\n                    h(target),\n                    cz(control, target),\n                    h(target),\n                ]\n            )\ncircuit\n</code></pre> <pre><code>version 3.0\n\nqubit[3] q\n\nx q[0]\nx q[1]\nx q[2]\nh q[1]\ncz q[0], q[1]\nh q[1]\nry q[2], 6.78\n</code></pre> <p>OpenSquirrel will check whether the provided decomposition is correct. For instance, an exception is thrown if we forget the final Hadamard, or H-gate, in our custom-made decomposition:</p> <pre><code>circuit = Circuit.from_string(\n    \"\"\"\n    version 3.0\n    qubit[3] q\n\n    x q[0:2]\n    cnot q[0], q[1]\n    ry q[2], 6.78\n    \"\"\"\n)\n\ntry:\n  circuit.replace(cnot,\n                  lambda control, target:\n                  [\n                      h(target),\n                      cz(control, target),\n                  ]\n)\n\nexcept Exception as e:\n  print(e)\n</code></pre> <pre><code>Replacement for gate cnot does not preserve the quantum state\n</code></pre>"},{"location":"tutorial/#2-inferred-decomposition","title":"2. Inferred decomposition","text":"<p>On top of decompositions of a single gate, OpenSquirrel can decompose gates based on their semantics, regardless of name. To give an example, let us decompose an arbitrary single qubit gate into a product of axis rotations ZYZ; note that these are not Y- and Z-gates, but Ry and Rz rotations gates.</p> <p>First, we need to figure out the mathmatics behind this decomposition. Let us use quaternions and the Python library for symbolic mathematics SymPy for this; it will make things a lot easier. A 3D rotation of angle \\(\\alpha\\) about the (normalized) axis \\(n=\\left(n_x, n_y, n_z \\right)\\) can be represented by the quaternion \\(q = \\cos\\left(\\alpha/2\\right) + \\sin\\left(\\alpha/2\\right) \\left( n_x i + n_y j + n_z k \\right)\\). Since composition of rotations is equivalent to the product of their quaternions, we have to find the angles \\(\\theta_1\\), \\(\\theta_2\\) and \\(\\theta_3\\) such that</p> \\[\\begin{align} q = &amp;\\left[ \\cos\\left(\\frac{\\theta_1}{2}\\right) + k \\sin\\left(\\frac{\\theta_1}{2}\\right) \\right]\\\\ &amp;\\times\\left[ \\cos\\left(\\frac{\\theta_2}{2}\\right) + j \\sin\\left(\\frac{\\theta_2}{2}\\right) \\right]\\\\ &amp;\\times\\left[ \\cos\\left(\\frac{\\theta_3}{2}\\right) + k \\sin\\left(\\frac{\\theta_3}{2}\\right) \\right]\\ . \\end{align} \\] <p>Let us expand this last term with SymPy:</p> <pre><code>! pip install sympy\n</code></pre> <pre><code>import sympy as sp\n\ntheta1, theta2, theta3 = sp.symbols(\"theta_1 theta_2 theta_3\")\n\nz1 = sp.algebras.Quaternion.from_axis_angle((0, 0, 1), theta1)\ny = sp.algebras.Quaternion.from_axis_angle((0, 1, 0), theta2)\nz2 = sp.algebras.Quaternion.from_axis_angle((0, 0, 1), theta3)\n\nrhs = sp.trigsimp(sp.expand(z1 * y * z2))\nrhs\n</code></pre> \\[ \\cos{\\left(\\frac{\\theta_{2}}{2} \\right)} \\cos{\\left(\\frac{\\theta_{1} + \\theta_{3}}{2} \\right)} + - \\sin{\\left(\\frac{\\theta_{2}}{2} \\right)} \\sin{\\left(\\frac{\\theta_{1} - \\theta_{3}}{2} \\right)} i + \\sin{\\left(\\frac{\\theta_{2}}{2} \\right)} \\cos{\\left(\\frac{\\theta_{1} - \\theta_{3}}{2} \\right)} j + \\sin{\\left(\\frac{\\theta_{1} + \\theta_{3}}{2} \\right)} \\cos{\\left(\\frac{\\theta_{2}}{2} \\right)} k\\] <p>Let us change variables and define \\(p\\equiv\\theta_1 + \\theta_3\\) and \\(m\\equiv\\theta_1 - \\theta_3\\).</p> <pre><code>p, m = sp.symbols(\"p m\")\n\nrhs_simplified = rhs.subs({\n    theta1 + theta3: p,\n    theta1 - theta3: m\n})\n\nrhs_simplified\n</code></pre> \\[ \\cos{\\left(\\frac{p}{2} \\right)} \\cos{\\left(\\frac{\\theta_{2}}{2} \\right)} + - \\sin{\\left(\\frac{m}{2} \\right)} \\sin{\\left(\\frac{\\theta_{2}}{2} \\right)} i + \\sin{\\left(\\frac{\\theta_{2}}{2} \\right)} \\cos{\\left(\\frac{m}{2} \\right)} j + \\sin{\\left(\\frac{p}{2} \\right)} \\cos{\\left(\\frac{\\theta_{2}}{2} \\right)} k\\] <p>The original quaternion \\(q\\) can be defined in Sympy accordingly:</p> <pre><code>alpha, nx, ny, nz = sp.symbols(\"alpha n_x n_y n_z\")\n\nq = sp.algebras.Quaternion.from_axis_angle((nx, ny, nz), alpha).subs({\n    nx**2 + ny**2 + nz**2: 1  # We assume the axis is normalized.\n})\nq\n</code></pre> \\[ \\cos{\\left(\\frac{\\alpha}{2} \\right)} + n_{x} \\sin{\\left(\\frac{\\alpha}{2} \\right)} i + n_{y} \\sin{\\left(\\frac{\\alpha}{2} \\right)} j + n_{z} \\sin{\\left(\\frac{\\alpha}{2} \\right)} k\\] <p>We get the following system of equations, where the unknowns are \\(p\\), \\(m\\), and \\(\\theta_2\\):</p> <pre><code>from IPython.display import display, Math\n\ndisplay(\n    sp.Eq(rhs_simplified.a, q.a),\n    sp.Eq(rhs_simplified.b, q.b),\n    sp.Eq(rhs_simplified.c, q.c),\n    sp.Eq(rhs_simplified.d, q.d)\n    )\n</code></pre> \\[ \\cos{\\left(\\frac{p}{2} \\right)} \\cos{\\left(\\frac{\\theta_{2}}{2} \\right)} = \\cos{\\left(\\frac{\\alpha}{2} \\right)}\\] \\[ - \\sin{\\left(\\frac{m}{2} \\right)} \\sin{\\left(\\frac{\\theta_{2}}{2} \\right)} = n_{x} \\sin{\\left(\\frac{\\alpha}{2} \\right)}\\] \\[ \\sin{\\left(\\frac{\\theta_{2}}{2} \\right)} \\cos{\\left(\\frac{m}{2} \\right)} = n_{y} \\sin{\\left(\\frac{\\alpha}{2} \\right)}\\] \\[ \\sin{\\left(\\frac{p}{2} \\right)} \\cos{\\left(\\frac{\\theta_{2}}{2} \\right)} = n_{z} \\sin{\\left(\\frac{\\alpha}{2} \\right)}\\] <p>This system can be solved using Sympy, but we obtain a rather ugly solution after some computation time:</p> <p><pre><code># sp.solve([q.a - rhs.a, q.b - rhs.b, q.c - rhs.c, q.d - rhs.d], theta1, theta2, theta3) # Using this we obtain a rather ugly solution after some computation time ...\n</code></pre> Instead, we assume \\(\\sin(p/2) \\neq 0\\), such that we can substitute in the first equation \\(\\cos\\left(\\theta_2/2\\right)\\) with its value computed from the last equation. We find:</p> <pre><code>sp.trigsimp(sp.Eq(rhs_simplified.a, q.a).subs(sp.cos(theta2 / 2), nz * sp.sin(alpha / 2) / sp.sin(p / 2)))\n</code></pre> \\[ \\frac{n_{z} \\sin{\\left(\\frac{\\alpha}{2} \\right)}}{\\tan{\\left(\\frac{p}{2} \\right)}} = \\cos{\\left(\\frac{\\alpha}{2} \\right)}\\] <p>Therefore,</p> \\[p=\\theta_1+\\theta_3=2\\arctan\\left[n_z\\tan\\left(\\frac{\\alpha}{2}\\right)\\right]\\] <p>We can then deduce</p> \\[\\begin{array}{rl}\\theta_2 &amp;=2\\arccos\\left[\\cos\\left(\\frac{\\alpha}{2}\\right)\\cos^{-1}\\left(\\frac{p}{2}\\right)\\right] \\\\ &amp;=2\\arccos\\left[ \\cos\\left(\\frac{\\alpha}{2}\\right)\\sqrt{1+n_z^2\\tan^2\\left(\\frac{\\alpha}{2}\\right)}\\right] \\\\ \\end{array}\\] <p>Using the third equation, we can finally infer the value of \\(m\\):</p> \\[m=\\theta_1-\\theta_3=2\\arccos\\left[\\frac{n_y\\sin\\left(\\frac{\\alpha}{2}\\right)}{\\sin\\left(\\frac{\\theta_2}{2}\\right)}\\right]\\] <p>Let us put this into code...</p> <pre><code>from typing import Tuple\n\nATOL = 0.0001\n\ndef theta123(alpha: float, axis: Tuple[float, float, float]):\n    \"\"\"\n    Gives the angles used in the Z-Y-Z decomposition of the Bloch sphere rotation\n    characterized by a rotation around `axis` of angle `alpha`.\n\n    Parameters:\n      alpha: angle of the Bloch sphere rotation\n      axis: _normalized_ axis of the Bloch sphere rotation\n\n    Returns:\n      a triple (theta1, theta2, theta3) corresponding to the decomposition of the\n      arbitrary Bloch sphere rotation into U = rz(theta1) ry(theta2) rz(theta3)\n\n    \"\"\"\n\n    # CAUTION: there might be edge cases where this crashes.\n\n    nx, ny, nz = axis\n    assert abs(nx**2 + ny**2 + nz**2 - 1) &lt; ATOL, \"Axis needs to be normalized\"\n\n    ta2 = math.tan(alpha / 2)\n    theta2 = 2 * math.acos(math.cos(alpha / 2) * math.sqrt(1 + (nz * ta2) ** 2))\n\n    p = 2 * math.atan(nz * ta2)\n    m = 2 * math.acos(ny * math.sin(alpha / 2) / math.sin(theta2 / 2))\n\n    theta1 = (p + m) / 2\n    theta3 = p - theta1\n\n    return (theta1, theta2, theta3)\n</code></pre> <p>Once we have our angles, we can implement the OpenSquirrel decomposition; we will name it the <code>ZYZDecomposer</code>. Implementation is done by inheriting from the <code>Decomposer</code> base class and defining the <code>decompose</code> method, which in turn expects a gate and returns a list of gates. This method is applied internally to all gates of the circuit. Since 2-qubit gates should be left as-is, there is an <code>isinstance</code> check, to skip those. Also note that the axis of a <code>BlochSphereRotation</code> in OpenSquirrel is always normalized internally, and the angle should always be in the range \\([-\\pi, \\pi]\\).</p> <p>Here is what our final ZYZ decomposition looks like:</p> <pre><code>from opensquirrel.squirrel_ir import Gate, BlochSphereRotation\nfrom opensquirrel.replacer import Decomposer\nfrom opensquirrel.default_gates import rz, ry\n\nclass ZYZDecomposer(Decomposer):\n\n    def decompose(g: Gate) -&gt; [Gate]:\n        if not isinstance(g, BlochSphereRotation):\n          return [g] # Do nothing.\n\n        theta1, theta2, theta3 = theta123(g.angle, g.axis)\n\n        z1 = rz(g.qubit, Float(theta1))\n        y = ry(g.qubit, Float(theta2))\n        z2 = rz(g.qubit, Float(theta3))\n\n        # Note: written like this, the decomposition doesn't preserve the global phase, which is fine\n        # since the global phase is a physically irrelevant artifact of the mathematical\n        # model we use to describe the quantum system.\n\n        # Should we want to preserve it, we would need to use a raw BlochSphereRotation, which would then\n        # be an anonymous gate in the resulting decomposed circuit:\n        # z2 = BlochSphereRotation(qubit=g.qubit, angle=theta3, axis=(0, 0, 1), phase = g.phase)\n\n        return [z1, y, z2]\n</code></pre> <p>Once we defined the decomposition function, we can apply it by passing our decomposer to the <code>decompose()</code> method of the circuit. The decomposition of every gate is checked, to see if it preserves the circuit semantics (i.e., the unitary matrix), so we can sleep on both ears knowing that our circuit/quantum state remains the same.</p> <pre><code>circuit_to_decompose = Circuit.from_string(\n    \"\"\"\n    version 3.0\n\n    qubit[3] q\n\n    h q[0]\n    \"\"\"\n)\n\ncircuit_to_decompose.merge_single_qubit_gates()\ncircuit_to_decompose.decompose(decomposer=ZYZDecomposer)\ncircuit_to_decompose\n</code></pre> <pre><code>version 3.0\n\nqubit[3] q\n\nrz q[0], 3.1415927\nry q[0], 1.5707963\nrz q[0], 0.0\n</code></pre> <p>We get the expected result for the Hadamard gate: H = Y\\(^{1/2}\\)Z, one of the canonical decompositions of the Hadamard gate as described in the Quantum Inspire knowledge base.</p>"},{"location":"tutorial/#exporting-a-circuit","title":"Exporting a circuit","text":"<p>As you have seen in the examples above, you can turn a circuit into a cQASM 3.0 string by simply using the <code>str</code> or <code>__repr__</code> methods. We are aiming to support the possibility to export to other languages as well, e.g., a OpenQASM 3.0 string, and frameworks, e.g., a Qiskit quantum circuit.</p>"},{"location":"C%3A/Users/elenbaascpc/projects/qi2/OpenSquirrel/OpenSquirrel/docs/reference/","title":"Reference","text":""},{"location":"C%3A/Users/elenbaascpc/projects/qi2/OpenSquirrel/OpenSquirrel/docs/reference/#opensquirrel.circuit.Circuit","title":"<code>Circuit</code>","text":"<p>The Circuit class is the only interface to access OpenSquirrel's features.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; c = Circuit.from_string(\"version 3.0; qubit[3] q; h q[0]\")\n&gt;&gt;&gt; c\nversion 3.0\n\nqubit[3] q\n\nh q[0]\n\n&gt;&gt;&gt; c.decompose(decomposer=mckay_decomposer.McKayDecomposer)\n&gt;&gt;&gt; c\nversion 3.0\n\nqubit[3] q\n\nx90 q[0]\nrz q[0], 1.5707963\nx90 q[0]\n</code></pre> Source code in <code>opensquirrel\\circuit.py</code> <pre><code>class Circuit:\n    \"\"\"The Circuit class is the only interface to access OpenSquirrel's features.\n\n    Examples:\n        &gt;&gt;&gt; c = Circuit.from_string(\"version 3.0; qubit[3] q; h q[0]\")\n        &gt;&gt;&gt; c\n        version 3.0\n        &lt;BLANKLINE&gt;\n        qubit[3] q\n        &lt;BLANKLINE&gt;\n        h q[0]\n        &lt;BLANKLINE&gt;\n        &gt;&gt;&gt; c.decompose(decomposer=mckay_decomposer.McKayDecomposer)\n        &gt;&gt;&gt; c\n        version 3.0\n        &lt;BLANKLINE&gt;\n        qubit[3] q\n        &lt;BLANKLINE&gt;\n        x90 q[0]\n        rz q[0], 1.5707963\n        x90 q[0]\n        &lt;BLANKLINE&gt;\n\n    \"\"\"\n\n    def __init__(self, squirrel_ir: SquirrelIR):\n        \"\"\"Create a circuit object from a SquirrelIR object.\"\"\"\n\n        self.squirrel_ir = squirrel_ir\n\n    @classmethod\n    def from_string(\n        cls,\n        cqasm3_string: str,\n        gate_set: [Callable[..., Gate]] = default_gate_set,\n        gate_aliases: Dict[str, Callable[..., Gate]] = default_gate_aliases,\n        use_libqasm: bool = False,\n    ):\n        \"\"\"Create a circuit object from a cQasm3 string. All the gates in the circuit need to be defined in\n        the `gates` argument.\n\n        * type-checking is performed, eliminating qubit indices errors and incoherencies\n        * checks that used gates are supported and mentioned in `gates` with appropriate signatures\n        * does not support map or variables, and other things...\n        * for example of `gates` dictionary, please look at TestGates.py\n\n\n        Args:\n            cqasm3_string: a cqasm 3 string\n            gate_set: an array of gate semantic functions. See default_gates for examples\n            gate_aliases: a dictionary of extra aliases, mapping strings to functions in the gate set\n            use_libqasm: if True, use libqasm instead of build-in ANTLR parser.\n                Note: those two separate implementations may diverge and libqasm should be taken as reference.\n\n        \"\"\"\n        if use_libqasm:\n            libqasm_ir_creator = LibqasmIRCreator(gate_set=gate_set, gate_aliases=gate_aliases)\n            return Circuit(libqasm_ir_creator.squirrel_ir_from_string(cqasm3_string))\n\n        return Circuit(\n            opensquirrel.parsing.antlr.squirrel_ir_from_string.squirrel_ir_from_string(\n                cqasm3_string, gate_set=gate_set, gate_aliases=gate_aliases\n            )\n        )\n\n    @property\n    def number_of_qubits(self) -&gt; int:\n        return self.squirrel_ir.number_of_qubits\n\n    @property\n    def qubit_register_name(self) -&gt; str:\n        return self.squirrel_ir.qubit_register_name\n\n    def merge_single_qubit_gates(self):\n        \"\"\"Merge all consecutive 1-qubit gates in the circuit.\n        Gates obtained from merging other gates become anonymous gates.\n        \"\"\"\n\n        merger.merge_single_qubit_gates(self.squirrel_ir)\n\n    def decompose(self, decomposer: Decomposer):\n        \"\"\"Generic decomposition pass. It applies the given decomposer function\n        to every gate in the circuit.\"\"\"\n        replacer.decompose(self.squirrel_ir, decomposer)\n\n    def replace(self, gate_generator: Callable[..., Gate], f):\n        \"\"\"Manually replace occurrences of a given gate with a list of gates.\n        `f` is a callable that takes the arguments of the gate that is to be replaced\n        and returns the decomposition as a list of gates.\n        \"\"\"\n\n        replacer.replace(self.squirrel_ir, gate_generator, f)\n\n    def test_get_circuit_matrix(self) -&gt; np.ndarray:\n        \"\"\"Get the (large) unitary matrix corresponding to the circuit.\n\n        * this matrix has 4**n elements, where n is the number of qubits\n        * therefore this function is only here for testing purposes on small number of qubits\n        * result is stored as a numpy array of complex numbers\n        \"\"\"\n\n        return circuit_matrix_calculator.get_circuit_matrix(self.squirrel_ir)\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Write the circuit to a cQasm3 string.\"\"\"\n\n        return writer.squirrel_ir_to_string(self.squirrel_ir)\n\n    def export(self, format: ExportFormat):\n        if format == ExportFormat.QUANTIFY_SCHEDULER:\n            return quantify_scheduler_exporter.export(self.squirrel_ir)\n\n        raise Exception(\"Unknown export format\")\n</code></pre>"},{"location":"C%3A/Users/elenbaascpc/projects/qi2/OpenSquirrel/OpenSquirrel/docs/reference/#opensquirrel.circuit.Circuit.__init__","title":"<code>__init__(squirrel_ir)</code>","text":"<p>Create a circuit object from a SquirrelIR object.</p> Source code in <code>opensquirrel\\circuit.py</code> <pre><code>def __init__(self, squirrel_ir: SquirrelIR):\n    \"\"\"Create a circuit object from a SquirrelIR object.\"\"\"\n\n    self.squirrel_ir = squirrel_ir\n</code></pre>"},{"location":"C%3A/Users/elenbaascpc/projects/qi2/OpenSquirrel/OpenSquirrel/docs/reference/#opensquirrel.circuit.Circuit.__repr__","title":"<code>__repr__()</code>","text":"<p>Write the circuit to a cQasm3 string.</p> Source code in <code>opensquirrel\\circuit.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Write the circuit to a cQasm3 string.\"\"\"\n\n    return writer.squirrel_ir_to_string(self.squirrel_ir)\n</code></pre>"},{"location":"C%3A/Users/elenbaascpc/projects/qi2/OpenSquirrel/OpenSquirrel/docs/reference/#opensquirrel.circuit.Circuit.decompose","title":"<code>decompose(decomposer)</code>","text":"<p>Generic decomposition pass. It applies the given decomposer function to every gate in the circuit.</p> Source code in <code>opensquirrel\\circuit.py</code> <pre><code>def decompose(self, decomposer: Decomposer):\n    \"\"\"Generic decomposition pass. It applies the given decomposer function\n    to every gate in the circuit.\"\"\"\n    replacer.decompose(self.squirrel_ir, decomposer)\n</code></pre>"},{"location":"C%3A/Users/elenbaascpc/projects/qi2/OpenSquirrel/OpenSquirrel/docs/reference/#opensquirrel.circuit.Circuit.from_string","title":"<code>from_string(cqasm3_string, gate_set=default_gate_set, gate_aliases=default_gate_aliases, use_libqasm=False)</code>  <code>classmethod</code>","text":"<p>Create a circuit object from a cQasm3 string. All the gates in the circuit need to be defined in the <code>gates</code> argument.</p> <ul> <li>type-checking is performed, eliminating qubit indices errors and incoherencies</li> <li>checks that used gates are supported and mentioned in <code>gates</code> with appropriate signatures</li> <li>does not support map or variables, and other things...</li> <li>for example of <code>gates</code> dictionary, please look at TestGates.py</li> </ul> <p>Parameters:</p> Name Type Description Default <code>cqasm3_string</code> <code>str</code> <p>a cqasm 3 string</p> required <code>gate_set</code> <code>[Callable[..., Gate]]</code> <p>an array of gate semantic functions. See default_gates for examples</p> <code>default_gate_set</code> <code>gate_aliases</code> <code>Dict[str, Callable[..., Gate]]</code> <p>a dictionary of extra aliases, mapping strings to functions in the gate set</p> <code>default_gate_aliases</code> <code>use_libqasm</code> <code>bool</code> <p>if True, use libqasm instead of build-in ANTLR parser. Note: those two separate implementations may diverge and libqasm should be taken as reference.</p> <code>False</code> Source code in <code>opensquirrel\\circuit.py</code> <pre><code>@classmethod\ndef from_string(\n    cls,\n    cqasm3_string: str,\n    gate_set: [Callable[..., Gate]] = default_gate_set,\n    gate_aliases: Dict[str, Callable[..., Gate]] = default_gate_aliases,\n    use_libqasm: bool = False,\n):\n    \"\"\"Create a circuit object from a cQasm3 string. All the gates in the circuit need to be defined in\n    the `gates` argument.\n\n    * type-checking is performed, eliminating qubit indices errors and incoherencies\n    * checks that used gates are supported and mentioned in `gates` with appropriate signatures\n    * does not support map or variables, and other things...\n    * for example of `gates` dictionary, please look at TestGates.py\n\n\n    Args:\n        cqasm3_string: a cqasm 3 string\n        gate_set: an array of gate semantic functions. See default_gates for examples\n        gate_aliases: a dictionary of extra aliases, mapping strings to functions in the gate set\n        use_libqasm: if True, use libqasm instead of build-in ANTLR parser.\n            Note: those two separate implementations may diverge and libqasm should be taken as reference.\n\n    \"\"\"\n    if use_libqasm:\n        libqasm_ir_creator = LibqasmIRCreator(gate_set=gate_set, gate_aliases=gate_aliases)\n        return Circuit(libqasm_ir_creator.squirrel_ir_from_string(cqasm3_string))\n\n    return Circuit(\n        opensquirrel.parsing.antlr.squirrel_ir_from_string.squirrel_ir_from_string(\n            cqasm3_string, gate_set=gate_set, gate_aliases=gate_aliases\n        )\n    )\n</code></pre>"},{"location":"C%3A/Users/elenbaascpc/projects/qi2/OpenSquirrel/OpenSquirrel/docs/reference/#opensquirrel.circuit.Circuit.merge_single_qubit_gates","title":"<code>merge_single_qubit_gates()</code>","text":"<p>Merge all consecutive 1-qubit gates in the circuit. Gates obtained from merging other gates become anonymous gates.</p> Source code in <code>opensquirrel\\circuit.py</code> <pre><code>def merge_single_qubit_gates(self):\n    \"\"\"Merge all consecutive 1-qubit gates in the circuit.\n    Gates obtained from merging other gates become anonymous gates.\n    \"\"\"\n\n    merger.merge_single_qubit_gates(self.squirrel_ir)\n</code></pre>"},{"location":"C%3A/Users/elenbaascpc/projects/qi2/OpenSquirrel/OpenSquirrel/docs/reference/#opensquirrel.circuit.Circuit.replace","title":"<code>replace(gate_generator, f)</code>","text":"<p>Manually replace occurrences of a given gate with a list of gates. <code>f</code> is a callable that takes the arguments of the gate that is to be replaced and returns the decomposition as a list of gates.</p> Source code in <code>opensquirrel\\circuit.py</code> <pre><code>def replace(self, gate_generator: Callable[..., Gate], f):\n    \"\"\"Manually replace occurrences of a given gate with a list of gates.\n    `f` is a callable that takes the arguments of the gate that is to be replaced\n    and returns the decomposition as a list of gates.\n    \"\"\"\n\n    replacer.replace(self.squirrel_ir, gate_generator, f)\n</code></pre>"},{"location":"C%3A/Users/elenbaascpc/projects/qi2/OpenSquirrel/OpenSquirrel/docs/reference/#opensquirrel.circuit.Circuit.test_get_circuit_matrix","title":"<code>test_get_circuit_matrix()</code>","text":"<p>Get the (large) unitary matrix corresponding to the circuit.</p> <ul> <li>this matrix has 4**n elements, where n is the number of qubits</li> <li>therefore this function is only here for testing purposes on small number of qubits</li> <li>result is stored as a numpy array of complex numbers</li> </ul> Source code in <code>opensquirrel\\circuit.py</code> <pre><code>def test_get_circuit_matrix(self) -&gt; np.ndarray:\n    \"\"\"Get the (large) unitary matrix corresponding to the circuit.\n\n    * this matrix has 4**n elements, where n is the number of qubits\n    * therefore this function is only here for testing purposes on small number of qubits\n    * result is stored as a numpy array of complex numbers\n    \"\"\"\n\n    return circuit_matrix_calculator.get_circuit_matrix(self.squirrel_ir)\n</code></pre>"},{"location":"C%3A/Users/elenbaascpc/projects/qi2/OpenSquirrel/OpenSquirrel/docs/reference/#opensquirrel.circuit_builder.CircuitBuilder","title":"<code>CircuitBuilder</code>","text":"<p>             Bases: <code>GateLibrary</code></p> <p>A class using the builder pattern to make construction of circuits easy from Python. Adds corresponding gate when a method is called. Checks gates are known and called with the right arguments. Mainly here to allow for Qiskit-style circuit construction:</p> Example <p>CircuitBuilder(number_of_qubits=3).h(Qubit(0)).cnot(Qubit(0), Qubit(1)).cnot(Qubit(0), Qubit(2)).to_circuit() version 3.0  qubit[3] q  h q[0] cnot q[0], q[1] cnot q[0], q[2]  Source code in <code>opensquirrel\\circuit_builder.py</code> <pre><code>class CircuitBuilder(GateLibrary):\n    \"\"\"\n    A class using the builder pattern to make construction of circuits easy from Python.\n    Adds corresponding gate when a method is called. Checks gates are known and called with the right arguments.\n    Mainly here to allow for Qiskit-style circuit construction:\n\n    Example:\n        &gt;&gt;&gt; CircuitBuilder(number_of_qubits=3).h(Qubit(0)).cnot(Qubit(0), Qubit(1)).cnot(Qubit(0), Qubit(2)).to_circuit()\n        version 3.0\n        &lt;BLANKLINE&gt;\n        qubit[3] q\n        &lt;BLANKLINE&gt;\n        h q[0]\n        cnot q[0], q[1]\n        cnot q[0], q[2]\n        &lt;BLANKLINE&gt;\n    \"\"\"\n\n    _default_qubit_register_name = \"q\"\n\n    def __init__(\n        self,\n        number_of_qubits: int,\n        gate_set: [Callable[..., Gate]] = default_gate_set,\n        gate_aliases: Dict[str, Callable[..., Gate]] = default_gate_aliases,\n    ):\n        GateLibrary.__init__(self, gate_set, gate_aliases)\n        self.squirrel_ir = SquirrelIR(\n            number_of_qubits=number_of_qubits, qubit_register_name=self._default_qubit_register_name\n        )\n\n    def __getattr__(self, attr):\n        def add_comment(comment_string: str):\n            self.squirrel_ir.add_comment(Comment(comment_string))\n            return self\n\n        def add_this_gate(*args):\n            generator_f = GateLibrary.get_gate_f(self, attr)\n\n            for i, par in enumerate(inspect.signature(generator_f).parameters.values()):\n                if not isinstance(args[i], par.annotation):\n                    raise TypeError(\n                        f\"Wrong argument type for gate `{attr}`, got {type(args[i])} but expected {par.annotation}\"\n                    )\n\n            self.squirrel_ir.add_gate(generator_f(*args))\n            return self\n\n        return add_comment if attr == \"comment\" else add_this_gate\n\n    def to_circuit(self) -&gt; Circuit:\n        return Circuit(self.squirrel_ir)\n</code></pre>"},{"location":"C%3A/Users/elenbaascpc/projects/qi2/OpenSquirrel/OpenSquirrel/docs/reference/#opensquirrel.circuit_matrix_calculator.get_circuit_matrix","title":"<code>get_circuit_matrix(squirrel_ir)</code>","text":"<p>Compute the Numpy unitary matrix corresponding to the circuit. The size of this matrix grows exponentially with the number of qubits.</p> Source code in <code>opensquirrel\\circuit_matrix_calculator.py</code> <pre><code>def get_circuit_matrix(squirrel_ir: SquirrelIR):\n    \"\"\"\n    Compute the Numpy unitary matrix corresponding to the circuit.\n    The size of this matrix grows exponentially with the number of qubits.\n    \"\"\"\n\n    impl = _CircuitMatrixCalculator(squirrel_ir.number_of_qubits)\n\n    squirrel_ir.accept(impl)\n\n    return impl.matrix\n</code></pre>"},{"location":"C%3A/Users/elenbaascpc/projects/qi2/OpenSquirrel/OpenSquirrel/docs/reference/#opensquirrel.cnot_decomposer.CNOTDecomposer","title":"<code>CNOTDecomposer</code>","text":"<p>             Bases: <code>Decomposer</code></p> <p>Decomposes 2-qubit controlled unitary gates to CNOT + rz/ry. Applying single-qubit gate fusion after this pass might be beneficial.</p> <p>Source of the math: https://threeplusone.com/pubs/on_gates.pdf, chapter 7.5 \"ABC decomposition\"</p> Source code in <code>opensquirrel\\cnot_decomposer.py</code> <pre><code>class CNOTDecomposer(Decomposer):\n    \"\"\"\n    Decomposes 2-qubit controlled unitary gates to CNOT + rz/ry.\n    Applying single-qubit gate fusion after this pass might be beneficial.\n\n    Source of the math: https://threeplusone.com/pubs/on_gates.pdf, chapter 7.5 \"ABC decomposition\"\n    \"\"\"\n\n    @staticmethod\n    def decompose(g: Gate) -&gt; [Gate]:\n        if not isinstance(g, ControlledGate):\n            # Do nothing:\n            # - BlochSphereRotation's are only single-qubit,\n            # - decomposing MatrixGate is currently not supported.\n            return [g]\n\n        if not isinstance(g.target_gate, BlochSphereRotation):\n            # Do nothing.\n            # ControlledGate's with 2+ control qubits are ignored.\n            return [g]\n\n        target_qubit = g.target_gate.qubit\n\n        # Perform ZYZ decomposition on the target gate.\n        # This gives us an ABC decomposition (U = AXBXC, ABC = I) of the target gate.\n        # See https://threeplusone.com/pubs/on_gates.pdf\n\n        # Try special case first, see https://arxiv.org/pdf/quant-ph/9503016.pdf lemma 5.5\n        controlled_rotation_times_x = merger.compose_bloch_sphere_rotations(x(target_qubit), g.target_gate)\n        theta0_with_x, theta1_with_x, theta2_with_x = get_zyz_decomposition_angles(\n            controlled_rotation_times_x.angle, controlled_rotation_times_x.axis\n        )\n        if abs((theta0_with_x - theta2_with_x) % (2 * math.pi)) &lt; ATOL:\n            # The decomposition can use a single CNOT according to the lemma.\n\n            A = [ry(q=target_qubit, theta=Float(-theta1_with_x / 2)), rz(q=target_qubit, theta=Float(-theta2_with_x))]\n\n            B = [\n                rz(q=target_qubit, theta=Float(theta2_with_x)),\n                ry(q=target_qubit, theta=Float(theta1_with_x / 2)),\n            ]\n\n            return filter_out_identities(\n                B\n                + [cnot(control=g.control_qubit, target=target_qubit)]\n                + A\n                + [rz(q=g.control_qubit, theta=Float(g.target_gate.phase - math.pi / 2))]\n            )\n\n        theta0, theta1, theta2 = get_zyz_decomposition_angles(g.target_gate.angle, g.target_gate.axis)\n\n        A = [ry(q=target_qubit, theta=Float(theta1 / 2)), rz(q=target_qubit, theta=Float(theta2))]\n\n        B = [\n            rz(q=target_qubit, theta=Float(-(theta0 + theta2) / 2)),\n            ry(q=target_qubit, theta=Float(-theta1 / 2)),\n        ]\n\n        C = [\n            rz(q=target_qubit, theta=Float((theta0 - theta2) / 2)),\n        ]\n\n        return filter_out_identities(\n            C\n            + [cnot(control=g.control_qubit, target=target_qubit)]\n            + B\n            + [cnot(control=g.control_qubit, target=target_qubit)]\n            + A\n            + [rz(q=g.control_qubit, theta=Float(g.target_gate.phase))]\n        )\n</code></pre>"},{"location":"C%3A/Users/elenbaascpc/projects/qi2/OpenSquirrel/OpenSquirrel/docs/reference/#opensquirrel.mckay_decomposer.McKayDecomposer","title":"<code>McKayDecomposer</code>","text":"<p>             Bases: <code>Decomposer</code></p> Source code in <code>opensquirrel\\mckay_decomposer.py</code> <pre><code>class McKayDecomposer(Decomposer):\n    @staticmethod\n    def decompose(g: Gate) -&gt; [Gate]:\n        \"\"\"Return the McKay decomposition of a 1-qubit gate as a list of gates.\n                gate   ----&gt;    Rz.Rx(pi/2).Rz.Rx(pi/2).Rz\n\n        The global phase is deemed _irrelevant_, therefore a simulator backend might produce different output\n            for the input and output - the results should be equivalent modulo global phase.\n\n        Relevant literature: https://arxiv.org/abs/1612.00858\n        \"\"\"\n        if not isinstance(g, BlochSphereRotation):\n            return [g]\n\n        if abs(g.angle) &lt; ATOL:\n            return []\n\n        # McKay decomposition\n\n        za_mod = sqrt(cos(g.angle / 2) ** 2 + (g.axis[2] * sin(g.angle / 2)) ** 2)\n        zb_mod = abs(sin(g.angle / 2)) * sqrt(g.axis[0] ** 2 + g.axis[1] ** 2)\n\n        theta = pi - 2 * atan2(zb_mod, za_mod)\n\n        alpha = atan2(-sin(g.angle / 2) * g.axis[2], cos(g.angle / 2))\n        beta = atan2(-sin(g.angle / 2) * g.axis[0], -sin(g.angle / 2) * g.axis[1])\n\n        lam = beta - alpha\n        phi = -beta - alpha - pi\n\n        lam = normalize_angle(lam)\n        phi = normalize_angle(phi)\n        theta = normalize_angle(theta)\n\n        decomposed_g = []\n\n        if abs(lam) &gt; ATOL:\n            decomposed_g.append(rz(g.qubit, Float(lam)))\n\n        decomposed_g.append(x90(g.qubit))\n\n        if abs(theta) &gt; ATOL:\n            decomposed_g.append(rz(g.qubit, Float(theta)))\n\n        decomposed_g.append(x90(g.qubit))\n\n        if abs(phi) &gt; ATOL:\n            decomposed_g.append(rz(g.qubit, Float(phi)))\n\n        return decomposed_g\n</code></pre>"},{"location":"C%3A/Users/elenbaascpc/projects/qi2/OpenSquirrel/OpenSquirrel/docs/reference/#opensquirrel.mckay_decomposer.McKayDecomposer.decompose","title":"<code>decompose(g)</code>  <code>staticmethod</code>","text":"<p>Return the McKay decomposition of a 1-qubit gate as a list of gates.         gate   ----&gt;    Rz.Rx(pi/2).Rz.Rx(pi/2).Rz</p> <p>The global phase is deemed irrelevant, therefore a simulator backend might produce different output     for the input and output - the results should be equivalent modulo global phase.</p> <p>Relevant literature: https://arxiv.org/abs/1612.00858</p> Source code in <code>opensquirrel\\mckay_decomposer.py</code> <pre><code>@staticmethod\ndef decompose(g: Gate) -&gt; [Gate]:\n    \"\"\"Return the McKay decomposition of a 1-qubit gate as a list of gates.\n            gate   ----&gt;    Rz.Rx(pi/2).Rz.Rx(pi/2).Rz\n\n    The global phase is deemed _irrelevant_, therefore a simulator backend might produce different output\n        for the input and output - the results should be equivalent modulo global phase.\n\n    Relevant literature: https://arxiv.org/abs/1612.00858\n    \"\"\"\n    if not isinstance(g, BlochSphereRotation):\n        return [g]\n\n    if abs(g.angle) &lt; ATOL:\n        return []\n\n    # McKay decomposition\n\n    za_mod = sqrt(cos(g.angle / 2) ** 2 + (g.axis[2] * sin(g.angle / 2)) ** 2)\n    zb_mod = abs(sin(g.angle / 2)) * sqrt(g.axis[0] ** 2 + g.axis[1] ** 2)\n\n    theta = pi - 2 * atan2(zb_mod, za_mod)\n\n    alpha = atan2(-sin(g.angle / 2) * g.axis[2], cos(g.angle / 2))\n    beta = atan2(-sin(g.angle / 2) * g.axis[0], -sin(g.angle / 2) * g.axis[1])\n\n    lam = beta - alpha\n    phi = -beta - alpha - pi\n\n    lam = normalize_angle(lam)\n    phi = normalize_angle(phi)\n    theta = normalize_angle(theta)\n\n    decomposed_g = []\n\n    if abs(lam) &gt; ATOL:\n        decomposed_g.append(rz(g.qubit, Float(lam)))\n\n    decomposed_g.append(x90(g.qubit))\n\n    if abs(theta) &gt; ATOL:\n        decomposed_g.append(rz(g.qubit, Float(theta)))\n\n    decomposed_g.append(x90(g.qubit))\n\n    if abs(phi) &gt; ATOL:\n        decomposed_g.append(rz(g.qubit, Float(phi)))\n\n    return decomposed_g\n</code></pre>"},{"location":"C%3A/Users/elenbaascpc/projects/qi2/OpenSquirrel/OpenSquirrel/docs/reference/#opensquirrel.merger.compose_bloch_sphere_rotations","title":"<code>compose_bloch_sphere_rotations(a, b)</code>","text":"<p>Computes the Bloch sphere rotation resulting from the composition of two Bloch sphere rotations. The first rotation is applied and then the second. The resulting gate is anonymous except if <code>a</code> is the identity and <code>b</code> is not anonymous, or vice versa.</p> <p>Uses Rodrigues' rotation formula, see for instance https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula.</p> Source code in <code>opensquirrel\\merger.py</code> <pre><code>def compose_bloch_sphere_rotations(a: BlochSphereRotation, b: BlochSphereRotation) -&gt; BlochSphereRotation:\n    \"\"\"Computes the Bloch sphere rotation resulting from the composition of two Bloch sphere rotations.\n    The first rotation is applied and then the second.\n    The resulting gate is anonymous except if `a` is the identity and `b` is not anonymous, or vice versa.\n\n    Uses Rodrigues' rotation formula, see for instance https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula.\n    \"\"\"\n    assert a.qubit == b.qubit, \"Cannot merge two BlochSphereRotation's on different qubits\"\n\n    acos_argument = cos(a.angle / 2) * cos(b.angle / 2) - sin(a.angle / 2) * sin(b.angle / 2) * np.dot(a.axis, b.axis)\n    # This fixes float approximations like 1.0000000000002 which acos doesn't like.\n    acos_argument = max(min(acos_argument, 1.0), -1.0)\n\n    combined_angle = 2 * acos(acos_argument)\n\n    if abs(sin(combined_angle / 2)) &lt; ATOL:\n        return BlochSphereRotation.identity(a.qubit)\n\n    combined_axis = (\n        1\n        / sin(combined_angle / 2)\n        * (\n            sin(a.angle / 2) * cos(b.angle / 2) * a.axis\n            + cos(a.angle / 2) * sin(b.angle / 2) * b.axis\n            + sin(a.angle / 2) * sin(b.angle / 2) * np.cross(a.axis, b.axis)\n        )\n    )\n\n    combined_phase = a.phase + b.phase\n\n    generator = b.generator if a.is_identity() else a.generator if b.is_identity() else None\n    arguments = b.arguments if a.is_identity() else a.arguments if b.is_identity() else None\n\n    return BlochSphereRotation(\n        qubit=a.qubit,\n        axis=combined_axis,\n        angle=combined_angle,\n        phase=combined_phase,\n        generator=generator,\n        arguments=arguments,\n    )\n</code></pre>"},{"location":"C%3A/Users/elenbaascpc/projects/qi2/OpenSquirrel/OpenSquirrel/docs/reference/#opensquirrel.parsing.antlr.qubit_range_checker.QubitRangeChecker","title":"<code>QubitRangeChecker</code>","text":"<p>             Bases: <code>CQasm3Visitor</code></p> <p>This class checks that all qubit indices make sense in an ANTLR parse tree. It is an instance of the ANTLR abstract syntax tree visitor class. Therefore, method names are fixed and based on rule names in the Grammar .g4 file.</p> Source code in <code>opensquirrel\\parsing\\antlr\\qubit_range_checker.py</code> <pre><code>class QubitRangeChecker(CQasm3Visitor.CQasm3Visitor):\n    \"\"\"\n    This class checks that all qubit indices make sense in an ANTLR parse tree.\n    It is an instance of the ANTLR abstract syntax tree visitor class.\n    Therefore, method names are fixed and based on rule names in the Grammar .g4 file.\n    \"\"\"\n\n    def __init__(self):\n        self.number_of_qubits = 0\n\n    def visitProg(self, ctx):\n        self.visit(ctx.qubitRegisterDeclaration())\n        for gate_application in ctx.gateApplication():\n            self.visit(gate_application)\n\n    def visitQubitRegisterDeclaration(self, ctx):\n        self.number_of_qubits = int(str(ctx.INT()))\n\n    def visitGateApplication(self, ctx):\n        visited_args = (self.visit(arg) for arg in ctx.expr())\n        qubit_argument_sizes = [qubit_range_size for qubit_range_size in visited_args if qubit_range_size is not None]\n\n        if len(qubit_argument_sizes) &gt; 0 and not all(s == qubit_argument_sizes[0] for s in qubit_argument_sizes):\n            raise Exception(\"Invalid gate call with qubit arguments of different sizes\")\n\n    def visitQubit(self, ctx):\n        qubit_index = int(str(ctx.INT()))\n        if qubit_index &gt;= self.number_of_qubits:\n            raise Exception(f\"Qubit index {qubit_index} out of range\")\n\n        return 1\n\n    def visitQubits(self, ctx):\n        qubit_indices = list(map(int, map(str, ctx.INT())))\n        for qubit_index in qubit_indices:\n            if qubit_index &gt;= self.number_of_qubits:\n                raise Exception(f\"Qubit index {qubit_index} out of range\")\n\n        return len(qubit_indices)\n\n    def visitQubitRange(self, ctx):\n        first_qubit_index = int(str(ctx.INT(0)))\n        last_qubit_index = int(str(ctx.INT(1)))\n\n        if first_qubit_index &gt; last_qubit_index:\n            raise Exception(f\"Qubit index range {first_qubit_index}:{last_qubit_index} malformed\")\n\n        if max(first_qubit_index, last_qubit_index) &gt;= self.number_of_qubits:\n            raise Exception(f\"Qubit index range {first_qubit_index}:{last_qubit_index} out of range\")\n\n        return last_qubit_index - first_qubit_index + 1\n\n    def visitIntLiteral(self, ctx):\n        return None\n\n    def visitNegatedIntLiteral(self, ctx):\n        return None\n\n    def visitFloatLiteral(self, ctx):\n        return None\n\n    def visitNegatedFloatLiteral(self, ctx):\n        return None\n</code></pre>"},{"location":"C%3A/Users/elenbaascpc/projects/qi2/OpenSquirrel/OpenSquirrel/docs/reference/#opensquirrel.parsing.antlr.squirrel_ir_creator.SquirrelIRCreator","title":"<code>SquirrelIRCreator</code>","text":"<p>             Bases: <code>GateLibrary</code>, <code>CQasm3Visitor</code></p> <p>This class creates a SquirrelIR object from an ANTLR parse tree. It is an instance of the ANTLR abstract syntax tree visitor class. Therefore, method names are fixed and based on rule names in the Grammar .g4 file.</p> Source code in <code>opensquirrel\\parsing\\antlr\\squirrel_ir_creator.py</code> <pre><code>class SquirrelIRCreator(GateLibrary, CQasm3Visitor.CQasm3Visitor):\n    \"\"\"\n    This class creates a SquirrelIR object from an ANTLR parse tree.\n    It is an instance of the ANTLR abstract syntax tree visitor class.\n    Therefore, method names are fixed and based on rule names in the Grammar .g4 file.\n    \"\"\"\n\n    def __init__(self, gate_set=default_gate_set, gate_aliases=default_gate_aliases):\n        GateLibrary.__init__(self, gate_set, gate_aliases)\n        self.squirrel_ir = None\n\n    def visitProg(self, ctx):\n        number_of_qubits, qubit_register_name = self.visit(ctx.qubitRegisterDeclaration())\n\n        self.squirrel_ir = SquirrelIR(number_of_qubits=number_of_qubits, qubit_register_name=qubit_register_name)\n\n        for gate_application in ctx.gateApplication():\n            self.visit(gate_application)\n\n        return self.squirrel_ir\n\n    def visitGateApplication(self, ctx):\n        gate_name = str(ctx.ID())\n\n        generator_f = GateLibrary.get_gate_f(self, gate_name)\n        parameters = inspect.signature(generator_f).parameters\n\n        number_of_operands = next(\n            len(self.visit(ctx.expr(i))) for i, par in enumerate(parameters.values()) if par.annotation == Qubit\n        )\n\n        # The below is for handling e.g. `cr q[1:3], q[5:7], 1.23`\n        expanded_args = [\n            self.visit(ctx.expr(i)) if par.annotation == Qubit else [self.visit(ctx.expr(i))] * number_of_operands\n            for i, par in enumerate(parameters.values())\n        ]\n\n        for individual_args in zip(*expanded_args):\n            self.squirrel_ir.add_gate(generator_f(*individual_args))\n\n    def visitQubitRegisterDeclaration(self, ctx):\n        return int(str(ctx.INT())), str(ctx.ID())\n\n    def visitQubit(self, ctx):\n        return [Qubit(int(str(ctx.INT())))]\n\n    def visitQubits(self, ctx):\n        return list(map(Qubit, map(int, map(str, ctx.INT()))))\n\n    def visitQubitRange(self, ctx):\n        first_qubit_index = int(str(ctx.INT(0)))\n        last_qubit_index = int(str(ctx.INT(1)))\n        return list(map(Qubit, range(first_qubit_index, last_qubit_index + 1)))\n\n    def visitFloatLiteral(self, ctx):\n        return Float(float(str(ctx.FLOAT())))\n\n    def visitNegatedFloatLiteral(self, ctx):\n        return Float(-float(str(ctx.FLOAT())))\n\n    def visitIntLiteral(self, ctx):\n        return Int(int(str(ctx.INT())))\n\n    def visitNegatedIntLiteral(self, ctx):\n        return Int(-int(str(ctx.INT())))\n</code></pre>"},{"location":"C%3A/Users/elenbaascpc/projects/qi2/OpenSquirrel/OpenSquirrel/docs/reference/#opensquirrel.parsing.antlr.squirrel_ir_from_string.squirrel_ir_from_string","title":"<code>squirrel_ir_from_string(s, gate_set, gate_aliases)</code>","text":"<p>ANTLR parsing entrypoint. Performs type checking based on provided gate semantics and check that the qubit indices are valid. Creates the IR where each gate node is mapped to its semantic function and arguments.</p> <p>Parameters:</p> Name Type Description Default <code>gate_set</code> <code>list</code> <p>The set of supported gate semantics.</p> required <code>gate_aliases</code> <code>dict</code> <p>Dictionary mapping extra gate names to their semantic.</p> required <p>Returns:</p> Type Description <code>SquirrelIR</code> <p>A corresponding SquirrelIR object. Throws in case of parsing error.</p> Source code in <code>opensquirrel\\parsing\\antlr\\squirrel_ir_from_string.py</code> <pre><code>def squirrel_ir_from_string(s: str, gate_set: list, gate_aliases: dict) -&gt; SquirrelIR:\n    \"\"\"\n    ANTLR parsing entrypoint.\n    Performs type checking based on provided gate semantics and check that the qubit indices are valid.\n    Creates the IR where each gate node is mapped to its semantic function and arguments.\n\n    Args:\n        gate_set: The set of supported gate semantics.\n        gate_aliases: Dictionary mapping extra gate names to their semantic.\n\n    Returns:\n        A corresponding SquirrelIR object. Throws in case of parsing error.\n    \"\"\"\n    tree = antlr_tree_from_string(s)\n\n    type_check_antlr_tree(tree, gate_set=gate_set, gate_aliases=gate_aliases)\n\n    check_qubit_ranges_of_antlr_tree(tree)\n\n    squirrel_ir_creator = SquirrelIRCreator(gate_set=gate_set, gate_aliases=gate_aliases)\n\n    return squirrel_ir_creator.visit(tree)\n</code></pre>"},{"location":"C%3A/Users/elenbaascpc/projects/qi2/OpenSquirrel/OpenSquirrel/docs/reference/#opensquirrel.parsing.antlr.type_checker.TypeChecker","title":"<code>TypeChecker</code>","text":"<p>             Bases: <code>GateLibrary</code>, <code>CQasm3Visitor</code></p> <p>This class checks that all gate parameter types make sense in an ANTLR parse tree. It is an instance of the ANTLR abstract syntax tree visitor class. Therefore, method names are fixed and based on rule names in the Grammar .g4 file.</p> Source code in <code>opensquirrel\\parsing\\antlr\\type_checker.py</code> <pre><code>class TypeChecker(GateLibrary, CQasm3Visitor.CQasm3Visitor):\n    \"\"\"\n    This class checks that all gate parameter types make sense in an ANTLR parse tree.\n    It is an instance of the ANTLR abstract syntax tree visitor class.\n    Therefore, method names are fixed and based on rule names in the Grammar .g4 file.\n    \"\"\"\n\n    def __init__(self, gate_set=default_gate_set, gate_aliases=default_gate_aliases):\n        GateLibrary.__init__(self, gate_set, gate_aliases)\n        self.qubit_register_name = None\n\n    def visitProg(self, ctx):\n        self.visit(ctx.qubitRegisterDeclaration())\n        for gate_application in ctx.gateApplication():\n            self.visit(gate_application)\n\n    def visitQubitRegisterDeclaration(self, ctx):\n        self.qubit_register_name = str(ctx.ID())\n\n    def visitGateApplication(self, ctx):\n        # Check that the types of the operands match the gate generator function.\n        gate_name = str(ctx.ID())\n        generator_f = GateLibrary.get_gate_f(self, gate_name)\n\n        parameters = inspect.signature(generator_f).parameters\n\n        if len(ctx.expr()) &gt; len(parameters):\n            raise Exception(f\"Gate `{gate_name}` takes {len(parameters)} arguments, but {len(ctx.expr())} were given!\")\n\n        for i, param in enumerate(parameters.values()):\n            actual_type = self.visit(ctx.expr(i))\n            expected_type = param.annotation\n            if actual_type != expected_type:\n                raise Exception(\n                    f\"Argument #{i} passed to gate `{gate_name}` is of type\"\n                    f\" {actual_type} but should be {expected_type}\"\n                )\n\n    def visitQubit(self, ctx):\n        if str(ctx.ID()) != self.qubit_register_name:\n            raise Exception(f\"Qubit register {str(ctx.ID())} not declared\")\n\n        return Qubit\n\n    def visitQubits(self, ctx):\n        if str(ctx.ID()) != self.qubit_register_name:\n            raise Exception(f\"Qubit register {str(ctx.ID())} not declared\")\n\n        return Qubit\n\n    def visitQubitRange(self, ctx):\n        if str(ctx.ID()) != self.qubit_register_name:\n            raise Exception(f\"Qubit register {str(ctx.ID())} not declared\")\n\n        return Qubit\n\n    def visitIntLiteral(self, ctx):\n        return Int\n\n    def visitNegatedIntLiteral(self, ctx):\n        return Int\n\n    def visitFloatLiteral(self, ctx):\n        return Float\n\n    def visitNegatedFloatLiteral(self, ctx):\n        return Float\n</code></pre>"},{"location":"C%3A/Users/elenbaascpc/projects/qi2/OpenSquirrel/OpenSquirrel/docs/reference/#opensquirrel.replacer.decompose","title":"<code>decompose(squirrel_ir, decomposer)</code>","text":"<p>Applies <code>decomposer</code> to every gate in the circuit, replacing each gate by the output of <code>decomposer</code>. When <code>decomposer</code> decides to not decompose a gate, it needs to return a list with the intact gate as single element.</p> Source code in <code>opensquirrel\\replacer.py</code> <pre><code>def decompose(squirrel_ir: SquirrelIR, decomposer: Decomposer):\n    \"\"\"Applies `decomposer` to every gate in the circuit, replacing each gate by the output of `decomposer`.\n    When `decomposer` decides to not decompose a gate, it needs to return a list with the intact gate as single element.\n    \"\"\"\n    statement_index = 0\n    while statement_index &lt; len(squirrel_ir.statements):\n        statement = squirrel_ir.statements[statement_index]\n\n        if not isinstance(statement, Gate):\n            statement_index += 1\n            continue\n\n        replacement: List[Gate] = decomposer.decompose(statement)\n\n        check_valid_replacement(statement, replacement)\n\n        squirrel_ir.statements[statement_index : statement_index + 1] = replacement\n        statement_index += len(replacement)\n</code></pre>"},{"location":"C%3A/Users/elenbaascpc/projects/qi2/OpenSquirrel/OpenSquirrel/docs/reference/#opensquirrel.replacer.replace","title":"<code>replace(squirrel_ir, gate_generator, f)</code>","text":"<p>Does the same as decomposer, but only applies to a given gate.</p> Source code in <code>opensquirrel\\replacer.py</code> <pre><code>def replace(squirrel_ir: SquirrelIR, gate_generator: Callable[..., Gate], f):\n    \"\"\"Does the same as decomposer, but only applies to a given gate.\"\"\"\n\n    def generic_replacer(g: Gate) -&gt; [Gate]:\n        if g.is_anonymous or g.generator != gate_generator:\n            return [g]\n        return f(*g.arguments)\n\n    generic_replacer = _GenericReplacer(gate_generator, f)\n\n    decompose(squirrel_ir, generic_replacer)\n</code></pre>"},{"location":"C%3A/Users/elenbaascpc/projects/qi2/OpenSquirrel/OpenSquirrel/docs/reference/#opensquirrel.utils.matrix_expander.expand_ket","title":"<code>expand_ket(base_ket, reduced_ket, qubits)</code>","text":"<p>Given a base quantum ket on n qubits and a reduced ket on a subset of those qubits, this computes the expanded ket where the reduction qubits and the other qubits are set based on the reduced ket and the base ket, respectively. Roughly equivalent to the <code>pdep</code> assembly instruction (bits deposit).</p> <p>Parameters:</p> Name Type Description Default <code>base_ket</code> <code>int</code> <p>A quantum ket, represented by its corresponding non-negative integer.       By convention, qubit #0 corresponds to the least significant bit.</p> required <code>reduced_ket</code> <code>int</code> <p>A quantum ket, represented by its corresponding non-negative integer.          By convention, qubit #0 corresponds to the least significant bit.</p> required <code>qubits</code> <code>List[Qubit]</code> <p>The indices of the qubits to expand from the reduced ket. Order matters.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The non-negative integer corresponding to the expanded ket.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; expand_ket(0b00000, 0b0, [Qubit(5)])   # 0b000000\n0\n&gt;&gt;&gt; expand_ket(0b00000, 0b1, [Qubit(5)])   # 0b100000\n32\n&gt;&gt;&gt; expand_ket(0b00111, 0b0, [Qubit(5)])   # 0b000111\n7\n&gt;&gt;&gt; expand_ket(0b00111, 0b1, [Qubit(5)])   # 0b100111\n39\n&gt;&gt;&gt; expand_ket(0b0000, 0b000, [Qubit(1), Qubit(2), Qubit(3)])    # 0b0000\n0\n&gt;&gt;&gt; expand_ket(0b0000, 0b001, [Qubit(1), Qubit(2), Qubit(3)])    # 0b0010\n2\n&gt;&gt;&gt; expand_ket(0b0000, 0b011, [Qubit(1), Qubit(2), Qubit(3)])    # 0b0110\n6\n&gt;&gt;&gt; expand_ket(0b0000, 0b101, [Qubit(1), Qubit(2), Qubit(3)])   # 0b1010\n10\n&gt;&gt;&gt; expand_ket(0b0001, 0b101, [Qubit(1), Qubit(2), Qubit(3)])   # 0b1011\n11\n</code></pre> Source code in <code>opensquirrel\\utils\\matrix_expander.py</code> <pre><code>def expand_ket(base_ket: int, reduced_ket: int, qubits: List[Qubit]) -&gt; int:\n    \"\"\"\n    Given a base quantum ket on n qubits and a reduced ket on a subset of those qubits, this computes the expanded ket\n    where the reduction qubits and the other qubits are set based on the reduced ket and the base ket, respectively.\n    Roughly equivalent to the `pdep` assembly instruction (bits deposit).\n\n    Args:\n        base_ket: A quantum ket, represented by its corresponding non-negative integer.\n                  By convention, qubit #0 corresponds to the least significant bit.\n        reduced_ket: A quantum ket, represented by its corresponding non-negative integer.\n                     By convention, qubit #0 corresponds to the least significant bit.\n        qubits: The indices of the qubits to expand from the reduced ket. Order matters.\n\n    Returns:\n        The non-negative integer corresponding to the expanded ket.\n\n    Examples:\n        &gt;&gt;&gt; expand_ket(0b00000, 0b0, [Qubit(5)])   # 0b000000\n        0\n        &gt;&gt;&gt; expand_ket(0b00000, 0b1, [Qubit(5)])   # 0b100000\n        32\n        &gt;&gt;&gt; expand_ket(0b00111, 0b0, [Qubit(5)])   # 0b000111\n        7\n        &gt;&gt;&gt; expand_ket(0b00111, 0b1, [Qubit(5)])   # 0b100111\n        39\n        &gt;&gt;&gt; expand_ket(0b0000, 0b000, [Qubit(1), Qubit(2), Qubit(3)])    # 0b0000\n        0\n        &gt;&gt;&gt; expand_ket(0b0000, 0b001, [Qubit(1), Qubit(2), Qubit(3)])    # 0b0010\n        2\n        &gt;&gt;&gt; expand_ket(0b0000, 0b011, [Qubit(1), Qubit(2), Qubit(3)])    # 0b0110\n        6\n        &gt;&gt;&gt; expand_ket(0b0000, 0b101, [Qubit(1), Qubit(2), Qubit(3)])   # 0b1010\n        10\n        &gt;&gt;&gt; expand_ket(0b0001, 0b101, [Qubit(1), Qubit(2), Qubit(3)])   # 0b1011\n        11\n    \"\"\"\n    expanded_ket = base_ket\n    for i, qubit in enumerate(qubits):\n        expanded_ket &amp;= ~(1 &lt;&lt; qubit.index)  # Erase bit.\n        expanded_ket |= ((reduced_ket &amp; (1 &lt;&lt; i)) &gt;&gt; i) &lt;&lt; qubit.index  # Set bit to value from reduced_ket.\n\n    return expanded_ket\n</code></pre>"},{"location":"C%3A/Users/elenbaascpc/projects/qi2/OpenSquirrel/OpenSquirrel/docs/reference/#opensquirrel.utils.matrix_expander.get_matrix","title":"<code>get_matrix(gate, number_of_qubits)</code>","text":"<p>Compute the unitary matrix corresponding to the gate applied to those qubit operands, taken among any number of qubits. This can be used for, e.g., - testing, - permuting the operands of multi-qubit gates, - simulating a circuit (simulation in this way is inefficient for large numbers of qubits).</p> <p>Parameters:</p> Name Type Description Default <code>gate</code> <code>Gate</code> <p>The gate, including the qubits on which it is operated on.</p> required <code>number_of_qubits</code> <code>int</code> <p>The total number of qubits.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; X = lambda q: BlochSphereRotation(qubit=q, axis=(1, 0, 0), angle=math.pi, phase=math.pi / 2)\n&gt;&gt;&gt; get_matrix(X(Qubit(1)), 2).astype(int)           # X q[1]\narray([[0, 0, 1, 0],\n       [0, 0, 0, 1],\n       [1, 0, 0, 0],\n       [0, 1, 0, 0]])\n</code></pre> <pre><code>&gt;&gt;&gt; CNOT02 = ControlledGate(Qubit(0), X(Qubit(2)))\n&gt;&gt;&gt; get_matrix(CNOT02, 3).astype(int)     # CNOT q[0], q[2]\narray([[1, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 1, 0, 0],\n       [0, 0, 1, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 1],\n       [0, 0, 0, 0, 1, 0, 0, 0],\n       [0, 1, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 1, 0],\n       [0, 0, 0, 1, 0, 0, 0, 0]])\n&gt;&gt;&gt; get_matrix(ControlledGate(Qubit(1), X(Qubit(2))), 3).astype(int)     # CNOT q[1], q[2]\narray([[1, 0, 0, 0, 0, 0, 0, 0],\n       [0, 1, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 1, 0],\n       [0, 0, 0, 0, 0, 0, 0, 1],\n       [0, 0, 0, 0, 1, 0, 0, 0],\n       [0, 0, 0, 0, 0, 1, 0, 0],\n       [0, 0, 1, 0, 0, 0, 0, 0],\n       [0, 0, 0, 1, 0, 0, 0, 0]])\n</code></pre> Source code in <code>opensquirrel\\utils\\matrix_expander.py</code> <pre><code>def get_matrix(gate: Gate, number_of_qubits: int) -&gt; np.ndarray:\n    \"\"\"\n    Compute the unitary matrix corresponding to the gate applied to those qubit operands, taken among any number of qubits.\n    This can be used for, e.g.,\n    - testing,\n    - permuting the operands of multi-qubit gates,\n    - simulating a circuit (simulation in this way is inefficient for large numbers of qubits).\n\n    Args:\n        gate: The gate, including the qubits on which it is operated on.\n        number_of_qubits: The total number of qubits.\n\n    Examples:\n        &gt;&gt;&gt; X = lambda q: BlochSphereRotation(qubit=q, axis=(1, 0, 0), angle=math.pi, phase=math.pi / 2)\n        &gt;&gt;&gt; get_matrix(X(Qubit(1)), 2).astype(int)           # X q[1]\n        array([[0, 0, 1, 0],\n               [0, 0, 0, 1],\n               [1, 0, 0, 0],\n               [0, 1, 0, 0]])\n\n        &gt;&gt;&gt; CNOT02 = ControlledGate(Qubit(0), X(Qubit(2)))\n        &gt;&gt;&gt; get_matrix(CNOT02, 3).astype(int)     # CNOT q[0], q[2]\n        array([[1, 0, 0, 0, 0, 0, 0, 0],\n               [0, 0, 0, 0, 0, 1, 0, 0],\n               [0, 0, 1, 0, 0, 0, 0, 0],\n               [0, 0, 0, 0, 0, 0, 0, 1],\n               [0, 0, 0, 0, 1, 0, 0, 0],\n               [0, 1, 0, 0, 0, 0, 0, 0],\n               [0, 0, 0, 0, 0, 0, 1, 0],\n               [0, 0, 0, 1, 0, 0, 0, 0]])\n        &gt;&gt;&gt; get_matrix(ControlledGate(Qubit(1), X(Qubit(2))), 3).astype(int)     # CNOT q[1], q[2]\n        array([[1, 0, 0, 0, 0, 0, 0, 0],\n               [0, 1, 0, 0, 0, 0, 0, 0],\n               [0, 0, 0, 0, 0, 0, 1, 0],\n               [0, 0, 0, 0, 0, 0, 0, 1],\n               [0, 0, 0, 0, 1, 0, 0, 0],\n               [0, 0, 0, 0, 0, 1, 0, 0],\n               [0, 0, 1, 0, 0, 0, 0, 0],\n               [0, 0, 0, 1, 0, 0, 0, 0]])\n    \"\"\"\n\n    expander = MatrixExpander(number_of_qubits)\n    return gate.accept(expander)\n</code></pre>"},{"location":"C%3A/Users/elenbaascpc/projects/qi2/OpenSquirrel/OpenSquirrel/docs/reference/#opensquirrel.utils.matrix_expander.get_reduced_ket","title":"<code>get_reduced_ket(ket, qubits)</code>","text":"<p>Given a quantum ket represented by its corresponding base-10 integer, this computes the reduced ket where only the given qubits appear, in order. Roughly equivalent to the <code>pext</code> assembly instruction (bits extraction).</p> <p>Parameters:</p> Name Type Description Default <code>ket</code> <code>int</code> <p>A quantum ket, represented by its corresponding non-negative integer.  By convention, qubit #0 corresponds to the least significant bit.</p> required <code>qubits</code> <code>List[Qubit]</code> <p>The indices of the qubits to extract. Order matters.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The non-negative integer corresponding to the reduced ket.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; get_reduced_ket(1, [Qubit(0)])         # 0b01\n1\n&gt;&gt;&gt; get_reduced_ket(1111, [Qubit(2)])      # 0b01\n1\n&gt;&gt;&gt; get_reduced_ket(1111, [Qubit(5)])      # 0b0\n0\n&gt;&gt;&gt; get_reduced_ket(1111, [Qubit(2), Qubit(5)])   # 0b01\n1\n&gt;&gt;&gt; get_reduced_ket(101, [Qubit(1), Qubit(0)])    # 0b10\n2\n&gt;&gt;&gt; get_reduced_ket(101, [Qubit(0), Qubit(1)])    # 0b01\n1\n</code></pre> Source code in <code>opensquirrel\\utils\\matrix_expander.py</code> <pre><code>def get_reduced_ket(ket: int, qubits: List[Qubit]) -&gt; int:\n    \"\"\"\n    Given a quantum ket represented by its corresponding base-10 integer, this computes the reduced ket\n    where only the given qubits appear, in order.\n    Roughly equivalent to the `pext` assembly instruction (bits extraction).\n\n    Args:\n        ket: A quantum ket, represented by its corresponding non-negative integer.\n             By convention, qubit #0 corresponds to the least significant bit.\n        qubits: The indices of the qubits to extract. Order matters.\n\n    Returns:\n        The non-negative integer corresponding to the reduced ket.\n\n    Examples:\n        &gt;&gt;&gt; get_reduced_ket(1, [Qubit(0)])         # 0b01\n        1\n        &gt;&gt;&gt; get_reduced_ket(1111, [Qubit(2)])      # 0b01\n        1\n        &gt;&gt;&gt; get_reduced_ket(1111, [Qubit(5)])      # 0b0\n        0\n        &gt;&gt;&gt; get_reduced_ket(1111, [Qubit(2), Qubit(5)])   # 0b01\n        1\n        &gt;&gt;&gt; get_reduced_ket(101, [Qubit(1), Qubit(0)])    # 0b10\n        2\n        &gt;&gt;&gt; get_reduced_ket(101, [Qubit(0), Qubit(1)])    # 0b01\n        1\n    \"\"\"\n    reduced_ket = 0\n    for i, qubit in enumerate(qubits):\n        reduced_ket |= ((ket &amp; (1 &lt;&lt; qubit.index)) &gt;&gt; qubit.index) &lt;&lt; i\n\n    return reduced_ket\n</code></pre>"},{"location":"C%3A/Users/elenbaascpc/projects/qi2/OpenSquirrel/OpenSquirrel/docs/reference/#opensquirrel.zyz_decomposer.get_zyz_decomposition_angles","title":"<code>get_zyz_decomposition_angles(alpha, axis)</code>","text":"<p>Gives the angles used in the Z-Y-Z decomposition of the Bloch sphere rotation characterized by a rotation around <code>axis</code> of angle <code>alpha</code>.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>float</code> <p>angle of the Bloch sphere rotation</p> required <code>axis</code> <code>Tuple[float, float, float]</code> <p>normalized axis of the Bloch sphere rotation</p> required <p>Returns:</p> Type Description <code>float</code> <p>A triple (theta1, theta2, theta3) corresponding to the decomposition of the</p> <code>float</code> <p>arbitrary Bloch sphere rotation into U = rz(theta3) ry(theta2) rz(theta1)</p> Source code in <code>opensquirrel\\zyz_decomposer.py</code> <pre><code>def get_zyz_decomposition_angles(alpha: float, axis: Tuple[float, float, float]) -&gt; Tuple[float, float, float]:\n    \"\"\"\n    Gives the angles used in the Z-Y-Z decomposition of the Bloch sphere rotation\n    characterized by a rotation around `axis` of angle `alpha`.\n\n    Parameters:\n        alpha: angle of the Bloch sphere rotation\n        axis: _normalized_ axis of the Bloch sphere rotation\n\n    Returns:\n        A triple (theta1, theta2, theta3) corresponding to the decomposition of the\n        arbitrary Bloch sphere rotation into U = rz(theta3) ry(theta2) rz(theta1)\n\n    \"\"\"\n    nx, ny, nz = axis\n\n    assert abs(nx**2 + ny**2 + nz**2 - 1) &lt; ATOL, \"Axis needs to be normalized\"\n\n    assert -math.pi + ATOL &lt; alpha &lt;= math.pi + ATOL, \"Angle needs to be normalized\"\n\n    if abs(alpha - math.pi) &lt; ATOL:\n        # alpha == pi, math.tan(alpha / 2) is not defined.\n\n        if abs(nz) &lt; ATOL:\n            theta2 = math.pi\n            p = 0\n            m = 2 * math.acos(ny)\n\n        else:\n            p = math.pi\n            theta2 = 2 * math.acos(nz)\n\n            if abs(nz - 1) &lt; ATOL or abs(nz + 1) &lt; ATOL:\n                m = p  # This can be anything, but setting m = p means theta3 == 0, which is better for gate count.\n            else:\n                m = 2 * math.acos(ny / math.sqrt(1 - nz**2))\n\n    else:\n        p = 2 * math.atan2(nz * math.sin(alpha / 2), math.cos(alpha / 2))\n\n        acos_argument = math.cos(alpha / 2) * math.sqrt(1 + (nz * math.tan(alpha / 2)) ** 2)\n\n        # This fixes float approximations like 1.0000000000002 which acos doesn't like.\n        acos_argument = max(min(acos_argument, 1.0), -1.0)\n\n        theta2 = 2 * math.acos(acos_argument)\n        theta2 = math.copysign(theta2, alpha)\n\n        if abs(math.sin(theta2 / 2)) &lt; ATOL:\n            m = p  # This can be anything, but setting m = p means theta3 == 0, which is better for gate count.\n        else:\n            acos_argument = ny * math.sin(alpha / 2) / math.sin(theta2 / 2)\n\n            # This fixes float approximations like 1.0000000000002 which acos doesn't like.\n            acos_argument = max(min(acos_argument, 1.0), -1.0)\n\n            m = 2 * math.acos(acos_argument)\n\n    theta1 = (p + m) / 2\n\n    theta3 = p - theta1\n\n    return theta1, theta2, theta3\n</code></pre>"}]}