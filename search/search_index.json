{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":"<p>This site contains the documentation for OpenSquirrel, i.e., a flexible quantum program compiler. OpenSquirrel chooses a modular, over a configurable, approach to prepare and optimize quantum circuits for heterogeneous target architectures.</p> <p>It has a user-friendly interface and is straightforwardly extensible with custom-made readers, compiler passes, and exporters. As a quantum circuit compiler, it is fully aware of the semantics of each gate and arbitrary quantum gates can be constructed manually. It understands the quantum programming language cQASM 3 and will support additional quantum programming languages in the future. It is developed in modern Python and follows best practices.</p> <p>[GitHub repository][PyPI]</p>"},{"location":"index.html#table-of-contents","title":"Table of Contents","text":"<p>The following documentation structure is used: Di\u00e1taxis documentation framework.</p> <ol> <li>Tutorial</li> <li>Reference</li> </ol>"},{"location":"index.html#authors","title":"Authors","text":"<p>Quantum Inspire (support@quantum-inspire.com)</p>"},{"location":"index.html#acknowledgements","title":"Acknowledgements","text":"<p>The Quantum Inspire project (by QuTech: a collaboration of TNO and TU Delft)</p>"},{"location":"tutorial.html","title":"Tutorial","text":""},{"location":"tutorial.html#installation","title":"Installation","text":"<p>OpenSquirrel is available through the Python Package Index (PyPI).</p> <p>Accordingly, installation is as easy as ABC: <pre><code>$ pip install opensquirrel\n</code></pre></p> <p>You can check if the package is installed by importing it: <pre><code>import opensquirrel\n</code></pre></p>"},{"location":"tutorial.html#creating-a-circuit","title":"Creating a circuit","text":"<p>OpenSquirrel's entrypoint is the <code>Circuit</code>, which represents a quantum circuit. You can create a circuit in two different ways:</p> <ol> <li>form a string written in cQASM, or;</li> <li>by using the <code>CircuitBuilder</code> in Python.</li> </ol>"},{"location":"tutorial.html#1-from-a-cqasm-string","title":"1. From a cQASM string","text":"<p><pre><code>from opensquirrel import Circuit\n\nqc = Circuit.from_string(\n    \"\"\"\n    version 3.0\n\n    // Initialise a circuit with two qubits and a bit\n    qubit[2] q\n    bit[2] b\n\n    // Create a Bell pair\n    H q[0]\n    CNOT q[0], q[1]\n\n    // Measure qubits\n    b = measure q\n    \"\"\"\n)\n\nprint(qc)\n</code></pre> Output:</p> <pre><code>version 3.0\n\nqubit[2] q\nbit[2] b\n\nH q[0]\nCNOT q[0], q[1]\nb[0] = measure q[0]\nb[1] = measure q[1]\n</code></pre>"},{"location":"tutorial.html#2-using-the-circuitbuilder","title":"2. Using the <code>CircuitBuilder</code>","text":"<p>For creation of a circuit through Python, the <code>CircuitBuilder</code> can be used accordingly:</p> <p><pre><code>from opensquirrel import CircuitBuilder\nfrom opensquirrel.ir import Qubit, Float\n\nbuilder = CircuitBuilder(qubit_register_size=2)\nbuilder.Ry(Qubit(0), Float(0.23)).CNOT(Qubit(0),Qubit(1))\nqc = builder.to_circuit()\n\nprint(qc)\n</code></pre> Output:</p> <pre><code>version 3.0\n\nqubit[2] q\n\nRy(0.23) q[0]\nCNOT q[0], q[1]\n</code></pre> <p>You can naturally use the functionalities available in Python to create your circuit:</p> <p><pre><code>builder = CircuitBuilder(qubit_register_size=10)\nfor i in range(0, 10, 2):\n    builder.H(Qubit(i))\nqc = builder.to_circuit()\n\nprint(qc)\n</code></pre> Output:</p> <pre><code>version 3.0\n\nqubit[10] q\n\nH q[0]\nH q[2]\nH q[4]\nH q[6]\nH q[8]\n</code></pre> <p>For instance, you can generate a quantum fourier transform (QFT) circuit as follows:</p> <p><pre><code>qubit_register_size = 5\nbuilder = CircuitBuilder(qubit_register_size)\nfor i in range(qubit_register_size):\n      builder.H(Qubit(i))\n      for c in range(i + 1, qubit_register_size):\n            builder.CRk(Qubit(c), Qubit(i), Int(c-i+1))\nqft = builder.to_circuit()\n\nprint(qft)\n</code></pre> Output:</p> <pre><code>version 3.0\n\nqubit[5] q\n\nH q[0]\nCRk(2) q[1], q[0]\nCRk(3) q[2], q[0]\nCRk(4) q[3], q[0]\nCRk(5) q[4], q[0]\nH q[1]\nCRk(2) q[2], q[1]\nCRk(3) q[3], q[1]\nCRk(4) q[4], q[1]\nH q[2]\nCRk(2) q[3], q[2]\nCRk(3) q[4], q[2]\nH q[3]\nCRk(2) q[4], q[3]\nH q[4]\n</code></pre>"},{"location":"tutorial.html#strong-types","title":"Strong types","text":"<p>As you can see, gates require strong types. For instance, you cannot do:</p> <p><pre><code>try:\n    Circuit.from_string(\n        \"\"\"\n        version 3.0\n        qubit[2] q\n\n        CNOT q[0], 3 // The CNOT expects a qubit as second argument.\n        \"\"\"\n    )\nexcept Exception as e:\n    print(e)\n</code></pre> Output:</p> <pre><code>Parsing error: failed to resolve overload for cnot with argument pack (qubit, int)\n</code></pre> <p>The issue is that the CNOT expects a qubit as second input argument where an integer has been provided. The same holds for the <code>CircuitBuilder</code>, i.e., it also throws an error if arguments are passed of an unexpected type:</p> <p><pre><code>try:\n    CircuitBuilder(qubit_register_size=2).CNOT(Qubit(0), 3)\nexcept Exception as e:\n    print(e)\n</code></pre> Output:</p> <pre><code>TypeError: wrong argument type for instruction `CNOT`, got &lt;class 'int'&gt; but expected Qubit\n</code></pre>"},{"location":"tutorial.html#modifying-a-circuit","title":"Modifying a circuit","text":""},{"location":"tutorial.html#merging-single-qubit-gates","title":"Merging single qubit gates","text":"<p>All single-qubit gates appearing in a circuit can be merged by applying <code>merge_single_qubit_gates()</code> to the circuit. Note that multi-qubit gates remain untouched and single-qubit gates are not merged across any multi-qubit gates. The gate that results from the merger of single-qubit gates will, in general, comprise an arbitrary rotation and, therefore, not be a known gate. In OpenSquirrel an unrecognized gate is deemed anonymous. When a circuit contains anonymous gates and is written to a cQASM string, the semantic representation of the anonymous gate is exported.</p> <p>Warning</p> <p>The semantic representation of an anonymous gate is not compliant cQASM, meaning that a cQASM parser, e.g. libQASM, will not recognize it as a valid statement.</p> <p><pre><code>import math\n\nbuilder = CircuitBuilder(1)\nfor _ in range(4):\n    builder.Rx(Qubit(0), Float(math.pi / 4))\nqc = builder.to_circuit()\n\nqc.merge_single_qubit_gates()\n\nprint(qc)\n</code></pre> Output:</p> <pre><code>version 3.0\n\nqubit[1] q\n\nAnonymous gate: BlochSphereRotation(Qubit[0], axis=[1. 0. 0.], angle=3.14159, phase=0.0)\n</code></pre> <p>In the above example, OpenSquirrel has merged all the Rx gates together. Yet, for now, OpenSquirrel does not recognize that this results in a single Rx over the cumulated angle of the individual rotations. Moreover, it does not recognize that the result corresponds to the X gate (up to a global phase difference). At a later stage, we may want OpenSquirrel to recognize the resultant gate in the case it is part of the set of known gates.</p> <p>The gate set is, however, not immutable. In the following section, we demonstrate how new gates can be defined and added to the default gate set.</p>"},{"location":"tutorial.html#defining-your-own-quantum-gates","title":"Defining your own quantum gates","text":"<p>OpenSquirrel accepts any new gate and requires its definition in terms of a semantic. Creating new gates is done using Python functions, decorators, and one of the following gate semantic classes: <code>BlochSphereRotation</code>, <code>ControlledGate</code>, or <code>MatrixGate</code>.</p> <ul> <li>The <code>BlochSphereRotation</code> class is used to define an arbitrary single qubit gate. It accepts a qubit, an axis, an angle, and a phase as arguments. Below is shown how the X-gate is defined in the default gate set of OpenSquirrel:</li> </ul> <pre><code>@named_gate\ndef x(q: Qubit) -&gt; Gate:\n    return BlochSphereRotation(qubit=q, axis=(1, 0, 0), angle=math.pi, phase=math.pi / 2)\n</code></pre> <p>Notice the <code>@named_gate</code> decorator. This tells OpenSquirrel that the function defines a gate and that it should, therefore, have all the nice properties OpenSquirrel expects of it.</p> <ul> <li>The <code>ControlledGate</code> class is used to define a multiple qubit gate that comprises a controlled operation. For instance, the CNOT gate is defined in the default gate set of OpenSquirrel as follows:</li> </ul> <pre><code>@named_gate\ndef cnot(control: Qubit, target: Qubit) -&gt; Gate:\n    return ControlledGate(control, x(target))\n</code></pre> <ul> <li>The <code>MatrixGate</code> class may be used to define a gate in the generic form of a matrix:</li> </ul> <pre><code>@named_gate\ndef swap(q1: Qubit, q2: Qubit) -&gt; Gate:\n    return MatrixGate(\n        np.array(\n            [\n                [1, 0, 0, 0],\n                [0, 0, 1, 0],\n                [0, 1, 0, 0],\n                [0, 0, 0, 1],\n            ]\n        ),\n        [q1, q2],\n    )\n</code></pre> <p>Note</p> <p>User defined gates can only be used in when creating a circuit with the circuit builder. cQASM parsers will not recognize user defined gates, i.e., they cannot be used when creating a circuit through a cQASM string.</p>"},{"location":"tutorial.html#gate-decomposition","title":"Gate decomposition","text":"<p>OpenSquirrel can decompose the gates of a quantum circuit, given a specific decomposition. OpenSquirrel offers several, so-called, decomposers out of the box, but users can also make their own decomposer and apply them to the circuit. Decompositions can be:    1. predefined, or;    2. inferred from the gate semantics.</p>"},{"location":"tutorial.html#1-predefined-decomposition","title":"1. Predefined decomposition","text":"<p>The first kind of decomposition is when you want to replace a particular gate in the circuit, like the CNOT gate, with a fixed list of gates. It is commonly known that CNOT can be decomposed as H-CZ-H. This decomposition is demonstrated below using a Python lambda function, which requires the same parameters as the gate that is decomposed:</p> <p><pre><code>from opensquirrel.default_gates import CNOT, H, CZ\n\nqc = Circuit.from_string(\n    \"\"\"\n    version 3.0\n    qubit[3] q\n\n    X q[0:2]  // Note that this notation is expanded in OpenSquirrel.\n    CNOT q[0], q[1]\n    Ry q[2], 6.78\n    \"\"\"\n)\nqc.replace(\n    CNOT,\n    lambda control, target:\n    [\n        H(target),\n        CZ(control, target),\n        H(target),\n    ]\n)\n\nprint(qc)\n</code></pre> Output:</p> <pre><code>version 3.0\n\nqubit[3] q\n\nX q[0]\nX q[1]\nX q[2]\nH q[1]\nCZ q[0], q[1]\nH q[1]\nRy(6.78) q[2]\n</code></pre> <p>OpenSquirrel will check whether the provided decomposition is correct. For instance, an exception is thrown if we forget the final Hadamard, or H gate, in our custom-made decomposition:</p> <p><pre><code>qc = Circuit.from_string(\n    \"\"\"\n    version 3.0\n    qubit[3] q\n\n    X q[0:2]\n    CNOT q[0], q[1]\n    Ry q[2], 6.78\n    \"\"\"\n)\ntry:\n    qc.replace(\n        CNOT,\n        lambda control, target:\n        [\n            H(target),\n            CZ(control, target),\n        ]\n    )\nexcept Exception as e:\n  print(e)\n</code></pre> Output:</p> <pre><code>replacement for gate CNOT does not preserve the quantum state\n</code></pre>"},{"location":"tutorial.html#2-inferred-decomposition","title":"2. Inferred decomposition","text":"<p>OpenSquirrel has a variety inferred decomposition strategies. More in depth tutorials can be found in the decomposition example Jupyter notebook.</p> <p>One of the most common single qubit decomposition techniques is the Z-Y-Z decomposition. This technique decomposes a quantum gate into an <code>Rz</code>, <code>Ry</code> and <code>Rz</code> gate in that order. The decompositions are found in <code>opensquirrel.decomposer</code>, an example can be seen below where a Hadamard, Z, Y and Rx gate are all decomposed on a single qubit circuit.</p> <p><pre><code>from opensquirrel.decomposer.aba_decomposer import ZYZDecomposer\n\nbuilder = CircuitBuilder(qubit_register_size=1)\nbuilder.H(Qubit(0)).Z(Qubit(0)).Y(Qubit(0)).Rx(Qubit(0), Float(math.pi / 3))\nqc = builder.to_circuit()\n\nqc.decompose(decomposer=ZYZDecomposer())\n\nprint(qc)\n</code></pre> Output:</p> <pre><code>version 3.0\n\nqubit[1] q\n\nRz(3.1415927) q[0]\nRy(1.5707963) q[0]\nRz(3.1415927) q[0]\nRy(3.1415927) q[0]\nRz(1.5707963) q[0]\nRy(1.0471976) q[0]\nRz(-1.5707963) q[0]\n</code></pre> <p>Similarly, the decomposer can be used on individual gates.</p> <p><pre><code>from opensquirrel.decomposer.aba_decomposer import XZXDecomposer\nfrom opensquirrel.default_gates import H\n\nprint(ZYZDecomposer().decompose(H(Qubit(0))))\n</code></pre> Output:</p> <pre><code>[BlochSphereRotation(Qubit[0], axis=Axis[0. 0. 1.], angle=1.5707963267948966, phase=0.0),\n BlochSphereRotation(Qubit[0], axis=Axis[0. 1. 0.], angle=1.5707963267948966, phase=0.0),\n BlochSphereRotation(Qubit[0], axis=Axis[0. 0. 1.], angle=1.5707963267948966, phase=0.0)]\n</code></pre>"},{"location":"tutorial.html#exporting-a-circuit","title":"Exporting a circuit","text":"<p>As you have seen in the examples above, you can turn a circuit into a cQASM string by simply using the <code>str</code> or <code>__repr__</code> methods. We are aiming to support the possibility to export to other languages as well, e.g., a OpenQASM 3.0 string, and frameworks, e.g., a Qiskit quantum circuit.</p>"},{"location":"reference/circuit.html","title":"circuit","text":""},{"location":"reference/circuit.html#opensquirrel.circuit.Circuit","title":"<code>Circuit</code>","text":"<p>The Circuit class is the only interface to access OpenSquirrel's features.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; c = Circuit.from_string(\"version 3.0; qubit[3] q; h q[0]\")\n&gt;&gt;&gt; c\nversion 3.0\n\nqubit[3] q\n\nh q[0]\n\n&gt;&gt;&gt; c.decomposer(decomposer=mckay_decomposer.McKayDecomposer)\n&gt;&gt;&gt; c\nversion 3.0\n\nqubit[3] q\n\nx90 q[0]\nrz q[0], 1.5707963\nx90 q[0]\n</code></pre> Source code in <code>opensquirrel\\circuit.py</code> <pre><code>class Circuit:\n    \"\"\"The Circuit class is the only interface to access OpenSquirrel's features.\n\n    Examples:\n        &gt;&gt;&gt; c = Circuit.from_string(\"version 3.0; qubit[3] q; h q[0]\")\n        &gt;&gt;&gt; c\n        version 3.0\n        &lt;BLANKLINE&gt;\n        qubit[3] q\n        &lt;BLANKLINE&gt;\n        h q[0]\n        &lt;BLANKLINE&gt;\n        &gt;&gt;&gt; c.decomposer(decomposer=mckay_decomposer.McKayDecomposer)\n        &gt;&gt;&gt; c\n        version 3.0\n        &lt;BLANKLINE&gt;\n        qubit[3] q\n        &lt;BLANKLINE&gt;\n        x90 q[0]\n        rz q[0], 1.5707963\n        x90 q[0]\n        &lt;BLANKLINE&gt;\n    \"\"\"\n\n    def __init__(self, register_manager: RegisterManager, ir: IR) -&gt; None:\n        \"\"\"Create a circuit object from a register manager and an IR.\"\"\"\n        self.register_manager = register_manager\n        self.ir = ir\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Write the circuit to a cQASM 3 string.\"\"\"\n        from opensquirrel.writer import writer\n\n        return writer.circuit_to_string(self)\n\n    def __eq__(self, other: Any) -&gt; bool:\n        if not isinstance(other, Circuit):\n            return False\n        return self.register_manager == other.register_manager and self.ir == other.ir\n\n    @classmethod\n    def from_string(\n        cls,\n        cqasm3_string: str,\n        gate_set: list[Callable[..., Gate]] = default_gate_set,\n        gate_aliases: Mapping[str, Callable[..., Gate]] = default_gate_aliases,\n        measurement_set: list[Callable[..., Measure]] = default_measurement_set,\n    ) -&gt; Circuit:\n        \"\"\"Create a circuit object from a cQasm3 string. All the gates in the circuit need to be defined in\n        the `gates` argument.\n\n        * type-checking is performed, eliminating qubit indices errors and incoherences\n        * checks that used gates are supported and mentioned in `gates` with appropriate signatures\n        * does not support map or variables, and other things...\n        * for example of `gates` dictionary, please look at TestGates.py\n\n        Args:\n            cqasm3_string: a cQASM 3 string\n            gate_set: an array of gate semantic functions. See default_gates for examples\n            gate_aliases: a dictionary of extra gate aliases, mapping strings to functions in the gate set\n            measurement_set: an array of measurement semantic functions. See default_measurements for examples\n        \"\"\"\n        from opensquirrel.parser.libqasm.parser import Parser\n\n        parser = Parser(\n            gate_set=gate_set,\n            gate_aliases=gate_aliases,\n            measurement_set=measurement_set,\n        )\n        return parser.circuit_from_string(cqasm3_string)\n\n    @property\n    def qubit_register_size(self) -&gt; int:\n        return self.register_manager.get_qubit_register_size()\n\n    @property\n    def bit_register_size(self) -&gt; int:\n        return self.register_manager.get_bit_register_size()\n\n    @property\n    def qubit_register_name(self) -&gt; str:\n        return self.register_manager.get_qubit_register_name()\n\n    @property\n    def bit_register_name(self) -&gt; str:\n        return self.register_manager.get_bit_register_name()\n\n    def merge_single_qubit_gates(self) -&gt; None:\n        \"\"\"Merge all consecutive 1-qubit gates in the circuit.\n        Gates obtained from merging other gates become anonymous gates.\n        \"\"\"\n        from opensquirrel.merger import general_merger\n\n        general_merger.merge_single_qubit_gates(self)\n\n    def decompose(self, decomposer: Decomposer) -&gt; None:\n        \"\"\"Generic decomposition pass.\n        It applies the given decomposer function to every gate in the circuit.\n        \"\"\"\n        from opensquirrel.decomposer import general_decomposer\n\n        general_decomposer.decompose(self.ir, decomposer)\n\n    def map(self, mapper: Mapper) -&gt; None:\n        \"\"\"Generic qubit mapper pass.\n        Map the (virtual) qubits of the circuit to the physical qubits of the target hardware.\n        \"\"\"\n        from opensquirrel.mapper.qubit_remapper import remap_ir\n\n        remap_ir(self, mapper.get_mapping())\n\n    def replace(self, gate_generator: Callable[..., Gate], f: Callable[..., list[Gate]]) -&gt; None:\n        \"\"\"Manually replace occurrences of a given gate with a list of gates.\n        `f` is a callable that takes the arguments of the gate that is to be replaced and\n        returns the decomposition as a list of gates.\n        \"\"\"\n        from opensquirrel.decomposer import general_decomposer\n\n        general_decomposer.replace(self.ir, gate_generator, f)\n\n    def export(self, fmt: Literal[ExportFormat.QUANTIFY_SCHEDULER] | None = None) -&gt; Any:\n        if fmt == ExportFormat.QUANTIFY_SCHEDULER:\n            from opensquirrel.exporter import quantify_scheduler_exporter\n\n            return quantify_scheduler_exporter.export(self)\n        msg = \"unknown exporter format\"\n        raise ValueError(msg)\n</code></pre>"},{"location":"reference/circuit.html#opensquirrel.circuit.Circuit.__init__","title":"<code>__init__(register_manager, ir)</code>","text":"<p>Create a circuit object from a register manager and an IR.</p> Source code in <code>opensquirrel\\circuit.py</code> <pre><code>def __init__(self, register_manager: RegisterManager, ir: IR) -&gt; None:\n    \"\"\"Create a circuit object from a register manager and an IR.\"\"\"\n    self.register_manager = register_manager\n    self.ir = ir\n</code></pre>"},{"location":"reference/circuit.html#opensquirrel.circuit.Circuit.__repr__","title":"<code>__repr__()</code>","text":"<p>Write the circuit to a cQASM 3 string.</p> Source code in <code>opensquirrel\\circuit.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Write the circuit to a cQASM 3 string.\"\"\"\n    from opensquirrel.writer import writer\n\n    return writer.circuit_to_string(self)\n</code></pre>"},{"location":"reference/circuit.html#opensquirrel.circuit.Circuit.decompose","title":"<code>decompose(decomposer)</code>","text":"<p>Generic decomposition pass. It applies the given decomposer function to every gate in the circuit.</p> Source code in <code>opensquirrel\\circuit.py</code> <pre><code>def decompose(self, decomposer: Decomposer) -&gt; None:\n    \"\"\"Generic decomposition pass.\n    It applies the given decomposer function to every gate in the circuit.\n    \"\"\"\n    from opensquirrel.decomposer import general_decomposer\n\n    general_decomposer.decompose(self.ir, decomposer)\n</code></pre>"},{"location":"reference/circuit.html#opensquirrel.circuit.Circuit.from_string","title":"<code>from_string(cqasm3_string, gate_set=default_gate_set, gate_aliases=default_gate_aliases, measurement_set=default_measurement_set)</code>  <code>classmethod</code>","text":"<p>Create a circuit object from a cQasm3 string. All the gates in the circuit need to be defined in the <code>gates</code> argument.</p> <ul> <li>type-checking is performed, eliminating qubit indices errors and incoherences</li> <li>checks that used gates are supported and mentioned in <code>gates</code> with appropriate signatures</li> <li>does not support map or variables, and other things...</li> <li>for example of <code>gates</code> dictionary, please look at TestGates.py</li> </ul> <p>Parameters:</p> Name Type Description Default <code>cqasm3_string</code> <code>str</code> <p>a cQASM 3 string</p> required <code>gate_set</code> <code>list[Callable[..., Gate]]</code> <p>an array of gate semantic functions. See default_gates for examples</p> <code>default_gate_set</code> <code>gate_aliases</code> <code>Mapping[str, Callable[..., Gate]]</code> <p>a dictionary of extra gate aliases, mapping strings to functions in the gate set</p> <code>default_gate_aliases</code> <code>measurement_set</code> <code>list[Callable[..., Measure]]</code> <p>an array of measurement semantic functions. See default_measurements for examples</p> <code>default_measurement_set</code> Source code in <code>opensquirrel\\circuit.py</code> <pre><code>@classmethod\ndef from_string(\n    cls,\n    cqasm3_string: str,\n    gate_set: list[Callable[..., Gate]] = default_gate_set,\n    gate_aliases: Mapping[str, Callable[..., Gate]] = default_gate_aliases,\n    measurement_set: list[Callable[..., Measure]] = default_measurement_set,\n) -&gt; Circuit:\n    \"\"\"Create a circuit object from a cQasm3 string. All the gates in the circuit need to be defined in\n    the `gates` argument.\n\n    * type-checking is performed, eliminating qubit indices errors and incoherences\n    * checks that used gates are supported and mentioned in `gates` with appropriate signatures\n    * does not support map or variables, and other things...\n    * for example of `gates` dictionary, please look at TestGates.py\n\n    Args:\n        cqasm3_string: a cQASM 3 string\n        gate_set: an array of gate semantic functions. See default_gates for examples\n        gate_aliases: a dictionary of extra gate aliases, mapping strings to functions in the gate set\n        measurement_set: an array of measurement semantic functions. See default_measurements for examples\n    \"\"\"\n    from opensquirrel.parser.libqasm.parser import Parser\n\n    parser = Parser(\n        gate_set=gate_set,\n        gate_aliases=gate_aliases,\n        measurement_set=measurement_set,\n    )\n    return parser.circuit_from_string(cqasm3_string)\n</code></pre>"},{"location":"reference/circuit.html#opensquirrel.circuit.Circuit.map","title":"<code>map(mapper)</code>","text":"<p>Generic qubit mapper pass. Map the (virtual) qubits of the circuit to the physical qubits of the target hardware.</p> Source code in <code>opensquirrel\\circuit.py</code> <pre><code>def map(self, mapper: Mapper) -&gt; None:\n    \"\"\"Generic qubit mapper pass.\n    Map the (virtual) qubits of the circuit to the physical qubits of the target hardware.\n    \"\"\"\n    from opensquirrel.mapper.qubit_remapper import remap_ir\n\n    remap_ir(self, mapper.get_mapping())\n</code></pre>"},{"location":"reference/circuit.html#opensquirrel.circuit.Circuit.merge_single_qubit_gates","title":"<code>merge_single_qubit_gates()</code>","text":"<p>Merge all consecutive 1-qubit gates in the circuit. Gates obtained from merging other gates become anonymous gates.</p> Source code in <code>opensquirrel\\circuit.py</code> <pre><code>def merge_single_qubit_gates(self) -&gt; None:\n    \"\"\"Merge all consecutive 1-qubit gates in the circuit.\n    Gates obtained from merging other gates become anonymous gates.\n    \"\"\"\n    from opensquirrel.merger import general_merger\n\n    general_merger.merge_single_qubit_gates(self)\n</code></pre>"},{"location":"reference/circuit.html#opensquirrel.circuit.Circuit.replace","title":"<code>replace(gate_generator, f)</code>","text":"<p>Manually replace occurrences of a given gate with a list of gates. <code>f</code> is a callable that takes the arguments of the gate that is to be replaced and returns the decomposition as a list of gates.</p> Source code in <code>opensquirrel\\circuit.py</code> <pre><code>def replace(self, gate_generator: Callable[..., Gate], f: Callable[..., list[Gate]]) -&gt; None:\n    \"\"\"Manually replace occurrences of a given gate with a list of gates.\n    `f` is a callable that takes the arguments of the gate that is to be replaced and\n    returns the decomposition as a list of gates.\n    \"\"\"\n    from opensquirrel.decomposer import general_decomposer\n\n    general_decomposer.replace(self.ir, gate_generator, f)\n</code></pre>"},{"location":"reference/circuit_builder.html","title":"circuit_builder","text":""},{"location":"reference/circuit_builder.html#opensquirrel.circuit_builder.CircuitBuilder","title":"<code>CircuitBuilder</code>","text":"<p>               Bases: <code>GateLibrary</code>, <code>MeasurementLibrary</code>, <code>ResetLibrary</code></p> <p>A class using the builder pattern to make construction of circuits easy from Python. Adds corresponding instruction when a method is called. Checks that instructions are known and called with the right arguments. Mainly here to allow for Qiskit-style circuit construction:</p> <p>Parameters:</p> Name Type Description Default <code>qubit_register_size</code> <code>int</code> <p>Size of the qubit register</p> required <code>bit_register_size</code> <code>int</code> <p>Size of the bit register</p> <code>0</code> <code>gate_set</code> <code>list</code> <p>Supported gates</p> <code>default_gate_set</code> <code>gate_aliases</code> <code>dict</code> <p>Supported gate aliases</p> <code>default_gate_aliases</code> <code>measurement_set</code> <code>list</code> <p>Supported measure instructions</p> <code>default_measurement_set</code> Example <p>CircuitBuilder(qubit_register_size=3, bit_register_size=3).        H(Qubit(0)).CNOT(Qubit(0), Qubit(1)).CNOT(Qubit(0), Qubit(2)).        to_circuit() version 3.0  qubit[3] q  h q[0] cnot q[0], q[1] cnot q[0], q[2]  Source code in <code>opensquirrel\\circuit_builder.py</code> <pre><code>class CircuitBuilder(GateLibrary, MeasurementLibrary, ResetLibrary):\n    \"\"\"\n    A class using the builder pattern to make construction of circuits easy from Python.\n    Adds corresponding instruction when a method is called. Checks that instructions are known and called with the right\n    arguments.\n    Mainly here to allow for Qiskit-style circuit construction:\n\n    Args:\n        qubit_register_size (int): Size of the qubit register\n        bit_register_size (int): Size of the bit register\n        gate_set (list): Supported gates\n        gate_aliases (dict): Supported gate aliases\n        measurement_set (list): Supported measure instructions\n\n    Example:\n        &gt;&gt;&gt; CircuitBuilder(qubit_register_size=3, bit_register_size=3).\\\n        H(Qubit(0)).CNOT(Qubit(0), Qubit(1)).CNOT(Qubit(0), Qubit(2)).\\\n        to_circuit()\n        version 3.0\n        &lt;BLANKLINE&gt;\n        qubit[3] q\n        &lt;BLANKLINE&gt;\n        h q[0]\n        cnot q[0], q[1]\n        cnot q[0], q[2]\n        &lt;BLANKLINE&gt;\n\n    \"\"\"\n\n    def __init__(\n        self,\n        qubit_register_size: int,\n        bit_register_size: int = 0,\n        gate_set: list[Callable[..., Gate]] = default_gate_set,\n        gate_aliases: Mapping[str, Callable[..., Gate]] = default_gate_aliases,\n        measurement_set: list[Callable[..., Measure]] = default_measurement_set,\n        reset_set: list[Callable[..., Reset]] = default_reset_set,\n    ) -&gt; None:\n        GateLibrary.__init__(self, gate_set, gate_aliases)\n        MeasurementLibrary.__init__(self, measurement_set)\n        ResetLibrary.__init__(self, reset_set)\n        self.register_manager = RegisterManager(QubitRegister(qubit_register_size), BitRegister(bit_register_size))\n        self.ir = IR()\n\n    def __getattr__(self, attr: Any) -&gt; Callable[..., Self]:\n        if attr == \"comment\":\n            return self._add_comment\n\n        return partial(self._add_instruction, attr)\n\n    def _add_comment(self, comment_string: str) -&gt; Self:\n        self.ir.add_comment(Comment(comment_string))\n        return self\n\n    def _add_instruction(self, attr: str, *args: Any) -&gt; Self:\n        if any(attr == measure.__name__ for measure in self.measurement_set):\n            generator_f_measure = MeasurementLibrary.get_measurement_f(self, attr)\n            self._check_generator_f_args(generator_f_measure, attr, args)\n            self.ir.add_measurement(generator_f_measure(*args))\n        elif any(attr == reset.__name__ for reset in self.reset_set):\n            generator_f_reset = ResetLibrary.get_reset_f(self, attr)\n            self._check_generator_f_args(generator_f_reset, attr, args)\n            self.ir.add_reset(generator_f_reset(*args))\n        else:\n            generator_f_gate = GateLibrary.get_gate_f(self, attr)\n            self._check_generator_f_args(generator_f_gate, attr, args)\n            self.ir.add_gate(generator_f_gate(*args))\n        return self\n\n    def _check_qubit_out_of_bounds_access(self, index: int) -&gt; None:\n        \"\"\"Throw error if qubit index is outside the qubit register range.\n\n        Args:\n            index: qubit index\n        \"\"\"\n        if index &gt;= self.register_manager.get_qubit_register_size():\n            msg = \"qubit index is out of bounds\"\n            raise IndexError(msg)\n\n    def _check_bit_out_of_bounds_access(self, index: int) -&gt; None:\n        \"\"\"Throw error if bit index is outside the qubit register range.\n\n        Args:\n            index: bit index\n        \"\"\"\n        if index &gt;= self.register_manager.get_bit_register_size():\n            msg = \"bit index is out of bounds\"\n            raise IndexError(msg)\n\n    def _check_generator_f_args(\n        self,\n        generator_f: Callable[..., Gate | Measure | Reset],\n        attr: str,\n        args: tuple[Any, ...],\n    ) -&gt; None:\n        \"\"\"General instruction validation function. The function checks if each instruction has the proper arguments\n        and if the qubit and bits are within the register range.\n\n        Args:\n            generator_f: Instruction function\n            attr: Type of instruction\n            args: Arguments parsed into the function\n\n        \"\"\"\n        for i, par in enumerate(inspect.signature(generator_f).parameters.values()):\n            if isinstance(par.annotation, str):\n                if args[i].__class__.__name__ != par.annotation:\n                    msg = (\n                        f\"wrong argument type for instruction `{attr}`, \"\n                        f\"got {type(args[i])} but expected {par.annotation}\"\n                    )\n                    raise TypeError(msg)\n            elif not isinstance(args[i], par.annotation):\n                msg = f\"wrong argument type for instruction `{attr}`, got {type(args[i])} but expected {par.annotation}\"\n                raise TypeError(msg)\n            if args[i].__class__.__name__ == \"Qubit\":\n                self._check_qubit_out_of_bounds_access(args[i].index)\n            elif args[i].__class__.__name__ == \"Bit\":\n                self._check_bit_out_of_bounds_access(args[i].index)\n\n    def to_circuit(self) -&gt; Circuit:\n        return Circuit(deepcopy(self.register_manager), deepcopy(self.ir))\n</code></pre>"},{"location":"reference/circuit_matrix_calculator.html","title":"circuit_matrix_calculator","text":""},{"location":"reference/circuit_matrix_calculator.html#opensquirrel.circuit_matrix_calculator.get_circuit_matrix","title":"<code>get_circuit_matrix(circuit)</code>","text":"<p>Compute the (large) unitary matrix corresponding to the circuit.</p> <p>This matrix has 4**n elements, where n is the number of qubits. Result is stored as a numpy array of complex numbers.</p> <p>Returns:</p> Type Description <code>NDArray[complex128]</code> <p>Matrix representation of the circuit.</p> Source code in <code>opensquirrel\\circuit_matrix_calculator.py</code> <pre><code>def get_circuit_matrix(circuit: Circuit) -&gt; NDArray[np.complex128]:\n    \"\"\"Compute the (large) unitary matrix corresponding to the circuit.\n\n    This matrix has 4**n elements, where n is the number of qubits. Result is stored as a numpy array of complex\n    numbers.\n\n    Returns:\n        Matrix representation of the circuit.\n    \"\"\"\n    impl = _CircuitMatrixCalculator(circuit.qubit_register_size)\n\n    circuit.ir.accept(impl)\n\n    return impl.matrix\n</code></pre>"},{"location":"reference/common.html","title":"common","text":""},{"location":"reference/common.html#opensquirrel.common.are_matrices_equivalent_up_to_global_phase","title":"<code>are_matrices_equivalent_up_to_global_phase(matrix_a, matrix_b)</code>","text":"<p>Checks whether two matrices are equivalent up to a global phase.</p> <p>Parameters:</p> Name Type Description Default <code>matrix_a</code> <code>NDArray[complex128]</code> <p>first matrix.</p> required <code>matrix_b</code> <code>NDArray[complex128]</code> <p>second matrix.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether two matrices are equivalent up to a global phase.</p> Source code in <code>opensquirrel\\common.py</code> <pre><code>def are_matrices_equivalent_up_to_global_phase(\n    matrix_a: NDArray[np.complex128], matrix_b: NDArray[np.complex128]\n) -&gt; bool:\n    \"\"\"Checks whether two matrices are equivalent up to a global phase.\n\n    Args:\n        matrix_a: first matrix.\n        matrix_b: second matrix.\n\n    Returns:\n        Whether two matrices are equivalent up to a global phase.\n    \"\"\"\n    first_non_zero = next(\n        (i, j) for i in range(matrix_a.shape[0]) for j in range(matrix_a.shape[1]) if abs(matrix_a[i, j]) &gt; ATOL\n    )\n\n    if abs(matrix_b[first_non_zero]) &lt; ATOL:\n        return False\n\n    phase_difference = matrix_a[first_non_zero] / matrix_b[first_non_zero]\n\n    return np.allclose(matrix_a, phase_difference * matrix_b)\n</code></pre>"},{"location":"reference/default_gates.html","title":"default_gates","text":""},{"location":"reference/default_measurements.html","title":"default_measurements","text":""},{"location":"reference/default_resets.html","title":"default_resets","text":""},{"location":"reference/exceptions.html","title":"exceptions","text":"<p>This module contains all custom exception used by <code>OpenSquirrel</code>.</p>"},{"location":"reference/exceptions.html#opensquirrel.exceptions.ExporterError","title":"<code>ExporterError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Should be raised when a circuit cannot be exported to the desired output format.</p> Source code in <code>opensquirrel\\exceptions.py</code> <pre><code>class ExporterError(Exception):\n    \"\"\"Should be raised when a circuit cannot be exported to the desired output format.\"\"\"\n</code></pre>"},{"location":"reference/exceptions.html#opensquirrel.exceptions.UnsupportedGateError","title":"<code>UnsupportedGateError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Should be raised when a gate is not supported.</p> Source code in <code>opensquirrel\\exceptions.py</code> <pre><code>class UnsupportedGateError(Exception):\n    \"\"\"Should be raised when a gate is not supported.\"\"\"\n\n    def __init__(self, gate: Any, *args: Any) -&gt; None:\n        \"\"\"Init of the ``UnsupportedGateError``.\n\n        Args:\n            gate: Gate that is not supported.\n        \"\"\"\n        super().__init__(f\"{gate} not supported\", *args)\n</code></pre>"},{"location":"reference/exceptions.html#opensquirrel.exceptions.UnsupportedGateError.__init__","title":"<code>__init__(gate, *args)</code>","text":"<p>Init of the <code>UnsupportedGateError</code>.</p> <p>Parameters:</p> Name Type Description Default <code>gate</code> <code>Any</code> <p>Gate that is not supported.</p> required Source code in <code>opensquirrel\\exceptions.py</code> <pre><code>def __init__(self, gate: Any, *args: Any) -&gt; None:\n    \"\"\"Init of the ``UnsupportedGateError``.\n\n    Args:\n        gate: Gate that is not supported.\n    \"\"\"\n    super().__init__(f\"{gate} not supported\", *args)\n</code></pre>"},{"location":"reference/instruction_library.html","title":"instruction_library","text":""},{"location":"reference/instruction_library.html#opensquirrel.instruction_library.InstructionLibrary","title":"<code>InstructionLibrary</code>","text":"<p>Base class for instruction libraries.</p> Source code in <code>opensquirrel\\instruction_library.py</code> <pre><code>class InstructionLibrary:\n    \"\"\"Base class for instruction libraries.\"\"\"\n</code></pre>"},{"location":"reference/ir.html","title":"ir","text":""},{"location":"reference/ir.html#opensquirrel.ir.Axis","title":"<code>Axis</code>","text":"<p>               Bases: <code>Sequence[float64]</code>, <code>Expression</code></p> <p>The <code>Axis</code> object parses and stores a vector containing 3 elements.</p> <p>The input vector is always normalized before it is stored.</p> Source code in <code>opensquirrel\\ir.py</code> <pre><code>class Axis(Sequence[np.float64], Expression):\n    \"\"\"The ``Axis`` object parses and stores a vector containing 3 elements.\n\n    The input vector is always normalized before it is stored.\n    \"\"\"\n\n    _len = 3\n\n    def __init__(self, *axis: AxisLike) -&gt; None:\n        \"\"\"Init of the ``Axis`` object.\n\n        axis: An ``AxisLike`` to create the axis from.\n        \"\"\"\n        axis_to_parse = axis[0] if len(axis) == 1 else cast(AxisLike, axis)\n        self._value = self._parse_and_validate_axislike(axis_to_parse)\n\n    @property\n    def value(self) -&gt; NDArray[np.float64]:\n        \"\"\"The ``Axis`` data saved as a 1D-Array with 3 elements.\"\"\"\n        return self._value\n\n    @value.setter\n    def value(self, axis: AxisLike) -&gt; None:\n        \"\"\"Parse and set a new axis.\n\n        Args:\n            axis: An ``AxisLike`` to create the axis from.\n        \"\"\"\n        self._value = self._parse_and_validate_axislike(axis)\n\n    @classmethod\n    def _parse_and_validate_axislike(cls, axis: AxisLike) -&gt; NDArray[np.float64]:\n        \"\"\"Parse and validate an ``AxisLike``.\n\n        Check if the `axis` can be cast to a 1DArray of length 3, raise an error\n        otherwise. After casting to an array, the axis is normalized.\n\n        Args:\n            axis: ``AxisLike`` to validate and parse.\n\n        Returns:\n            Parsed axis represented as a 1DArray of length 3.\n        \"\"\"\n        if isinstance(axis, Axis):\n            return axis.value\n\n        try:\n            axis = np.asarray(axis, dtype=float)\n        except (ValueError, TypeError) as e:\n            msg = \"axis requires an ArrayLike\"\n            raise TypeError(msg) from e\n        axis = axis.flatten()\n        if len(axis) != 3:\n            msg = f\"axis requires an ArrayLike of length 3, but received an ArrayLike of length {len(axis)}\"\n            raise ValueError(msg)\n        return cls._normalize_axis(axis)\n\n    @staticmethod\n    def _normalize_axis(axis: NDArray[np.float64]) -&gt; NDArray[np.float64]:\n        \"\"\"Normalize a NDArray.\n\n        Args:\n            axis: NDArray to normalize.\n\n        Returns:\n            Normalized NDArray.\n        \"\"\"\n        return axis / np.linalg.norm(axis)\n\n    def __getitem__(self, index: int, /) -&gt; np.float64:  # type:ignore[override]\n        \"\"\"Get the item at `index`.\"\"\"\n        return cast(np.float64, self.value[index])\n\n    def __len__(self) -&gt; int:\n        \"\"\"Length of the axis, which is always 3.\"\"\"\n        return self._len\n\n    def __repr__(self) -&gt; str:\n        \"\"\"String representation of the ``Axis``.\"\"\"\n        return f\"Axis{self.value}\"\n\n    def __array__(self, dtype: DTypeLike = None, *, copy: bool = True) -&gt; NDArray[Any]:\n        \"\"\"Convert the ``Axis`` data to an array.\"\"\"\n        return np.array(self.value, dtype=dtype, copy=copy)\n\n    def accept(self, visitor: IRVisitor) -&gt; Any:\n        \"\"\"Accept the ``Axis``.\"\"\"\n        return visitor.visit_axis(self)\n\n    def __eq__(self, other: Any) -&gt; bool:\n        \"\"\"Check if `self` is equal to other.\n\n        Two ``Axis`` objects are considered equal if their axes are equal.\n        \"\"\"\n        if not isinstance(other, Axis):\n            return False\n        return np.array_equal(self, other)\n</code></pre>"},{"location":"reference/ir.html#opensquirrel.ir.Axis.value","title":"<code>value: NDArray[np.float64]</code>  <code>property</code> <code>writable</code>","text":"<p>The <code>Axis</code> data saved as a 1D-Array with 3 elements.</p>"},{"location":"reference/ir.html#opensquirrel.ir.Axis.__array__","title":"<code>__array__(dtype=None, *, copy=True)</code>","text":"<p>Convert the <code>Axis</code> data to an array.</p> Source code in <code>opensquirrel\\ir.py</code> <pre><code>def __array__(self, dtype: DTypeLike = None, *, copy: bool = True) -&gt; NDArray[Any]:\n    \"\"\"Convert the ``Axis`` data to an array.\"\"\"\n    return np.array(self.value, dtype=dtype, copy=copy)\n</code></pre>"},{"location":"reference/ir.html#opensquirrel.ir.Axis.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Check if <code>self</code> is equal to other.</p> <p>Two <code>Axis</code> objects are considered equal if their axes are equal.</p> Source code in <code>opensquirrel\\ir.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n    \"\"\"Check if `self` is equal to other.\n\n    Two ``Axis`` objects are considered equal if their axes are equal.\n    \"\"\"\n    if not isinstance(other, Axis):\n        return False\n    return np.array_equal(self, other)\n</code></pre>"},{"location":"reference/ir.html#opensquirrel.ir.Axis.__getitem__","title":"<code>__getitem__(index)</code>","text":"<p>Get the item at <code>index</code>.</p> Source code in <code>opensquirrel\\ir.py</code> <pre><code>def __getitem__(self, index: int, /) -&gt; np.float64:  # type:ignore[override]\n    \"\"\"Get the item at `index`.\"\"\"\n    return cast(np.float64, self.value[index])\n</code></pre>"},{"location":"reference/ir.html#opensquirrel.ir.Axis.__init__","title":"<code>__init__(*axis)</code>","text":"<p>Init of the <code>Axis</code> object.</p> <p>axis: An <code>AxisLike</code> to create the axis from.</p> Source code in <code>opensquirrel\\ir.py</code> <pre><code>def __init__(self, *axis: AxisLike) -&gt; None:\n    \"\"\"Init of the ``Axis`` object.\n\n    axis: An ``AxisLike`` to create the axis from.\n    \"\"\"\n    axis_to_parse = axis[0] if len(axis) == 1 else cast(AxisLike, axis)\n    self._value = self._parse_and_validate_axislike(axis_to_parse)\n</code></pre>"},{"location":"reference/ir.html#opensquirrel.ir.Axis.__len__","title":"<code>__len__()</code>","text":"<p>Length of the axis, which is always 3.</p> Source code in <code>opensquirrel\\ir.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Length of the axis, which is always 3.\"\"\"\n    return self._len\n</code></pre>"},{"location":"reference/ir.html#opensquirrel.ir.Axis.__repr__","title":"<code>__repr__()</code>","text":"<p>String representation of the <code>Axis</code>.</p> Source code in <code>opensquirrel\\ir.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"String representation of the ``Axis``.\"\"\"\n    return f\"Axis{self.value}\"\n</code></pre>"},{"location":"reference/ir.html#opensquirrel.ir.Axis.accept","title":"<code>accept(visitor)</code>","text":"<p>Accept the <code>Axis</code>.</p> Source code in <code>opensquirrel\\ir.py</code> <pre><code>def accept(self, visitor: IRVisitor) -&gt; Any:\n    \"\"\"Accept the ``Axis``.\"\"\"\n    return visitor.visit_axis(self)\n</code></pre>"},{"location":"reference/ir.html#opensquirrel.ir.Gate","title":"<code>Gate</code>","text":"<p>               Bases: <code>Statement</code>, <code>ABC</code></p> Source code in <code>opensquirrel\\ir.py</code> <pre><code>class Gate(Statement, ABC):\n    def __init__(\n        self,\n        generator: Callable[..., Gate] | None = None,\n        arguments: tuple[Expression, ...] | None = None,\n        *args: Any,\n        **kwargs: Any,\n    ) -&gt; None:\n        # Note: two gates are considered equal even when their generators/arguments are different.\n        self.generator = generator\n        self.arguments = arguments\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, Gate):\n            return False\n        return compare_gates(self, other)\n\n    @property\n    def name(self) -&gt; str:\n        if self.generator:\n            return self.generator.__name__\n        return \"Anonymous gate: \" + self.__repr__()\n\n    @property\n    def is_anonymous(self) -&gt; bool:\n        return self.arguments is None\n\n    @staticmethod\n    def _check_repeated_qubit_operands(qubits: list[Qubit]) -&gt; bool:\n        \"\"\"Check if qubit operands are repeated.\n\n        Args:\n            qubits: List of qubits.\n\n        Returns:\n            Whether qubit operands are repeated.\n        \"\"\"\n        return len(qubits) != len(set(qubits))\n\n    @abstractmethod\n    def get_qubit_operands(self) -&gt; list[Qubit]:\n        \"\"\"Get the qubit operands of the Gate.\n\n        Returns:\n            List of qubits on which the Gate operates.\n        \"\"\"\n\n    @abstractmethod\n    def is_identity(self) -&gt; bool:\n        \"\"\"Check whether the Gate is an identity Gate.\n\n        Returns:\n            Boolean value stating whether the Gate is an identity Gate.\n        \"\"\"\n</code></pre>"},{"location":"reference/ir.html#opensquirrel.ir.Gate.get_qubit_operands","title":"<code>get_qubit_operands()</code>  <code>abstractmethod</code>","text":"<p>Get the qubit operands of the Gate.</p> <p>Returns:</p> Type Description <code>list[Qubit]</code> <p>List of qubits on which the Gate operates.</p> Source code in <code>opensquirrel\\ir.py</code> <pre><code>@abstractmethod\ndef get_qubit_operands(self) -&gt; list[Qubit]:\n    \"\"\"Get the qubit operands of the Gate.\n\n    Returns:\n        List of qubits on which the Gate operates.\n    \"\"\"\n</code></pre>"},{"location":"reference/ir.html#opensquirrel.ir.Gate.is_identity","title":"<code>is_identity()</code>  <code>abstractmethod</code>","text":"<p>Check whether the Gate is an identity Gate.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Boolean value stating whether the Gate is an identity Gate.</p> Source code in <code>opensquirrel\\ir.py</code> <pre><code>@abstractmethod\ndef is_identity(self) -&gt; bool:\n    \"\"\"Check whether the Gate is an identity Gate.\n\n    Returns:\n        Boolean value stating whether the Gate is an identity Gate.\n    \"\"\"\n</code></pre>"},{"location":"reference/reference.html","title":"Reference","text":"<ul> <li>opensquirrel<ul> <li>circuit</li> <li>circuit_builder</li> <li>circuit_matrix_calculator</li> <li>common</li> <li>decomposer<ul> <li>aba_decomposer</li> <li>cnot_decomposer</li> <li>general_decomposer</li> <li>mckay_decomposer</li> </ul> </li> <li>default_gates</li> <li>default_measurements</li> <li>default_resets</li> <li>exceptions</li> <li>exporter<ul> <li>export_format</li> <li>quantify_scheduler_exporter</li> </ul> </li> <li>instruction_library</li> <li>ir</li> <li>mapper<ul> <li>general_mapper</li> <li>mapping</li> <li>qubit_remapper</li> <li>simple_mappers</li> <li>utils</li> </ul> </li> <li>merger<ul> <li>general_merger</li> </ul> </li> <li>parser<ul> <li>libqasm<ul> <li>parser</li> </ul> </li> </ul> </li> <li>register_manager</li> <li>reindexer<ul> <li>qubit_reindexer</li> </ul> </li> <li>utils<ul> <li>check_passes<ul> <li>check_mapper</li> </ul> </li> <li>identity_filter</li> <li>matrix_expander</li> </ul> </li> <li>writer<ul> <li>writer</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/register_manager.html","title":"register_manager","text":""},{"location":"reference/register_manager.html#opensquirrel.register_manager.BitRegister","title":"<code>BitRegister</code>","text":"<p>               Bases: <code>Register</code></p> <p>BitRegister manages a (virtual) bit register.</p> Source code in <code>opensquirrel\\register_manager.py</code> <pre><code>class BitRegister(Register):\n    \"\"\"BitRegister manages a (virtual) bit register.\"\"\"\n\n    _default_bit_register_name: str = \"b\"\n\n    @property\n    def name(self) -&gt; str:\n        return self._default_bit_register_name\n\n    @staticmethod\n    def is_of_type(variable: cqasm.semantic.MultiVariable) -&gt; bool:\n        return is_bit_type(variable)\n</code></pre>"},{"location":"reference/register_manager.html#opensquirrel.register_manager.QubitRegister","title":"<code>QubitRegister</code>","text":"<p>               Bases: <code>Register</code></p> <p>QubitRegister manages a (virtual) qubit register.</p> Source code in <code>opensquirrel\\register_manager.py</code> <pre><code>class QubitRegister(Register):\n    \"\"\"QubitRegister manages a (virtual) qubit register.\"\"\"\n\n    _default_qubit_register_name: str = \"q\"\n\n    @property\n    def name(self) -&gt; str:\n        return self._default_qubit_register_name\n\n    @staticmethod\n    def is_of_type(variable: cqasm.semantic.MultiVariable) -&gt; bool:\n        return is_qubit_type(variable)\n</code></pre>"},{"location":"reference/register_manager.html#opensquirrel.register_manager.Register","title":"<code>Register</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Register manages a (virtual) register.</p> Source code in <code>opensquirrel\\register_manager.py</code> <pre><code>class Register(ABC):\n    \"\"\"Register manages a (virtual) register.\"\"\"\n\n    @property\n    @abstractmethod\n    def name(self) -&gt; str: ...\n\n    @staticmethod\n    @abstractmethod\n    def is_of_type(variable: cqasm.semantic.MultiVariable) -&gt; bool: ...\n\n    def __init__(\n        self,\n        register_size: int,\n        variable_name_to_range: dict[str, Range] | None = None,\n        index_to_variable_name: dict[int, str] | None = None,\n    ) -&gt; None:\n        self.register_size: int = register_size\n        self.variable_name_to_range: dict[str, Range] = variable_name_to_range or {}\n        self.index_to_variable_name: dict[int, str] = index_to_variable_name or {}\n\n    def __eq__(self, other: Any) -&gt; bool:\n        if not isinstance(other, Register):\n            return False\n        return (\n            self.register_size == other.register_size\n            and self.variable_name_to_range == other.variable_name_to_range\n            and self.index_to_variable_name == other.index_to_variable_name\n        )\n\n    def get_variable_name(self, index: int) -&gt; str:\n        \"\"\"Get the variable name at `index`.\"\"\"\n        return self.index_to_variable_name[index]\n\n    def get_range(self, variable_name: str) -&gt; Range:\n        \"\"\"Get the Range for a `variable_name`.\"\"\"\n        return self.variable_name_to_range[variable_name]\n\n    def get_index(self, variable_name: str, sub_index: int) -&gt; int:\n        \"\"\"Get the Index for a given `subIndex` of a `variable_name`.\"\"\"\n        return self.variable_name_to_range[variable_name].first + sub_index\n\n    def __repr__(self) -&gt; str:\n        entries: str = \"\"\n        first: bool = True\n        for variable_name, register_range in self.variable_name_to_range.items():\n            entries += \"{}{}: {}\".format(\"\" if first else \", \", variable_name, register_range)\n            first = False\n        return f\"{{ {entries} }}\"\n\n    def size(self) -&gt; int:\n        return self.register_size\n\n    @classmethod\n    def from_ast(cls, ast: cqasm.semantic.Program) -&gt; Self:\n        variables = [v for v in ast.variables if cls.is_of_type(v)]\n        register_size = sum([v.typ.size for v in variables])\n        variable_name_to_range: dict[str, Range] = {}\n        index_to_variable_name: dict[int, str] = {}\n\n        current_index: int = 0\n        for v in variables:\n            v_name = v.name\n            v_size = v.typ.size\n            variable_name_to_range[v_name] = Range(current_index, v_size)\n            for _ in range(v_size):\n                index_to_variable_name[current_index] = v_name\n                current_index += 1\n        return cls(register_size, variable_name_to_range, index_to_variable_name)\n</code></pre>"},{"location":"reference/register_manager.html#opensquirrel.register_manager.Register.get_index","title":"<code>get_index(variable_name, sub_index)</code>","text":"<p>Get the Index for a given <code>subIndex</code> of a <code>variable_name</code>.</p> Source code in <code>opensquirrel\\register_manager.py</code> <pre><code>def get_index(self, variable_name: str, sub_index: int) -&gt; int:\n    \"\"\"Get the Index for a given `subIndex` of a `variable_name`.\"\"\"\n    return self.variable_name_to_range[variable_name].first + sub_index\n</code></pre>"},{"location":"reference/register_manager.html#opensquirrel.register_manager.Register.get_range","title":"<code>get_range(variable_name)</code>","text":"<p>Get the Range for a <code>variable_name</code>.</p> Source code in <code>opensquirrel\\register_manager.py</code> <pre><code>def get_range(self, variable_name: str) -&gt; Range:\n    \"\"\"Get the Range for a `variable_name`.\"\"\"\n    return self.variable_name_to_range[variable_name]\n</code></pre>"},{"location":"reference/register_manager.html#opensquirrel.register_manager.Register.get_variable_name","title":"<code>get_variable_name(index)</code>","text":"<p>Get the variable name at <code>index</code>.</p> Source code in <code>opensquirrel\\register_manager.py</code> <pre><code>def get_variable_name(self, index: int) -&gt; str:\n    \"\"\"Get the variable name at `index`.\"\"\"\n    return self.index_to_variable_name[index]\n</code></pre>"},{"location":"reference/register_manager.html#opensquirrel.register_manager.RegisterManager","title":"<code>RegisterManager</code>","text":"<p>RegisterManager keeps track of a (virtual) qubit register, i.e., an array of consecutive qubits, and the mappings between the (logical) qubit variable names, as used in an input cQASM program, and the (virtual) qubit register.</p> <p>For example, given an input program that defines 'qubit[3] q': - variable 'q' is mapped to qubits 0 to 2 in the qubit register, and - positions 0 to 2 in the qubit register are mapped to variable 'q'.</p> <p>The mapping of qubit variable names to positions in the qubit register is an implementation detail, i.e., it is not guaranteed that qubit register indices are assigned to qubit variable names in the order these variables are defined in the input program.</p> Source code in <code>opensquirrel\\register_manager.py</code> <pre><code>class RegisterManager:\n    \"\"\"RegisterManager keeps track of a (virtual) qubit register, i.e., an array of consecutive qubits,\n    and the mappings between the (logical) qubit variable names, as used in an input cQASM program,\n    and the (virtual) qubit register.\n\n    For example, given an input program that defines 'qubit[3] q':\n    - variable 'q' is mapped to qubits 0 to 2 in the qubit register, and\n    - positions 0 to 2 in the qubit register are mapped to variable 'q'.\n\n    The mapping of qubit variable names to positions in the qubit register is an implementation detail,\n    i.e., it is not guaranteed that qubit register indices are assigned to qubit variable names in the order\n    these variables are defined in the input program.\n    \"\"\"\n\n    def __init__(self, qubit_register: QubitRegister, bit_register: BitRegister | None = None) -&gt; None:\n        self.qubit_register: QubitRegister = qubit_register\n        self.bit_register: BitRegister = bit_register or BitRegister(0)\n\n    def __repr__(self) -&gt; str:\n        return f\"qubit_register:\\n{self.qubit_register}\\nbit_register:\\n{self.bit_register}\"\n\n    @classmethod\n    def from_ast(cls, ast: cqasm.semantic.Program) -&gt; Self:\n        qubit_register = QubitRegister.from_ast(ast)\n        bit_register = BitRegister.from_ast(ast)\n        return cls(qubit_register, bit_register)\n\n    def __eq__(self, other: Any) -&gt; bool:\n        if not isinstance(other, RegisterManager):\n            return False\n        return self.qubit_register == other.qubit_register and self.bit_register == other.bit_register\n\n    def get_qubit_register_size(self) -&gt; int:\n        return self.qubit_register.size()\n\n    def get_bit_register_size(self) -&gt; int:\n        return self.bit_register.size()\n\n    def get_qubit_register_name(self) -&gt; str:\n        return self.qubit_register.name\n\n    def get_bit_register_name(self) -&gt; str:\n        return self.bit_register.name\n\n    def get_qubit_range(self, variable_name: str) -&gt; Range:\n        return self.qubit_register.get_range(variable_name)\n\n    def get_bit_range(self, variable_name: str) -&gt; Range:\n        return self.bit_register.get_range(variable_name)\n\n    def get_qubit_index(self, variable_name: str, sub_index: int) -&gt; int:\n        return self.qubit_register.get_index(variable_name, sub_index)\n\n    def get_bit_index(self, variable_name: str, sub_index: int) -&gt; int:\n        return self.bit_register.get_index(variable_name, sub_index)\n\n    def get_qubit_variable_name(self, index: int) -&gt; str:\n        return self.qubit_register.get_variable_name(index)\n\n    def get_bit_variable_name(self, index: int) -&gt; str:\n        return self.bit_register.get_variable_name(index)\n</code></pre>"},{"location":"reference/decomposer/aba_decomposer.html","title":"aba_decomposer","text":"<p>Module containing classes that inherit from the ABADecomposer class to decompose a circuit into one of the Pauli ABA decompositions.</p>"},{"location":"reference/decomposer/aba_decomposer.html#opensquirrel.decomposer.aba_decomposer.ABADecomposer","title":"<code>ABADecomposer</code>","text":"<p>               Bases: <code>Decomposer</code>, <code>ABC</code></p> Source code in <code>opensquirrel\\decomposer\\aba_decomposer.py</code> <pre><code>class ABADecomposer(Decomposer, ABC):\n    @property\n    @abstractmethod\n    def ra(self) -&gt; Callable[..., BlochSphereRotation]: ...\n\n    @property\n    @abstractmethod\n    def rb(self) -&gt; Callable[..., BlochSphereRotation]: ...\n\n    _gate_list: ClassVar[list[Callable[..., BlochSphereRotation]]] = [Rx, Ry, Rz]\n\n    def __init__(self) -&gt; None:\n        self.index_a = self._gate_list.index(self.ra)\n        self.index_b = self._gate_list.index(self.rb)\n\n    def _find_unused_index(self) -&gt; int:\n        \"\"\"Finds the index of the axis object that is not used in the decomposition.\n        For example, if one selects the ZYZ decomposition, the integer returned will be 0 (since it is X).\n        Returns:\n            Index of the axis object that is not used in the decomposition.\n        \"\"\"\n        return ({0, 1, 2} - {self.index_a, self.index_b}).pop()\n\n    def get_decomposition_angles(self, alpha: float, axis: AxisLike) -&gt; tuple[float, float, float]:\n        \"\"\"Gives the angles used in the A-B-A decomposition of the Bloch sphere rotation\n        characterized by a rotation around `axis` of angle `alpha`.\n\n        Parameters:\n            alpha: angle of the Bloch sphere rotation\n            axis: _normalized_ axis of the Bloch sphere rotation\n\n        Returns:\n            A triple (theta1, theta2, theta3) corresponding to the decomposition of the\n            arbitrary Bloch sphere rotation into U = Ra(theta3) Rb(theta2) Ra(theta1)\n\n        \"\"\"\n        axis = Axis(axis)\n        a_axis_value = axis[self.index_a]\n        b_axis_value = axis[self.index_b]\n        c_axis_value = axis[self._find_unused_index()]\n\n        if not (-math.pi + ATOL &lt; alpha &lt;= math.pi + ATOL):\n            msg = \"angle needs to be normalized\"\n            raise ValueError(msg)\n\n        if abs(alpha - math.pi) &lt; ATOL:\n            # alpha == pi, math.tan(alpha / 2) is not defined.\n            if abs(a_axis_value) &lt; ATOL:\n                theta2 = math.pi\n                p = 0.0\n                m = 2 * math.acos(b_axis_value)\n            else:\n                p = math.pi\n                theta2 = 2 * math.acos(a_axis_value)\n                if abs(a_axis_value - 1) &lt; ATOL or abs(a_axis_value + 1) &lt; ATOL:\n                    m = p  # This can be anything, but setting m = p means theta3 == 0, which is better for gate count.\n                else:\n                    m = 2 * math.acos(\n                        round(b_axis_value / math.sqrt(1 - a_axis_value**2), abs(math.floor(math.log10(ATOL)))),\n                    )\n\n        else:\n            p = 2 * math.atan2(a_axis_value * math.sin(alpha / 2), math.cos(alpha / 2))\n            acos_argument = math.cos(alpha / 2) * math.sqrt(1 + (a_axis_value * math.tan(alpha / 2)) ** 2)\n\n            # This fixes float approximations like 1.0000000000002, which acos does not like.\n            acos_argument = max(min(acos_argument, 1.0), -1.0)\n\n            theta2 = 2 * math.acos(acos_argument)\n            theta2 = math.copysign(theta2, alpha)\n\n            if abs(math.sin(theta2 / 2)) &lt; ATOL:\n                m = p  # This can be anything, but setting m = p means theta3 == 0, which is better for gate count.\n            else:\n                acos_argument = float(b_axis_value) * math.sin(alpha / 2) / math.sin(theta2 / 2)\n\n                # This fixes float approximations like 1.0000000000002, which acos does not like.\n                acos_argument = max(min(acos_argument, 1.0), -1.0)\n                m = 2 * math.acos(acos_argument)\n                if math.pi - abs(m) &gt; ATOL:\n                    m_sign = 2 * math.atan2(c_axis_value, a_axis_value)\n                    m = math.copysign(m, m_sign)\n\n        is_sin_m_negative = self.index_a - self.index_b in (-1, 2)\n        if is_sin_m_negative:\n            m = m * -1\n\n        theta1 = (p + m) / 2\n        theta3 = p - theta1\n\n        return theta1, theta2, theta3\n\n    def decompose(self, g: Gate) -&gt; list[Gate]:\n        \"\"\"General A-B-A decomposition function for a single gate.\n\n        Args:\n            g: gate to decompose.\n\n        Returns:\n            Three gates, following the A-B-A convention, corresponding to the decomposition of the input gate.\n        \"\"\"\n        if not isinstance(g, BlochSphereRotation):\n            # We only decompose Bloch sphere rotations.\n            return [g]\n\n        theta1, theta2, theta3 = self.get_decomposition_angles(g.angle, g.axis)\n        a1 = self.ra(g.qubit, Float(theta1))\n        b = self.rb(g.qubit, Float(theta2))\n        a2 = self.ra(g.qubit, Float(theta3))\n        return filter_out_identities([a1, b, a2])\n</code></pre>"},{"location":"reference/decomposer/aba_decomposer.html#opensquirrel.decomposer.aba_decomposer.ABADecomposer.decompose","title":"<code>decompose(g)</code>","text":"<p>General A-B-A decomposition function for a single gate.</p> <p>Parameters:</p> Name Type Description Default <code>g</code> <code>Gate</code> <p>gate to decompose.</p> required <p>Returns:</p> Type Description <code>list[Gate]</code> <p>Three gates, following the A-B-A convention, corresponding to the decomposition of the input gate.</p> Source code in <code>opensquirrel\\decomposer\\aba_decomposer.py</code> <pre><code>def decompose(self, g: Gate) -&gt; list[Gate]:\n    \"\"\"General A-B-A decomposition function for a single gate.\n\n    Args:\n        g: gate to decompose.\n\n    Returns:\n        Three gates, following the A-B-A convention, corresponding to the decomposition of the input gate.\n    \"\"\"\n    if not isinstance(g, BlochSphereRotation):\n        # We only decompose Bloch sphere rotations.\n        return [g]\n\n    theta1, theta2, theta3 = self.get_decomposition_angles(g.angle, g.axis)\n    a1 = self.ra(g.qubit, Float(theta1))\n    b = self.rb(g.qubit, Float(theta2))\n    a2 = self.ra(g.qubit, Float(theta3))\n    return filter_out_identities([a1, b, a2])\n</code></pre>"},{"location":"reference/decomposer/aba_decomposer.html#opensquirrel.decomposer.aba_decomposer.ABADecomposer.get_decomposition_angles","title":"<code>get_decomposition_angles(alpha, axis)</code>","text":"<p>Gives the angles used in the A-B-A decomposition of the Bloch sphere rotation characterized by a rotation around <code>axis</code> of angle <code>alpha</code>.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>float</code> <p>angle of the Bloch sphere rotation</p> required <code>axis</code> <code>AxisLike</code> <p>normalized axis of the Bloch sphere rotation</p> required <p>Returns:</p> Type Description <code>float</code> <p>A triple (theta1, theta2, theta3) corresponding to the decomposition of the</p> <code>float</code> <p>arbitrary Bloch sphere rotation into U = Ra(theta3) Rb(theta2) Ra(theta1)</p> Source code in <code>opensquirrel\\decomposer\\aba_decomposer.py</code> <pre><code>def get_decomposition_angles(self, alpha: float, axis: AxisLike) -&gt; tuple[float, float, float]:\n    \"\"\"Gives the angles used in the A-B-A decomposition of the Bloch sphere rotation\n    characterized by a rotation around `axis` of angle `alpha`.\n\n    Parameters:\n        alpha: angle of the Bloch sphere rotation\n        axis: _normalized_ axis of the Bloch sphere rotation\n\n    Returns:\n        A triple (theta1, theta2, theta3) corresponding to the decomposition of the\n        arbitrary Bloch sphere rotation into U = Ra(theta3) Rb(theta2) Ra(theta1)\n\n    \"\"\"\n    axis = Axis(axis)\n    a_axis_value = axis[self.index_a]\n    b_axis_value = axis[self.index_b]\n    c_axis_value = axis[self._find_unused_index()]\n\n    if not (-math.pi + ATOL &lt; alpha &lt;= math.pi + ATOL):\n        msg = \"angle needs to be normalized\"\n        raise ValueError(msg)\n\n    if abs(alpha - math.pi) &lt; ATOL:\n        # alpha == pi, math.tan(alpha / 2) is not defined.\n        if abs(a_axis_value) &lt; ATOL:\n            theta2 = math.pi\n            p = 0.0\n            m = 2 * math.acos(b_axis_value)\n        else:\n            p = math.pi\n            theta2 = 2 * math.acos(a_axis_value)\n            if abs(a_axis_value - 1) &lt; ATOL or abs(a_axis_value + 1) &lt; ATOL:\n                m = p  # This can be anything, but setting m = p means theta3 == 0, which is better for gate count.\n            else:\n                m = 2 * math.acos(\n                    round(b_axis_value / math.sqrt(1 - a_axis_value**2), abs(math.floor(math.log10(ATOL)))),\n                )\n\n    else:\n        p = 2 * math.atan2(a_axis_value * math.sin(alpha / 2), math.cos(alpha / 2))\n        acos_argument = math.cos(alpha / 2) * math.sqrt(1 + (a_axis_value * math.tan(alpha / 2)) ** 2)\n\n        # This fixes float approximations like 1.0000000000002, which acos does not like.\n        acos_argument = max(min(acos_argument, 1.0), -1.0)\n\n        theta2 = 2 * math.acos(acos_argument)\n        theta2 = math.copysign(theta2, alpha)\n\n        if abs(math.sin(theta2 / 2)) &lt; ATOL:\n            m = p  # This can be anything, but setting m = p means theta3 == 0, which is better for gate count.\n        else:\n            acos_argument = float(b_axis_value) * math.sin(alpha / 2) / math.sin(theta2 / 2)\n\n            # This fixes float approximations like 1.0000000000002, which acos does not like.\n            acos_argument = max(min(acos_argument, 1.0), -1.0)\n            m = 2 * math.acos(acos_argument)\n            if math.pi - abs(m) &gt; ATOL:\n                m_sign = 2 * math.atan2(c_axis_value, a_axis_value)\n                m = math.copysign(m, m_sign)\n\n    is_sin_m_negative = self.index_a - self.index_b in (-1, 2)\n    if is_sin_m_negative:\n        m = m * -1\n\n    theta1 = (p + m) / 2\n    theta3 = p - theta1\n\n    return theta1, theta2, theta3\n</code></pre>"},{"location":"reference/decomposer/aba_decomposer.html#opensquirrel.decomposer.aba_decomposer.XYXDecomposer","title":"<code>XYXDecomposer</code>","text":"<p>               Bases: <code>ABADecomposer</code></p> <p>Class responsible for the X-Y-X decomposition.</p> Source code in <code>opensquirrel\\decomposer\\aba_decomposer.py</code> <pre><code>class XYXDecomposer(ABADecomposer):\n    \"\"\"Class responsible for the X-Y-X decomposition.\"\"\"\n\n    @property\n    def ra(self) -&gt; Callable[..., BlochSphereRotation]:\n        return Rx\n\n    @property\n    def rb(self) -&gt; Callable[..., BlochSphereRotation]:\n        return Ry\n</code></pre>"},{"location":"reference/decomposer/aba_decomposer.html#opensquirrel.decomposer.aba_decomposer.XZXDecomposer","title":"<code>XZXDecomposer</code>","text":"<p>               Bases: <code>ABADecomposer</code></p> <p>Class responsible for the X-Z-X decomposition.</p> Source code in <code>opensquirrel\\decomposer\\aba_decomposer.py</code> <pre><code>class XZXDecomposer(ABADecomposer):\n    \"\"\"Class responsible for the X-Z-X decomposition.\"\"\"\n\n    @property\n    def ra(self) -&gt; Callable[..., BlochSphereRotation]:\n        return Rx\n\n    @property\n    def rb(self) -&gt; Callable[..., BlochSphereRotation]:\n        return Rz\n</code></pre>"},{"location":"reference/decomposer/aba_decomposer.html#opensquirrel.decomposer.aba_decomposer.YXYDecomposer","title":"<code>YXYDecomposer</code>","text":"<p>               Bases: <code>ABADecomposer</code></p> <p>Class responsible for the Y-X-Y decomposition.</p> Source code in <code>opensquirrel\\decomposer\\aba_decomposer.py</code> <pre><code>class YXYDecomposer(ABADecomposer):\n    \"\"\"Class responsible for the Y-X-Y decomposition.\"\"\"\n\n    @property\n    def ra(self) -&gt; Callable[..., BlochSphereRotation]:\n        return Ry\n\n    @property\n    def rb(self) -&gt; Callable[..., BlochSphereRotation]:\n        return Rx\n</code></pre>"},{"location":"reference/decomposer/aba_decomposer.html#opensquirrel.decomposer.aba_decomposer.YZYDecomposer","title":"<code>YZYDecomposer</code>","text":"<p>               Bases: <code>ABADecomposer</code></p> <p>Class responsible for the Y-Z-Y decomposition.</p> Source code in <code>opensquirrel\\decomposer\\aba_decomposer.py</code> <pre><code>class YZYDecomposer(ABADecomposer):\n    \"\"\"Class responsible for the Y-Z-Y decomposition.\"\"\"\n\n    @property\n    def ra(self) -&gt; Callable[..., BlochSphereRotation]:\n        return Ry\n\n    @property\n    def rb(self) -&gt; Callable[..., BlochSphereRotation]:\n        return Rz\n</code></pre>"},{"location":"reference/decomposer/aba_decomposer.html#opensquirrel.decomposer.aba_decomposer.ZXZDecomposer","title":"<code>ZXZDecomposer</code>","text":"<p>               Bases: <code>ABADecomposer</code></p> <p>Class responsible for the Z-X-Z decomposition.</p> Source code in <code>opensquirrel\\decomposer\\aba_decomposer.py</code> <pre><code>class ZXZDecomposer(ABADecomposer):\n    \"\"\"Class responsible for the Z-X-Z decomposition.\"\"\"\n\n    @property\n    def ra(self) -&gt; Callable[..., BlochSphereRotation]:\n        return Rz\n\n    @property\n    def rb(self) -&gt; Callable[..., BlochSphereRotation]:\n        return Rx\n</code></pre>"},{"location":"reference/decomposer/aba_decomposer.html#opensquirrel.decomposer.aba_decomposer.ZYZDecomposer","title":"<code>ZYZDecomposer</code>","text":"<p>               Bases: <code>ABADecomposer</code></p> <p>Class responsible for the Z-Y-Z decomposition.</p> Source code in <code>opensquirrel\\decomposer\\aba_decomposer.py</code> <pre><code>class ZYZDecomposer(ABADecomposer):\n    \"\"\"Class responsible for the Z-Y-Z decomposition.\"\"\"\n\n    @property\n    def ra(self) -&gt; Callable[..., BlochSphereRotation]:\n        return Rz\n\n    @property\n    def rb(self) -&gt; Callable[..., BlochSphereRotation]:\n        return Ry\n</code></pre>"},{"location":"reference/decomposer/cnot_decomposer.html","title":"cnot_decomposer","text":""},{"location":"reference/decomposer/cnot_decomposer.html#opensquirrel.decomposer.cnot_decomposer.CNOTDecomposer","title":"<code>CNOTDecomposer</code>","text":"<p>               Bases: <code>Decomposer</code></p> <p>Decomposes 2-qubit controlled unitary gates to CNOT + Rz/Ry. Applying single-qubit gate fusion after this pass might be beneficial.</p> <p>Source of the math: https://threeplusone.com/pubs/on_gates.pdf, chapter 7.5 \"ABC decomposition\"</p> Source code in <code>opensquirrel\\decomposer\\cnot_decomposer.py</code> <pre><code>class CNOTDecomposer(Decomposer):\n    \"\"\"\n    Decomposes 2-qubit controlled unitary gates to CNOT + Rz/Ry.\n    Applying single-qubit gate fusion after this pass might be beneficial.\n\n    Source of the math: https://threeplusone.com/pubs/on_gates.pdf, chapter 7.5 \"ABC decomposition\"\n    \"\"\"\n\n    def decompose(self, g: Gate) -&gt; list[Gate]:\n        if not isinstance(g, ControlledGate):\n            # Do nothing:\n            # - BlochSphereRotation's are only single-qubit,\n            # - decomposing MatrixGate is currently not supported.\n            return [g]\n\n        if not isinstance(g.target_gate, BlochSphereRotation):\n            # Do nothing.\n            # ControlledGate's with 2+ control qubits are ignored.\n            return [g]\n\n        target_qubit = g.target_gate.qubit\n\n        # Perform ZYZ decomposition on the target gate.\n        # This gives us an ABC decomposition (U = AXBXC, ABC = I) of the target gate.\n        # See https://threeplusone.com/pubs/on_gates.pdf\n\n        # Try special case first, see https://arxiv.org/pdf/quant-ph/9503016.pdf lemma 5.5\n        controlled_rotation_times_x = general_merger.compose_bloch_sphere_rotations(X(target_qubit), g.target_gate)\n        theta0_with_x, theta1_with_x, theta2_with_x = ZYZDecomposer().get_decomposition_angles(\n            controlled_rotation_times_x.angle,\n            controlled_rotation_times_x.axis,\n        )\n        if abs((theta0_with_x - theta2_with_x) % (2 * math.pi)) &lt; ATOL:\n            # The decomposition can use a single CNOT according to the lemma.\n            A = [Ry(target_qubit, Float(-theta1_with_x / 2)), Rz(target_qubit, Float(-theta2_with_x))]\n            B = [Rz(target_qubit, Float(theta2_with_x)), Ry(target_qubit, Float(theta1_with_x / 2))]\n\n            return filter_out_identities(\n                [\n                    *B,\n                    CNOT(g.control_qubit, target_qubit),\n                    *A,\n                    Rz(g.control_qubit, Float(g.target_gate.phase - math.pi / 2)),\n                ],\n            )\n\n        theta0, theta1, theta2 = ZYZDecomposer().get_decomposition_angles(g.target_gate.angle, g.target_gate.axis)\n\n        A = [Ry(target_qubit, Float(theta1 / 2)), Rz(target_qubit, Float(theta2))]\n        B = [Rz(target_qubit, Float(-(theta0 + theta2) / 2)), Ry(target_qubit, Float(-theta1 / 2))]\n        C = [Rz(target_qubit, Float((theta0 - theta2) / 2))]\n\n        return filter_out_identities(\n            [\n                *C,\n                CNOT(g.control_qubit, target_qubit),\n                *B,\n                CNOT(g.control_qubit, target_qubit),\n                *A,\n                Rz(g.control_qubit, Float(g.target_gate.phase)),\n            ],\n        )\n</code></pre>"},{"location":"reference/decomposer/general_decomposer.html","title":"general_decomposer","text":""},{"location":"reference/decomposer/general_decomposer.html#opensquirrel.decomposer.general_decomposer.decompose","title":"<code>decompose(ir, decomposer)</code>","text":"<p>Applies <code>decomposer</code> to every gate in the circuit, replacing each gate by the output of <code>decomposer</code>. When <code>decomposer</code> decides to not decomposer a gate, it needs to return a list with the intact gate as single element.</p> Source code in <code>opensquirrel\\decomposer\\general_decomposer.py</code> <pre><code>def decompose(ir: IR, decomposer: Decomposer) -&gt; None:\n    \"\"\"Applies `decomposer` to every gate in the circuit, replacing each gate by the output of `decomposer`.\n    When `decomposer` decides to not decomposer a gate, it needs to return a list with the intact gate as single\n    element.\n    \"\"\"\n    statement_index = 0\n    while statement_index &lt; len(ir.statements):\n        statement = ir.statements[statement_index]\n\n        if not isinstance(statement, Gate):\n            statement_index += 1\n            continue\n\n        gate = statement\n        replacement_gates: list[Gate] = decomposer.decompose(statement)\n        check_gate_replacement(gate, replacement_gates)\n\n        ir.statements[statement_index : statement_index + 1] = replacement_gates\n        statement_index += len(replacement_gates)\n</code></pre>"},{"location":"reference/decomposer/general_decomposer.html#opensquirrel.decomposer.general_decomposer.replace","title":"<code>replace(ir, gate_generator, f)</code>","text":"<p>Does the same as decomposer, but only applies to a given gate.</p> Source code in <code>opensquirrel\\decomposer\\general_decomposer.py</code> <pre><code>def replace(ir: IR, gate_generator: Callable[..., Gate], f: Callable[..., list[Gate]]) -&gt; None:\n    \"\"\"Does the same as decomposer, but only applies to a given gate.\"\"\"\n    generic_replacer = _GenericReplacer(gate_generator, f)\n\n    decompose(ir, generic_replacer)\n</code></pre>"},{"location":"reference/decomposer/mckay_decomposer.html","title":"mckay_decomposer","text":""},{"location":"reference/decomposer/mckay_decomposer.html#opensquirrel.decomposer.mckay_decomposer.McKayDecomposer","title":"<code>McKayDecomposer</code>","text":"<p>               Bases: <code>Decomposer</code></p> Source code in <code>opensquirrel\\decomposer\\mckay_decomposer.py</code> <pre><code>class McKayDecomposer(Decomposer):\n    def decompose(self, g: Gate) -&gt; list[Gate]:\n        \"\"\"Return the McKay decomposition of a 1-qubit gate as a list of gates.\n                gate   ----&gt;    Rz.Rx(pi/2).Rz.Rx(pi/2).Rz\n\n        The global phase is deemed _irrelevant_, therefore a simulator backend might produce different output.\n        The results should be equivalent modulo global phase.\n        Notice that, if the gate is Rz or X90, it will not be decomposed further, since they are natively used\n        in the McKay decomposition.\n\n        Relevant literature: https://arxiv.org/abs/1612.00858\n        \"\"\"\n        if not isinstance(g, BlochSphereRotation) or g.name == \"Rz\" or g.name == \"X90\":\n            return [g]\n\n        if abs(g.angle) &lt; ATOL:\n            return []\n\n        if g.axis[0] == 0 and g.axis[1] == 0:\n            rz_angle = float(g.angle * g.axis[2])\n            return [Rz(g.qubit, Float(rz_angle))]\n\n        zxz_decomposition = ZXZDecomposer().decompose(g)\n        zxz_angle = 0.0\n        if len(zxz_decomposition) &gt;= 2 and isinstance(zxz_decomposition[1], BlochSphereRotation):\n            zxz_angle = zxz_decomposition[1].angle\n\n        if abs(zxz_angle - pi / 2) &lt; ATOL:\n            zxz_decomposition[1] = X90(g.qubit)\n            return zxz_decomposition\n\n        # McKay decomposition\n        za_mod = sqrt(cos(g.angle / 2) ** 2 + (g.axis[2] * sin(g.angle / 2)) ** 2)\n        zb_mod = abs(sin(g.angle / 2)) * sqrt(g.axis[0] ** 2 + g.axis[1] ** 2)\n\n        theta = pi - 2 * atan2(zb_mod, za_mod)\n\n        alpha = atan2(-sin(g.angle / 2) * g.axis[2], cos(g.angle / 2))\n        beta = atan2(-sin(g.angle / 2) * g.axis[0], -sin(g.angle / 2) * g.axis[1])\n\n        lam = beta - alpha\n        phi = -beta - alpha - pi\n\n        lam = normalize_angle(lam)\n        phi = normalize_angle(phi)\n        theta = normalize_angle(theta)\n\n        decomposed_g: list[Gate] = []\n\n        if abs(theta) &lt; ATOL and lam == phi:\n            decomposed_g.append(X90(g.qubit))\n            decomposed_g.append(X90(g.qubit))\n            return decomposed_g\n\n        if abs(lam) &gt; ATOL:\n            decomposed_g.append(Rz(g.qubit, Float(lam)))\n\n        decomposed_g.append(X90(g.qubit))\n\n        if abs(theta) &gt; ATOL:\n            decomposed_g.append(Rz(g.qubit, Float(theta)))\n\n        decomposed_g.append(X90(g.qubit))\n\n        if abs(phi) &gt; ATOL:\n            decomposed_g.append(Rz(g.qubit, Float(phi)))\n\n        return decomposed_g\n</code></pre>"},{"location":"reference/decomposer/mckay_decomposer.html#opensquirrel.decomposer.mckay_decomposer.McKayDecomposer.decompose","title":"<code>decompose(g)</code>","text":"<p>Return the McKay decomposition of a 1-qubit gate as a list of gates.         gate   ----&gt;    Rz.Rx(pi/2).Rz.Rx(pi/2).Rz</p> <p>The global phase is deemed irrelevant, therefore a simulator backend might produce different output. The results should be equivalent modulo global phase. Notice that, if the gate is Rz or X90, it will not be decomposed further, since they are natively used in the McKay decomposition.</p> <p>Relevant literature: https://arxiv.org/abs/1612.00858</p> Source code in <code>opensquirrel\\decomposer\\mckay_decomposer.py</code> <pre><code>def decompose(self, g: Gate) -&gt; list[Gate]:\n    \"\"\"Return the McKay decomposition of a 1-qubit gate as a list of gates.\n            gate   ----&gt;    Rz.Rx(pi/2).Rz.Rx(pi/2).Rz\n\n    The global phase is deemed _irrelevant_, therefore a simulator backend might produce different output.\n    The results should be equivalent modulo global phase.\n    Notice that, if the gate is Rz or X90, it will not be decomposed further, since they are natively used\n    in the McKay decomposition.\n\n    Relevant literature: https://arxiv.org/abs/1612.00858\n    \"\"\"\n    if not isinstance(g, BlochSphereRotation) or g.name == \"Rz\" or g.name == \"X90\":\n        return [g]\n\n    if abs(g.angle) &lt; ATOL:\n        return []\n\n    if g.axis[0] == 0 and g.axis[1] == 0:\n        rz_angle = float(g.angle * g.axis[2])\n        return [Rz(g.qubit, Float(rz_angle))]\n\n    zxz_decomposition = ZXZDecomposer().decompose(g)\n    zxz_angle = 0.0\n    if len(zxz_decomposition) &gt;= 2 and isinstance(zxz_decomposition[1], BlochSphereRotation):\n        zxz_angle = zxz_decomposition[1].angle\n\n    if abs(zxz_angle - pi / 2) &lt; ATOL:\n        zxz_decomposition[1] = X90(g.qubit)\n        return zxz_decomposition\n\n    # McKay decomposition\n    za_mod = sqrt(cos(g.angle / 2) ** 2 + (g.axis[2] * sin(g.angle / 2)) ** 2)\n    zb_mod = abs(sin(g.angle / 2)) * sqrt(g.axis[0] ** 2 + g.axis[1] ** 2)\n\n    theta = pi - 2 * atan2(zb_mod, za_mod)\n\n    alpha = atan2(-sin(g.angle / 2) * g.axis[2], cos(g.angle / 2))\n    beta = atan2(-sin(g.angle / 2) * g.axis[0], -sin(g.angle / 2) * g.axis[1])\n\n    lam = beta - alpha\n    phi = -beta - alpha - pi\n\n    lam = normalize_angle(lam)\n    phi = normalize_angle(phi)\n    theta = normalize_angle(theta)\n\n    decomposed_g: list[Gate] = []\n\n    if abs(theta) &lt; ATOL and lam == phi:\n        decomposed_g.append(X90(g.qubit))\n        decomposed_g.append(X90(g.qubit))\n        return decomposed_g\n\n    if abs(lam) &gt; ATOL:\n        decomposed_g.append(Rz(g.qubit, Float(lam)))\n\n    decomposed_g.append(X90(g.qubit))\n\n    if abs(theta) &gt; ATOL:\n        decomposed_g.append(Rz(g.qubit, Float(theta)))\n\n    decomposed_g.append(X90(g.qubit))\n\n    if abs(phi) &gt; ATOL:\n        decomposed_g.append(Rz(g.qubit, Float(phi)))\n\n    return decomposed_g\n</code></pre>"},{"location":"reference/exporter/export_format.html","title":"export_format","text":""},{"location":"reference/exporter/quantify_scheduler_exporter.html","title":"quantify_scheduler_exporter","text":""},{"location":"reference/mapper/general_mapper.html","title":"general_mapper","text":"<p>This module contains generic mapping components.</p>"},{"location":"reference/mapper/general_mapper.html#opensquirrel.mapper.general_mapper.Mapper","title":"<code>Mapper</code>","text":"<p>Base class for the Mapper pass.</p> Source code in <code>opensquirrel\\mapper\\general_mapper.py</code> <pre><code>class Mapper:\n    \"\"\"Base class for the Mapper pass.\"\"\"\n\n    def __init__(self, qubit_register_size: int, mapping: Mapping | None = None) -&gt; None:\n        \"\"\"Use ``IdentityMapper`` as the fallback case for ``Mapper``\"\"\"\n        physical_qubit_register = list(range(qubit_register_size))\n        self.mapping = mapping if mapping is not None else Mapping(physical_qubit_register)\n\n        if qubit_register_size != self.mapping.size():\n            msg = \"qubit register size and mapping size differ\"\n            raise ValueError(msg)\n\n    def get_mapping(self) -&gt; Mapping:\n        \"\"\"Get mapping.\"\"\"\n        return self.mapping\n</code></pre>"},{"location":"reference/mapper/general_mapper.html#opensquirrel.mapper.general_mapper.Mapper.__init__","title":"<code>__init__(qubit_register_size, mapping=None)</code>","text":"<p>Use <code>IdentityMapper</code> as the fallback case for <code>Mapper</code></p> Source code in <code>opensquirrel\\mapper\\general_mapper.py</code> <pre><code>def __init__(self, qubit_register_size: int, mapping: Mapping | None = None) -&gt; None:\n    \"\"\"Use ``IdentityMapper`` as the fallback case for ``Mapper``\"\"\"\n    physical_qubit_register = list(range(qubit_register_size))\n    self.mapping = mapping if mapping is not None else Mapping(physical_qubit_register)\n\n    if qubit_register_size != self.mapping.size():\n        msg = \"qubit register size and mapping size differ\"\n        raise ValueError(msg)\n</code></pre>"},{"location":"reference/mapper/general_mapper.html#opensquirrel.mapper.general_mapper.Mapper.get_mapping","title":"<code>get_mapping()</code>","text":"<p>Get mapping.</p> Source code in <code>opensquirrel\\mapper\\general_mapper.py</code> <pre><code>def get_mapping(self) -&gt; Mapping:\n    \"\"\"Get mapping.\"\"\"\n    return self.mapping\n</code></pre>"},{"location":"reference/mapper/mapping.html","title":"mapping","text":""},{"location":"reference/mapper/mapping.html#opensquirrel.mapper.mapping.Mapping","title":"<code>Mapping</code>","text":"A Mapping is a dictionary where <ul> <li>the keys are virtual qubit indices (from 0 to virtual_qubit_register_size-1), and</li> <li>the values are physical qubit indices.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>physical_qubit_register</code> <code>list[int]</code> <p>a list of physical qubit indices.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the mapping is incorrect.</p> Source code in <code>opensquirrel\\mapper\\mapping.py</code> <pre><code>class Mapping:\n    \"\"\"A Mapping is a dictionary where:\n       - the keys are virtual qubit indices (from 0 to virtual_qubit_register_size-1), and\n       - the values are physical qubit indices.\n\n    Args:\n        physical_qubit_register: a list of physical qubit indices.\n\n    Raises:\n        ValueError: If the mapping is incorrect.\n    \"\"\"\n\n    def __init__(self, physical_qubit_register: list[int]) -&gt; None:\n        self.data: dict[int, int] = dict(enumerate(physical_qubit_register))\n        if (self.data.keys()) != set(self.data.values()):\n            msg = \"the mapping is incorrect\"\n            raise ValueError(msg)\n\n    def __eq__(self, other: Any) -&gt; bool:\n        if not isinstance(other, Mapping):\n            return False\n        return self.data == other.data\n\n    def __getitem__(self, key: int) -&gt; int:\n        return self.data[key]\n\n    def __len__(self) -&gt; int:\n        return len(self.data)\n\n    def size(self) -&gt; int:\n        return len(self.data)\n\n    def items(self) -&gt; list[tuple[int, int]]:\n        return list(self.data.items())\n\n    def keys(self) -&gt; list[int]:\n        return list(self.data.keys())\n\n    def values(self) -&gt; list[int]:\n        return list(self.data.values())\n</code></pre>"},{"location":"reference/mapper/qubit_remapper.html","title":"qubit_remapper","text":""},{"location":"reference/mapper/simple_mappers.html","title":"simple_mappers","text":"<p>This module contains the following simple mappers:</p> <ul> <li>IdentityMapper</li> <li>HardcodedMapper</li> </ul>"},{"location":"reference/mapper/simple_mappers.html#opensquirrel.mapper.simple_mappers.HardcodedMapper","title":"<code>HardcodedMapper</code>","text":"<p>               Bases: <code>Mapper</code></p> Source code in <code>opensquirrel\\mapper\\simple_mappers.py</code> <pre><code>class HardcodedMapper(Mapper):\n    def __init__(self, qubit_register_size: int, mapping: Mapping) -&gt; None:\n        \"\"\"A ``HardcodedMapper`` maps each virtual qubit to a hardcoded physical qubit\"\"\"\n        super().__init__(qubit_register_size, mapping)\n</code></pre>"},{"location":"reference/mapper/simple_mappers.html#opensquirrel.mapper.simple_mappers.HardcodedMapper.__init__","title":"<code>__init__(qubit_register_size, mapping)</code>","text":"<p>A <code>HardcodedMapper</code> maps each virtual qubit to a hardcoded physical qubit</p> Source code in <code>opensquirrel\\mapper\\simple_mappers.py</code> <pre><code>def __init__(self, qubit_register_size: int, mapping: Mapping) -&gt; None:\n    \"\"\"A ``HardcodedMapper`` maps each virtual qubit to a hardcoded physical qubit\"\"\"\n    super().__init__(qubit_register_size, mapping)\n</code></pre>"},{"location":"reference/mapper/simple_mappers.html#opensquirrel.mapper.simple_mappers.IdentityMapper","title":"<code>IdentityMapper</code>","text":"<p>               Bases: <code>Mapper</code></p> Source code in <code>opensquirrel\\mapper\\simple_mappers.py</code> <pre><code>class IdentityMapper(Mapper):\n    def __init__(self, qubit_register_size: int) -&gt; None:\n        \"\"\"An ``IdentityMapper`` maps each virtual qubit to exactly the same physical qubit.\"\"\"\n        super().__init__(qubit_register_size)\n</code></pre>"},{"location":"reference/mapper/simple_mappers.html#opensquirrel.mapper.simple_mappers.IdentityMapper.__init__","title":"<code>__init__(qubit_register_size)</code>","text":"<p>An <code>IdentityMapper</code> maps each virtual qubit to exactly the same physical qubit.</p> Source code in <code>opensquirrel\\mapper\\simple_mappers.py</code> <pre><code>def __init__(self, qubit_register_size: int) -&gt; None:\n    \"\"\"An ``IdentityMapper`` maps each virtual qubit to exactly the same physical qubit.\"\"\"\n    super().__init__(qubit_register_size)\n</code></pre>"},{"location":"reference/mapper/utils.html","title":"utils","text":""},{"location":"reference/merger/general_merger.html","title":"general_merger","text":""},{"location":"reference/merger/general_merger.html#opensquirrel.merger.general_merger.compose_bloch_sphere_rotations","title":"<code>compose_bloch_sphere_rotations(a, b)</code>","text":"<p>Computes the Bloch sphere rotation resulting from the composition of two Bloch sphere rotations. The first rotation is applied and then the second. The resulting gate is anonymous except if <code>a</code> is the identity and <code>b</code> is not anonymous, or vice versa.</p> <p>Uses Rodrigues' rotation formula, see for instance https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula.</p> Source code in <code>opensquirrel\\merger\\general_merger.py</code> <pre><code>def compose_bloch_sphere_rotations(a: BlochSphereRotation, b: BlochSphereRotation) -&gt; BlochSphereRotation:\n    \"\"\"Computes the Bloch sphere rotation resulting from the composition of two Bloch sphere rotations.\n    The first rotation is applied and then the second.\n    The resulting gate is anonymous except if `a` is the identity and `b` is not anonymous, or vice versa.\n\n    Uses Rodrigues' rotation formula, see for instance https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula.\n    \"\"\"\n    if a.qubit != b.qubit:\n        msg = \"cannot merge two BlochSphereRotation's on different qubits\"\n        raise ValueError(msg)\n\n    acos_argument = cos(a.angle / 2) * cos(b.angle / 2) - sin(a.angle / 2) * sin(b.angle / 2) * np.dot(a.axis, b.axis)\n    # This fixes float approximations like 1.0000000000002 which acos doesn't like.\n    acos_argument = max(min(acos_argument, 1.0), -1.0)\n\n    combined_angle = 2 * acos(acos_argument)\n\n    if abs(sin(combined_angle / 2)) &lt; ATOL:\n        return BlochSphereRotation.identity(a.qubit)\n\n    order_of_magnitude = abs(floor(log10(ATOL)))\n    combined_axis = np.round(\n        (\n            1\n            / sin(combined_angle / 2)\n            * (\n                sin(a.angle / 2) * cos(b.angle / 2) * a.axis.value\n                + cos(a.angle / 2) * sin(b.angle / 2) * b.axis.value\n                + sin(a.angle / 2) * sin(b.angle / 2) * np.cross(a.axis, b.axis)\n            )\n        ),\n        order_of_magnitude,\n    )\n\n    combined_phase = np.round(a.phase + b.phase, order_of_magnitude)\n\n    generator = b.generator if a.is_identity() else a.generator if b.is_identity() else None\n    arguments = b.arguments if a.is_identity() else a.arguments if b.is_identity() else None\n\n    return BlochSphereRotation(\n        qubit=a.qubit,\n        axis=combined_axis,\n        angle=combined_angle,\n        phase=combined_phase,\n        generator=generator,  # type: ignore[arg-type]\n        arguments=arguments,\n    )\n</code></pre>"},{"location":"reference/merger/general_merger.html#opensquirrel.merger.general_merger.merge_single_qubit_gates","title":"<code>merge_single_qubit_gates(circuit)</code>","text":"<p>Merge all consecutive 1-qubit gates in the circuit.</p> <p>Gates obtained from merging other gates become anonymous gates.</p> Source code in <code>opensquirrel\\merger\\general_merger.py</code> <pre><code>def merge_single_qubit_gates(circuit: Circuit) -&gt; None:\n    \"\"\"Merge all consecutive 1-qubit gates in the circuit.\n\n    Gates obtained from merging other gates become anonymous gates.\n    \"\"\"\n    accumulators_per_qubit: dict[Qubit, BlochSphereRotation] = {\n        Qubit(qubit_index): I(Qubit(qubit_index)) for qubit_index in range(circuit.qubit_register_size)\n    }\n\n    ir = circuit.ir\n    statement_index = 0\n    while statement_index &lt; len(ir.statements):\n        statement = ir.statements[statement_index]\n\n        if isinstance(statement, Comment):\n            # Skip, since statement is a comment\n            statement_index += 1\n            continue\n\n        if isinstance(statement, BlochSphereRotation):\n            # Accumulate consecutive Bloch sphere rotations\n            already_accumulated = accumulators_per_qubit[statement.qubit]\n\n            composed = compose_bloch_sphere_rotations(statement, already_accumulated)\n            accumulators_per_qubit[statement.qubit] = composed\n\n            del ir.statements[statement_index]\n            continue\n\n        # Skip controlled-gates, measure, reset, and reset accumulator for their qubit operands\n        for qubit_operand in statement.get_qubit_operands():  # type: ignore\n            if not accumulators_per_qubit[qubit_operand].is_identity():\n                ir.statements.insert(statement_index, accumulators_per_qubit[qubit_operand])\n                accumulators_per_qubit[qubit_operand] = I(qubit_operand)\n                statement_index += 1\n\n        statement_index += 1\n\n    for accumulated_bloch_sphere_rotation in accumulators_per_qubit.values():\n        if not accumulated_bloch_sphere_rotation.is_identity():\n            if accumulated_bloch_sphere_rotation.is_anonymous:\n                accumulated_bloch_sphere_rotation = try_name_anonymous_bloch(accumulated_bloch_sphere_rotation)\n            ir.statements.append(accumulated_bloch_sphere_rotation)\n</code></pre>"},{"location":"reference/merger/general_merger.html#opensquirrel.merger.general_merger.try_name_anonymous_bloch","title":"<code>try_name_anonymous_bloch(bsr)</code>","text":"<p>Try converting a given BlochSphereRotation to a default BlochSphereRotation.  It does that by checking if the input BlochSphereRotation is close to a default BlochSphereRotation.</p> <p>Notice we don't try to match Rx, Ry, and Rz rotations, as those gates use an extra angle parameter.</p> <p>Returns:</p> Type Description <code>BlochSphereRotation</code> <p>A default BlockSphereRotation if this BlochSphereRotation is close to it,</p> <code>BlochSphereRotation</code> <p>or the input BlochSphereRotation otherwise.</p> Source code in <code>opensquirrel\\merger\\general_merger.py</code> <pre><code>def try_name_anonymous_bloch(bsr: BlochSphereRotation) -&gt; BlochSphereRotation:\n    \"\"\"Try converting a given BlochSphereRotation to a default BlochSphereRotation.\n     It does that by checking if the input BlochSphereRotation is close to a default BlochSphereRotation.\n\n    Notice we don't try to match Rx, Ry, and Rz rotations, as those gates use an extra angle parameter.\n\n    Returns:\n         A default BlockSphereRotation if this BlochSphereRotation is close to it,\n         or the input BlochSphereRotation otherwise.\n    \"\"\"\n    for gate_function in default_bloch_sphere_rotations_without_params:\n        gate = gate_function(*bsr.get_qubit_operands())\n        if (\n            np.allclose(gate.axis, bsr.axis)\n            and np.allclose(gate.angle, bsr.angle)\n            and np.allclose(gate.phase, bsr.phase)\n        ):\n            return gate\n    return bsr\n</code></pre>"},{"location":"reference/parser/libqasm/parser.html","title":"parser","text":""},{"location":"reference/parser/libqasm/parser.html#opensquirrel.parser.libqasm.parser.Parser","title":"<code>Parser</code>","text":"<p>               Bases: <code>GateLibrary</code>, <code>MeasurementLibrary</code>, <code>ResetLibrary</code></p> Source code in <code>opensquirrel\\parser\\libqasm\\parser.py</code> <pre><code>class Parser(GateLibrary, MeasurementLibrary, ResetLibrary):\n    def __init__(\n        self,\n        gate_set: Iterable[Callable[..., Gate]] = default_gate_set,\n        gate_aliases: Mapping[str, Callable[..., Gate]] = default_gate_aliases,\n        measurement_set: Iterable[Callable[..., Measure]] = default_measurement_set,\n        reset_set: Iterable[Callable[..., Reset]] = default_reset_set,\n    ) -&gt; None:\n        GateLibrary.__init__(self, gate_set, gate_aliases)\n        MeasurementLibrary.__init__(self, measurement_set)\n        ResetLibrary.__init__(self, reset_set)\n        self.ir = None\n\n    @staticmethod\n    def _ast_literal_to_ir_literal(\n        cqasm_literal_expression: cqasm.values.ConstInt | cqasm.values.ConstFloat,\n    ) -&gt; Int | Float | None:\n        if type(cqasm_literal_expression) not in [cqasm.values.ConstInt, cqasm.values.ConstFloat]:\n            msg = f\"unrecognized type: {type(cqasm_literal_expression)}\"\n            raise TypeError(msg)\n        if isinstance(cqasm_literal_expression, cqasm.values.ConstInt):\n            return Int(cqasm_literal_expression.value)\n        if isinstance(cqasm_literal_expression, cqasm.values.ConstFloat):\n            return Float(cqasm_literal_expression.value)\n        return None\n\n    @staticmethod\n    def _type_of(ast_expression: Any) -&gt; type:\n        if isinstance(ast_expression, (cqasm.values.IndexRef, cqasm.values.VariableRef)):\n            return type(ast_expression.variable.typ)\n        return type(ast_expression)\n\n    @staticmethod\n    def _size_of(ast_expression: Any) -&gt; int:\n        if isinstance(ast_expression, cqasm.values.IndexRef):\n            return len(ast_expression.indices)\n        if isinstance(ast_expression, cqasm.values.VariableRef):\n            return int(ast_expression.variable.typ.size)\n        return 1\n\n    @staticmethod\n    def _is_qubit_type(ast_expression: Any) -&gt; bool:\n        ast_type = Parser._type_of(ast_expression)\n        return bool(ast_type == cqasm.types.Qubit or ast_type == cqasm.types.QubitArray)\n\n    @staticmethod\n    def _is_bit_type(ast_expression: Any) -&gt; bool:\n        ast_type = Parser._type_of(ast_expression)\n        return bool(ast_type == cqasm.types.Bit or ast_type == cqasm.types.BitArray)\n\n    @staticmethod\n    def _get_qubits(\n        ast_qubit_expression: cqasm.values.VariableRef | cqasm.values.IndexRef,\n        register_manager: RegisterManager,\n    ) -&gt; list[Qubit]:\n        ret = []\n        variable_name = ast_qubit_expression.variable.name\n        if isinstance(ast_qubit_expression, cqasm.values.VariableRef):\n            qubit_range = register_manager.get_qubit_range(variable_name)\n            ret = [Qubit(index) for index in range(qubit_range.first, qubit_range.first + qubit_range.size)]\n        if isinstance(ast_qubit_expression, cqasm.values.IndexRef):\n            int_indices = [int(i.value) for i in ast_qubit_expression.indices]\n            indices = [register_manager.get_qubit_index(variable_name, i) for i in int_indices]\n            ret = [Qubit(index) for index in indices]\n        return ret\n\n    @staticmethod\n    def _get_bits(\n        ast_bit_expression: cqasm.values.VariableRef | cqasm.values.IndexRef,\n        register_manager: RegisterManager,\n    ) -&gt; list[Bit]:\n        ret = []\n        variable_name = ast_bit_expression.variable.name\n        if isinstance(ast_bit_expression, cqasm.values.VariableRef):\n            bit_range = register_manager.get_bit_range(variable_name)\n            ret = [Bit(index) for index in range(bit_range.first, bit_range.first + bit_range.size)]\n        if isinstance(ast_bit_expression, cqasm.values.IndexRef):\n            int_indices = [int(i.value) for i in ast_bit_expression.indices]\n            indices = [register_manager.get_bit_index(variable_name, i) for i in int_indices]\n            ret = [Bit(index) for index in indices]\n        return ret\n\n    @classmethod\n    def _get_expanded_measure_args(cls, ast_args: Any, register_manager: RegisterManager) -&gt; zip[tuple[Any, ...]]:\n        \"\"\"Construct a list with a list of bits and a list of qubits, then return a zip of both lists.\n        For example: [(Qubit(0), Bit(0)), (Qubit(1), Bit(1))]\n\n        Notice the  list is walked in reverse mode.\n        This is because the AST measure node has a bit first operand and a qubit second operand.\n        \"\"\"\n        expanded_args: list[list[Any]] = []\n        for ast_arg in reversed(ast_args):\n            if Parser._is_qubit_type(ast_arg):\n                expanded_args.append(cls._get_qubits(ast_arg, register_manager))\n            elif Parser._is_bit_type(ast_arg):\n                expanded_args.append(cls._get_bits(ast_arg, register_manager))\n            else:\n                msg = \"received argument is not a (qu)bit\"\n                raise TypeError(msg)\n        return zip(*expanded_args)\n\n    @classmethod\n    def _get_expanded_reset_args(cls, ast_args: Any, register_manager: RegisterManager) -&gt; zip[tuple[Any, ...]]:\n        \"\"\"Construct a list of qubits and return a zip.\n        For example: [Qubit(0), Qubit(1), Qubit(2)]\n        \"\"\"\n        expanded_args: list[Any] = []\n        if len(ast_args) &lt; 1:\n            expanded_args += [Qubit(qubit_index) for qubit_index in range(register_manager.get_qubit_register_size())]\n            return zip(expanded_args)\n        for ast_arg in ast_args:\n            if Parser._is_qubit_type(ast_arg):\n                expanded_args += cls._get_qubits(ast_arg, register_manager)\n            else:\n                msg = \"received argument is not a (qu)bit\"\n                raise TypeError(msg)\n        return zip(expanded_args)\n\n    @classmethod\n    def _get_expanded_gate_args(cls, ast_args: Any, register_manager: RegisterManager) -&gt; zip[tuple[Any, ...]]:\n        \"\"\"Construct a list with a list of qubits and a list of parameters, then return a zip of both lists.\n        For example: [(Qubit(0), Float(pi)), (Qubit(1), Float(pi))]\n        \"\"\"\n        number_of_operands = 0\n        for ast_arg in ast_args:\n            if Parser._is_qubit_type(ast_arg):\n                number_of_operands += Parser._size_of(ast_arg)\n        expanded_args: list[list[Any]] = []\n        for ast_arg in ast_args:\n            if Parser._is_qubit_type(ast_arg):\n                expanded_args.append(cls._get_qubits(ast_arg, register_manager))\n            else:\n                expanded_args.append([cls._ast_literal_to_ir_literal(ast_arg)] * number_of_operands)\n        return zip(*expanded_args)\n\n    @staticmethod\n    def _create_analyzer() -&gt; cqasm.Analyzer:\n        without_defaults = False\n        return cqasm.Analyzer(\"3.0\", without_defaults)\n\n    @staticmethod\n    def _check_analysis_result(result: Any) -&gt; None:\n        if isinstance(result, list):\n            raise OSError(\"parsing error: \" + \", \".join(result))\n\n    def circuit_from_string(self, s: str) -&gt; Circuit:\n        # Analysis result will be either an Abstract Syntax Tree (AST) or a list of error messages\n        analyzer = Parser._create_analyzer()\n        analysis_result = analyzer.analyze_string(s)\n        Parser._check_analysis_result(analysis_result)\n        ast = analysis_result\n\n        # Create RegisterManager\n        register_manager = RegisterManager.from_ast(ast)\n\n        # Parse statements\n        ir = IR()\n        for statement in ast.block.statements:\n            if \"measure\" in statement.name:\n                generator_f_measure = self.get_measurement_f(statement.name)\n                expanded_args = Parser._get_expanded_measure_args(statement.operands, register_manager)\n                for arg_set in expanded_args:\n                    ir.add_measurement(generator_f_measure(*arg_set))\n            elif \"reset\" in statement.name:\n                generator_f_reset = self.get_reset_f(statement.name)\n                expanded_args = Parser._get_expanded_reset_args(statement.operands, register_manager)\n                for arg_set in expanded_args:\n                    ir.add_reset(generator_f_reset(*arg_set))\n            else:\n                generator_f_gate = self.get_gate_f(statement.name)\n                expanded_args = Parser._get_expanded_gate_args(statement.operands, register_manager)\n                for arg_set in expanded_args:\n                    ir.add_gate(generator_f_gate(*arg_set))\n\n        return Circuit(register_manager, ir)\n</code></pre>"},{"location":"reference/reindexer/qubit_reindexer.html","title":"qubit_reindexer","text":""},{"location":"reference/utils/identity_filter.html","title":"identity_filter","text":""},{"location":"reference/utils/matrix_expander.html","title":"matrix_expander","text":""},{"location":"reference/utils/matrix_expander.html#opensquirrel.utils.matrix_expander.expand_ket","title":"<code>expand_ket(base_ket, reduced_ket, qubits)</code>","text":"<p>Given a base quantum ket on n qubits and a reduced ket on a subset of those qubits, this computes the expanded ket where the reduction qubits and the other qubits are set based on the reduced ket and the base ket, respectively. Roughly equivalent to the <code>pdep</code> assembly instruction (bits deposit).</p> <p>Parameters:</p> Name Type Description Default <code>base_ket</code> <code>int</code> <p>A quantum ket, represented by its corresponding non-negative integer.       By convention, qubit #0 corresponds to the least significant bit.</p> required <code>reduced_ket</code> <code>int</code> <p>A quantum ket, represented by its corresponding non-negative integer.          By convention, qubit #0 corresponds to the least significant bit.</p> required <code>qubits</code> <code>Iterable[Qubit]</code> <p>The indices of the qubits to expand from the reduced ket. Order matters.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The non-negative integer corresponding to the expanded ket.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; expand_ket(0b00000, 0b0, [Qubit(5)])   # 0b000000\n0\n&gt;&gt;&gt; expand_ket(0b00000, 0b1, [Qubit(5)])   # 0b100000\n32\n&gt;&gt;&gt; expand_ket(0b00111, 0b0, [Qubit(5)])   # 0b000111\n7\n&gt;&gt;&gt; expand_ket(0b00111, 0b1, [Qubit(5)])   # 0b100111\n39\n&gt;&gt;&gt; expand_ket(0b0000, 0b000, [Qubit(1), Qubit(2), Qubit(3)])    # 0b0000\n0\n&gt;&gt;&gt; expand_ket(0b0000, 0b001, [Qubit(1), Qubit(2), Qubit(3)])    # 0b0010\n2\n&gt;&gt;&gt; expand_ket(0b0000, 0b011, [Qubit(1), Qubit(2), Qubit(3)])    # 0b0110\n6\n&gt;&gt;&gt; expand_ket(0b0000, 0b101, [Qubit(1), Qubit(2), Qubit(3)])   # 0b1010\n10\n&gt;&gt;&gt; expand_ket(0b0001, 0b101, [Qubit(1), Qubit(2), Qubit(3)])   # 0b1011\n11\n</code></pre> Source code in <code>opensquirrel\\utils\\matrix_expander.py</code> <pre><code>def expand_ket(base_ket: int, reduced_ket: int, qubits: Iterable[Qubit]) -&gt; int:\n    \"\"\"\n    Given a base quantum ket on n qubits and a reduced ket on a subset of those qubits, this computes the expanded ket\n    where the reduction qubits and the other qubits are set based on the reduced ket and the base ket, respectively.\n    Roughly equivalent to the `pdep` assembly instruction (bits deposit).\n\n    Args:\n        base_ket: A quantum ket, represented by its corresponding non-negative integer.\n                  By convention, qubit #0 corresponds to the least significant bit.\n        reduced_ket: A quantum ket, represented by its corresponding non-negative integer.\n                     By convention, qubit #0 corresponds to the least significant bit.\n        qubits: The indices of the qubits to expand from the reduced ket. Order matters.\n\n    Returns:\n        The non-negative integer corresponding to the expanded ket.\n\n    Examples:\n        &gt;&gt;&gt; expand_ket(0b00000, 0b0, [Qubit(5)])   # 0b000000\n        0\n        &gt;&gt;&gt; expand_ket(0b00000, 0b1, [Qubit(5)])   # 0b100000\n        32\n        &gt;&gt;&gt; expand_ket(0b00111, 0b0, [Qubit(5)])   # 0b000111\n        7\n        &gt;&gt;&gt; expand_ket(0b00111, 0b1, [Qubit(5)])   # 0b100111\n        39\n        &gt;&gt;&gt; expand_ket(0b0000, 0b000, [Qubit(1), Qubit(2), Qubit(3)])    # 0b0000\n        0\n        &gt;&gt;&gt; expand_ket(0b0000, 0b001, [Qubit(1), Qubit(2), Qubit(3)])    # 0b0010\n        2\n        &gt;&gt;&gt; expand_ket(0b0000, 0b011, [Qubit(1), Qubit(2), Qubit(3)])    # 0b0110\n        6\n        &gt;&gt;&gt; expand_ket(0b0000, 0b101, [Qubit(1), Qubit(2), Qubit(3)])   # 0b1010\n        10\n        &gt;&gt;&gt; expand_ket(0b0001, 0b101, [Qubit(1), Qubit(2), Qubit(3)])   # 0b1011\n        11\n    \"\"\"\n    expanded_ket = base_ket\n    for i, qubit in enumerate(qubits):\n        expanded_ket &amp;= ~(1 &lt;&lt; qubit.index)  # Erase bit.\n        expanded_ket |= ((reduced_ket &amp; (1 &lt;&lt; i)) &gt;&gt; i) &lt;&lt; qubit.index  # Set bit to value from reduced_ket.\n\n    return expanded_ket\n</code></pre>"},{"location":"reference/utils/matrix_expander.html#opensquirrel.utils.matrix_expander.get_matrix","title":"<code>get_matrix(gate, qubit_register_size)</code>","text":"<p>Compute the unitary matrix corresponding to the gate applied to those qubit operands, taken among any number of qubits. This can be used for, e.g., - testing, - permuting the operands of multi-qubit gates, - simulating a circuit (simulation in this way is inefficient for large numbers of qubits).</p> <p>Parameters:</p> Name Type Description Default <code>gate</code> <code>Gate</code> <p>The gate, including the qubits on which it is operated on.</p> required <code>qubit_register_size</code> <code>int</code> <p>The size of the qubit register.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; X = lambda q: BlochSphereRotation(qubit=q, axis=(1, 0, 0), angle=math.pi, phase=math.pi / 2)\n&gt;&gt;&gt; get_matrix(X(Qubit(1)), 2).astype(int)           # X q[1]\narray([[0, 0, 1, 0],\n       [0, 0, 0, 1],\n       [1, 0, 0, 0],\n       [0, 1, 0, 0]])\n</code></pre> <pre><code>&gt;&gt;&gt; CNOT02 = ControlledGate(Qubit(0), X(Qubit(2)))\n&gt;&gt;&gt; get_matrix(CNOT02, 3).astype(int)     # CNOT q[0], q[2]\narray([[1, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 1, 0, 0],\n       [0, 0, 1, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 1],\n       [0, 0, 0, 0, 1, 0, 0, 0],\n       [0, 1, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 1, 0],\n       [0, 0, 0, 1, 0, 0, 0, 0]])\n&gt;&gt;&gt; get_matrix(ControlledGate(Qubit(1), X(Qubit(2))), 3).astype(int)     # CNOT q[1], q[2]\narray([[1, 0, 0, 0, 0, 0, 0, 0],\n       [0, 1, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 1, 0],\n       [0, 0, 0, 0, 0, 0, 0, 1],\n       [0, 0, 0, 0, 1, 0, 0, 0],\n       [0, 0, 0, 0, 0, 1, 0, 0],\n       [0, 0, 1, 0, 0, 0, 0, 0],\n       [0, 0, 0, 1, 0, 0, 0, 0]])\n</code></pre> Source code in <code>opensquirrel\\utils\\matrix_expander.py</code> <pre><code>def get_matrix(gate: Gate, qubit_register_size: int) -&gt; NDArray[np.complex128]:\n    \"\"\"\n    Compute the unitary matrix corresponding to the gate applied to those qubit operands, taken among any number of\n    qubits. This can be used for, e.g.,\n    - testing,\n    - permuting the operands of multi-qubit gates,\n    - simulating a circuit (simulation in this way is inefficient for large numbers of qubits).\n\n    Args:\n        gate: The gate, including the qubits on which it is operated on.\n        qubit_register_size: The size of the qubit register.\n\n    Examples:\n        &gt;&gt;&gt; X = lambda q: BlochSphereRotation(qubit=q, axis=(1, 0, 0), angle=math.pi, phase=math.pi / 2)\n        &gt;&gt;&gt; get_matrix(X(Qubit(1)), 2).astype(int)           # X q[1]\n        array([[0, 0, 1, 0],\n               [0, 0, 0, 1],\n               [1, 0, 0, 0],\n               [0, 1, 0, 0]])\n\n        &gt;&gt;&gt; CNOT02 = ControlledGate(Qubit(0), X(Qubit(2)))\n        &gt;&gt;&gt; get_matrix(CNOT02, 3).astype(int)     # CNOT q[0], q[2]\n        array([[1, 0, 0, 0, 0, 0, 0, 0],\n               [0, 0, 0, 0, 0, 1, 0, 0],\n               [0, 0, 1, 0, 0, 0, 0, 0],\n               [0, 0, 0, 0, 0, 0, 0, 1],\n               [0, 0, 0, 0, 1, 0, 0, 0],\n               [0, 1, 0, 0, 0, 0, 0, 0],\n               [0, 0, 0, 0, 0, 0, 1, 0],\n               [0, 0, 0, 1, 0, 0, 0, 0]])\n        &gt;&gt;&gt; get_matrix(ControlledGate(Qubit(1), X(Qubit(2))), 3).astype(int)     # CNOT q[1], q[2]\n        array([[1, 0, 0, 0, 0, 0, 0, 0],\n               [0, 1, 0, 0, 0, 0, 0, 0],\n               [0, 0, 0, 0, 0, 0, 1, 0],\n               [0, 0, 0, 0, 0, 0, 0, 1],\n               [0, 0, 0, 0, 1, 0, 0, 0],\n               [0, 0, 0, 0, 0, 1, 0, 0],\n               [0, 0, 1, 0, 0, 0, 0, 0],\n               [0, 0, 0, 1, 0, 0, 0, 0]])\n    \"\"\"\n    expander = MatrixExpander(qubit_register_size)\n    return cast(NDArray[np.complex128], gate.accept(expander))\n</code></pre>"},{"location":"reference/utils/matrix_expander.html#opensquirrel.utils.matrix_expander.get_reduced_ket","title":"<code>get_reduced_ket(ket, qubits)</code>","text":"<p>Given a quantum ket represented by its corresponding base-10 integer, this computes the reduced ket where only the given qubits appear, in order. Roughly equivalent to the <code>pext</code> assembly instruction (bits extraction).</p> <p>Parameters:</p> Name Type Description Default <code>ket</code> <code>int</code> <p>A quantum ket, represented by its corresponding non-negative integer.  By convention, qubit #0 corresponds to the least significant bit.</p> required <code>qubits</code> <code>Iterable[Qubit]</code> <p>The indices of the qubits to extract. Order matters.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The non-negative integer corresponding to the reduced ket.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; get_reduced_ket(1, [Qubit(0)])         # 0b01\n1\n&gt;&gt;&gt; get_reduced_ket(1111, [Qubit(2)])      # 0b01\n1\n&gt;&gt;&gt; get_reduced_ket(1111, [Qubit(5)])      # 0b0\n0\n&gt;&gt;&gt; get_reduced_ket(1111, [Qubit(2), Qubit(5)])   # 0b01\n1\n&gt;&gt;&gt; get_reduced_ket(101, [Qubit(1), Qubit(0)])    # 0b10\n2\n&gt;&gt;&gt; get_reduced_ket(101, [Qubit(0), Qubit(1)])    # 0b01\n1\n</code></pre> Source code in <code>opensquirrel\\utils\\matrix_expander.py</code> <pre><code>def get_reduced_ket(ket: int, qubits: Iterable[Qubit]) -&gt; int:\n    \"\"\"\n    Given a quantum ket represented by its corresponding base-10 integer, this computes the reduced ket\n    where only the given qubits appear, in order.\n    Roughly equivalent to the `pext` assembly instruction (bits extraction).\n\n    Args:\n        ket: A quantum ket, represented by its corresponding non-negative integer.\n             By convention, qubit #0 corresponds to the least significant bit.\n        qubits: The indices of the qubits to extract. Order matters.\n\n    Returns:\n        The non-negative integer corresponding to the reduced ket.\n\n    Examples:\n        &gt;&gt;&gt; get_reduced_ket(1, [Qubit(0)])         # 0b01\n        1\n        &gt;&gt;&gt; get_reduced_ket(1111, [Qubit(2)])      # 0b01\n        1\n        &gt;&gt;&gt; get_reduced_ket(1111, [Qubit(5)])      # 0b0\n        0\n        &gt;&gt;&gt; get_reduced_ket(1111, [Qubit(2), Qubit(5)])   # 0b01\n        1\n        &gt;&gt;&gt; get_reduced_ket(101, [Qubit(1), Qubit(0)])    # 0b10\n        2\n        &gt;&gt;&gt; get_reduced_ket(101, [Qubit(0), Qubit(1)])    # 0b01\n        1\n    \"\"\"\n    reduced_ket = 0\n    for i, qubit in enumerate(qubits):\n        reduced_ket |= ((ket &amp; (1 &lt;&lt; qubit.index)) &gt;&gt; qubit.index) &lt;&lt; i\n\n    return reduced_ket\n</code></pre>"},{"location":"reference/utils/check_passes/check_mapper.html","title":"check_mapper","text":"<p>This module contains checks for the <code>Mapper</code> pass.</p>"},{"location":"reference/utils/check_passes/check_mapper.html#opensquirrel.utils.check_passes.check_mapper.check_mapper","title":"<code>check_mapper(mapper)</code>","text":"<p>Check if the <code>mapper</code> complies with the OpenSquirrel requirements.</p> <p>If an implementation of <code>Mapper</code> passes these checks it should be compatible with the <code>Circuit.map</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>mapper</code> <code>Mapper</code> <p>Mapper to check.</p> required Source code in <code>opensquirrel\\utils\\check_passes\\check_mapper.py</code> <pre><code>def check_mapper(mapper: Mapper) -&gt; None:\n    \"\"\"Check if the `mapper` complies with the OpenSquirrel requirements.\n\n    If an implementation of ``Mapper`` passes these checks it should be compatible with the ``Circuit.map`` method.\n\n    Args:\n        mapper: Mapper to check.\n    \"\"\"\n    assert isinstance(mapper, Mapper)\n\n    register_manager = RegisterManager(QubitRegister(10), BitRegister(10))\n    ir = IR()\n    circuit = Circuit(register_manager, ir)\n    _check_scenario(circuit, mapper)\n\n    ir = IR()\n    ir.add_comment(Comment(\"comment\"))\n    ir.add_gate(BlochSphereRotation(Qubit(42), (1, 0, 0), 1, 2))\n    ir.add_gate(ControlledGate(Qubit(42), BlochSphereRotation.identity(Qubit(100))))\n    ir.add_measurement(Measure(Qubit(42), Bit(42), (0, 0, 1)))\n    Circuit(register_manager, ir)\n    _check_scenario(circuit, mapper)\n</code></pre>"},{"location":"reference/writer/writer.html","title":"writer","text":""}]}